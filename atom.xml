<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dasasdhba</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dasasdhba.github.io/"/>
  <updated>2023-06-09T07:29:31.222Z</updated>
  <id>http://dasasdhba.github.io/</id>
  
  <author>
    <name>dasasdhba</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数值分析复习笔记</title>
    <link href="http://dasasdhba.github.io/study-numeric-analysis/"/>
    <id>http://dasasdhba.github.io/study-numeric-analysis/</id>
    <published>2023-04-24T06:10:28.000Z</published>
    <updated>2023-06-09T07:29:31.222Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为应付考试而整理的复习笔记，因而只是整理我个人认为考前需要速通的点，因而不一定全面以及完备。</p><h1 id="误差分析">误差分析</h1><h2 id="两类基本误差">两类基本误差</h2><ul><li><p>绝对误差：<span class="math inline">\(e_{\bar{x}}=x-\bar{x}\)</span></p></li><li><p>相对误差：<span class="math inline">\(r_{\bar{x}}=\frac{e_{\bar{x}}}x\)</span></p><p>由于 <span class="math inline">\(x\)</span> 往往未知，在 <span class="math inline">\(r_{\bar{x}}\)</span> 很小的时候，可以用 <span class="math inline">\(r^*_{\bar{x}}=\frac{e_{\bar{x}}}{\bar{x}}\)</span> 近似</p></li></ul><h2 id="舍入误差与有效数字">舍入误差与有效数字</h2><p>记十进制数 <span class="math inline">\(a\)</span> 某个数码 <span class="math inline">\(a_s\)</span> 的位数为 <span class="math inline">\(k(a_s)\)</span>，当 <span class="math inline">\(a_s\)</span> 在个位时取 0，十位时取 1，小数点后第一位时取 -1，以此类推</p><ul><li><p>舍入误差：将 a 四舍五入至 <span class="math inline">\(k\)</span> 位小数，那么 <span class="math inline">\(|e_{\bar{a}}|\leq\frac12\times10^{-k}\)</span></p></li><li><p>有效数字：设 <span class="math inline">\(\bar{a}\)</span> 为 <span class="math inline">\(a\)</span> 的近似值，从 <span class="math inline">\(\bar{a}\)</span> 中首位不为零的数码起，称数码 <span class="math inline">\(a_s\)</span> 为有效数字，若满足： <span class="math display">\[|e_{\bar{a}}|\leq\frac12\times10^{k(a_s)}\]</span> （因而对于四舍五入得到的近似值，从首位不为零的数码起，所有数码都是有效数字）</p></li></ul><p>利用有效数字，我们有如下<strong>相对误差估计</strong>：</p><p>设 <span class="math inline">\(\bar{a}\)</span> 有 <span class="math inline">\(k\)</span> 位有效数字，其中第一位有效数字为 <span class="math inline">\(a_s\)</span>，那么： <span class="math display">\[|r^*_{\bar{a}}|\leq\frac1{2a_s}\times10^{-(k-1)}\]</span> 反之，若有上述不等式成立，则 <span class="math inline">\(\bar{a}\)</span> 至少有 <span class="math inline">\(k\)</span> 位有效数字</p><p>（这说明有效数字越多，相对误差越小）</p><h2 id="运算中的误差传播">运算中的误差传播</h2><p>考察二元函数 <span class="math inline">\(z=f(x,y)\)</span> 产生的误差：<span class="math inline">\(e_{\bar{z}}=f(x,y)-f(\bar{x},\bar{y})\)</span></p><p>当 <span class="math inline">\(|e_{\bar{x}}|,|e_{\bar{y}}|\)</span> 很小，且 <span class="math inline">\(f\)</span> 可微时，有近似公式： <span class="math display">\[e_{\bar{z}}\approx \frac{\partial f}{\partial x}(\bar{x},\bar{y})\:e_{\bar{x}}+\frac{\partial f}{\partial y}(\bar{x},\bar{y})\:e_{\bar{y}}\\r_{\bar{z}}\approx \frac{\bar{x}}{\bar{z}}\frac{\partial f}{\partial x}(\bar{x},\bar{y})\:r_{\bar{x}}+\frac{\bar{y}}{\bar{z}}\frac{\partial f}{\partial y}(\bar{x},\bar{y})\:r_{\bar{y}}\]</span> （对于 <span class="math inline">\(r^*\)</span> 亦有类似的近似）</p><p>由此导出：</p><ol type="1"><li><p><span class="math inline">\(f(x,y)=x\pm y\)</span> <span class="math display">\[e_{\bar{x}\pm \bar{y}}=e_{\bar{x}}\pm e_{\bar{y}}\\r_{\bar{x}\pm \bar{y}}=\frac{\bar{x}}{\bar{x}\pm \bar{y}}r_{\bar{x}}\pm\frac{\bar{y}}{\bar{x}\pm \bar{y}}r_{\bar{y}}\]</span> 可见 <span class="math inline">\(x\approx y\)</span> 时作减法会产生较大的相对误差，这被称为<strong>相减相消</strong>，应尽量避免</p></li><li><p><span class="math inline">\(f(x,y)=xy\)</span> <span class="math display">\[e_{\bar{x}\bar{y}}=\bar{y}e_{\bar{x}}+\bar{x}e_{\bar{y}}\\r_{\bar{x}\bar{y}}=r_{\bar{x}}+r_{\bar{y}}\]</span></p></li><li><p><span class="math inline">\(f(x,y)=x/y\)</span> <span class="math display">\[e_{\bar{x}/\bar{y}}=\frac{\bar{y}e_{\bar{x}}-\bar{x}e_{\bar{y}}}{\bar{y}^2}\\r_{\bar{x}/\bar{y}}=r_{\bar{x}}-r_{\bar{y}}\]</span> 可见 <span class="math inline">\(y\to0\)</span> 时会产生较大的绝对误差，应尽量避免</p></li></ol><h2 id="计算机浮点系统">计算机浮点系统</h2><p>称 <span class="math inline">\(F(p,t,L,U)\)</span> 为一个计算机浮点系统，其中：</p><ul><li><span class="math inline">\(p\)</span>：基数（进制）</li><li><span class="math inline">\(t\)</span>：精度（最大小数位数）</li><li><span class="math inline">\(L,U\)</span>：指数的取值范围 <span class="math inline">\([-L,U]\)</span>（整数）</li></ul><p>属于浮点系统 <span class="math inline">\(F\)</span> 的数 <span class="math inline">\(x\)</span> 具有如下形式： <span class="math display">\[x=\pm p^J\sum_{k=1}^td_kp^{-k}=\pm (0.d_1d_2...d_t)_p\times p^J\\J\in \mathbb{Z}\cap[-L,U],\:d_k\in\{0,1,2,...,p-1\}\]</span> 称 <span class="math inline">\((0.d_1d_2...d_t)_p\)</span> 为 <span class="math inline">\(x\)</span> 的尾数，<span class="math inline">\(J\)</span> 为 <span class="math inline">\(x\)</span> 的指数（阶）</p><p>称 <span class="math inline">\(x\)</span> 为<strong>规格化浮点数</strong>，若 <span class="math inline">\(d_1\neq0\)</span></p><h3 id="ufl-与-ofl">UFL 与 OFL</h3><ul><li>称 <span class="math inline">\(F\)</span> 中的最小正数为 <span class="math inline">\(UFL=p^{-t}\times p^{-L}=p^{-(L+t)}\)</span></li><li>称 <span class="math inline">\(F\)</span> 中的最大正数为 <span class="math inline">\(OFL=(1-p^{-t})\times p^U\)</span></li></ul><h3 id="机器精度">机器精度</h3><p><span class="math inline">\(F\)</span> 自然不能表示任意实数，称 <span class="math inline">\(F\)</span> 中用于表示一个在 <strong>UFL</strong> 以及 <strong>OFL</strong> 范围内的实数 <span class="math inline">\(x\)</span> 的最大的相对误差为机器精度 <span class="math inline">\(\varepsilon_{mach}\)</span></p><ul><li>若采取<strong>截断法</strong>：<span class="math inline">\(\varepsilon_{mach}=p^{1-t}\)</span></li><li>若采取<strong>最近舍入法</strong>（四舍六入五取双）：<span class="math inline">\(\varepsilon_{mach}=\frac12p^{1-t}\)</span></li></ul><p>一般地：<span class="math inline">\(0&lt;UFL&lt;\varepsilon_{mach}&lt;OFL\)</span></p><h3 id="机器算术运算">机器算术运算</h3><p>以 <span class="math inline">\(\oplus\:\ominus\:\otimes\)</span> 等符号代表机器算术运算符号， 可以假定机器运算的定义为： <span class="math display">\[x\odot y=fl(fl(x)\cdot fl(y))\]</span> 其中 <span class="math inline">\(\cdot\)</span> 泛指上述符号，<span class="math inline">\(fl(x)\)</span> 为 <span class="math inline">\(F\)</span> 中最接近 <span class="math inline">\(x\)</span> 的数，也就是 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(F\)</span> 中的表示</p><p>乘除运算是直接进行的，只需要分别处理底数部分和指数部分即可；</p><p>而对于加减运算，则需要<strong>对阶</strong>操作，即首先将阶数较小的数调整为与阶数较大的数同阶数（相应地，底数修改小数点位置），这个过程中若底数超出了精度 <span class="math inline">\(t\)</span>，则需要截断或最近舍入；完成加减运算之后，仍然需要作截断或最近舍入</p><p>特别地，对于减法，我们有<strong>精度丢失定理</strong>：设 <span class="math inline">\(x&gt;y\)</span> 均为正的规格化二进制浮点数，且 <span class="math inline">\(2^{-q}\leq1-\frac yx\leq2^{-p}\)</span> 则 <span class="math inline">\(x\ominus y\)</span> 丢失至多 <span class="math inline">\(q\)</span> 个，至少 <span class="math inline">\(p\)</span> 个有效二进制位</p><h2 id="数值稳定与病态问题">数值稳定与病态问题</h2><ul><li><p>称一个算法是<strong>数值稳定</strong>的，若在计算过程中，<strong>误差</strong>不会增长，否则称为<strong>数值不稳定</strong>的</p><p>例：在计算递推式时，式中出现了形如 <span class="math inline">\(x_{n+1}=ax_n,\:a&gt;1\)</span> 的情况，那么误差就会被 <span class="math inline">\(a\)</span> 不断放大，导致数值不稳定</p></li><li><p>称一个问题是<strong>病态</strong>的，若输入的<strong>微小变化</strong>能够导致输出的<strong>巨大误差</strong></p><p>例：求解线性方程组时系数矩阵接近奇异，如 <span class="math inline">\(Hilbert\)</span> 矩阵</p></li></ul><h1 id="插值法">插值法</h1><p>插值问题是指给定一组离散数据 <span class="math inline">\(\{x_k,y_k\},k=0,1,...,n\)</span>，我们试图寻求一函数形如： <span class="math display">\[\varphi(x)=a_0\varphi_0(x)+a_1\varphi_1(x)+...+a_n\varphi_n(x)\]</span> 使得 <span class="math inline">\(\varphi(x_k)=y_k,\forall k=0,1,...,n\)</span></p><h2 id="lagrange-插值"><span class="math inline">\(Lagrange\)</span> 插值</h2><p>记 <span class="math inline">\(l_i(x)=\prod_{j=0,j\neq i}^n\frac{x-x_j}{x_i-x_j}\)</span>，则 <span class="math inline">\(l_i(x_j)=\delta_{ij}\)</span>，称为 <span class="math inline">\(Lagrange\)</span> 基本多项式</p><p>则 <span class="math inline">\(Lagrange\)</span> 插值多项式为：<span class="math inline">\(L_n(x)=\sum_{i=0}^nf(x_i)l_i(x)\)</span>，容易证明这是存在唯一的</p><p>方便起见，若记 <span class="math inline">\(\omega_{n+1}(x)=\prod_{i=0}^n(x-x_i)\)</span>，那么 <span class="math inline">\(\omega_{n+1}&#39;(x_i)=\prod_{j=0,j\neq i}^n(x_i-x_j)\)</span></p><p>于是 <span class="math inline">\(l_i(x)=\frac{\omega_{n+1}(x)}{(x-x_i)\omega_{n+1}&#39;(x_i)}\)</span></p><h3 id="余项">余项</h3><p>设离散数据 <span class="math inline">\(\{x_k,y_k\},k=0,1,...,n\)</span> 是由函数 <span class="math inline">\(f\)</span> 给出，也就是 <span class="math inline">\(y_i=f(x_i)\)</span>，称： <span class="math display">\[r_n(x)=f(x)-L_n(x)\]</span> 为 <span class="math inline">\(Lagrange\)</span> 插值多项式的<strong>余项</strong></p><p>假设 <span class="math inline">\(f\)</span> 在包含 <span class="math inline">\(\{x_n\}\)</span> 的区间 <span class="math inline">\([a,b]\)</span> 上具有 <span class="math inline">\(n\)</span> 阶连续导数，且在 <span class="math inline">\((a,b)\)</span> 内存在 <span class="math inline">\(n+1\)</span> 阶有界导数， <br>那么 <span class="math inline">\(\forall x \in [a,b],\:\exists \xi\in(a,b)\)</span> 使得： <span class="math display">\[r_n(x)=\frac{f^{n+1}(\xi)}{(n+1)!}\omega_{n+1}(x)\]</span> 其证明需要简单了解，大致如下： <br>因为 <span class="math inline">\(x_0,x_1,...,x_n\)</span> 都是 <span class="math inline">\(r_n(x)\)</span> 的一重零点，故可以设 <span class="math inline">\(r_n(x)=\omega_{n+1}(x)K(x)\)</span>，为确定 <span class="math inline">\(K(x)\)</span>，引入辅助函数： <span class="math display">\[F(t)=f(t)-L_n(t)-K(x)\omega_{n+1}(t)\]</span> 则 <span class="math inline">\(t = x_0,x_1,...,x_n,x\)</span> 时均有 <span class="math inline">\(F(t)=0\)</span>，反复应用 <span class="math inline">\(Rolle\)</span> 定理就有 <span class="math inline">\(0=F^{(n+1)}(\xi)=f^{(n+1)}(\xi)-K(x)(n+1)!\)</span> <br>从而不难解出 <span class="math inline">\(K(x)\)</span> （这说明 <span class="math inline">\(\xi\)</span> 与 <span class="math inline">\(x_0,x_1,...,x_n,x\)</span> 有关）</p><p>通过考察余项，我们可以估计误差，特别地，对于线性插值，有： <span class="math display">\[|r_1(x)|\leq\frac{(b-a)^2}{8}|f&#39;&#39;(\xi)|\]</span> 对于二次插值，有： <span class="math display">\[|r_2(x)|\leq \frac{\sqrt3}{27}(b-a)^3|f&#39;&#39;&#39;(\xi)|\]</span></p><h3 id="runge-现象"><span class="math inline">\(Runge\)</span> 现象</h3><p>一般而言，<span class="math inline">\(n\)</span> 越大，<span class="math inline">\(L_n(x)\)</span> 在端点附近的抖动也越大，这被称为 <span class="math inline">\(Runge\)</span> 现象，因而高次插值法一般不能用于外插</p><h2 id="newton-插值"><span class="math inline">\(Newton\)</span> 插值</h2><h3 id="均差">均差</h3><p>称 <span class="math inline">\(f[x_i,x_j]=\frac{f(x_j)-f(x_i)}{x_j-x_i}\)</span> 为 <span class="math inline">\(f\)</span> 关于基点 <span class="math inline">\(x_i,x_j\)</span> 的一阶均差<br> 称 <span class="math inline">\(f[x_i,x_j,x_k]=\frac{f[x_j,x_k]-f[x_i,x_j]}{x_k-x_i}\)</span> 为 <span class="math inline">\(f\)</span> 关于基点 <span class="math inline">\(x_i,x_j,x_k\)</span> 的二阶均差<br> 一般地，<span class="math inline">\(f[x_0,x_1,...,x_n]=\frac{f[x_1,x_2,...,x_n]-f[x_0,x_1,...,x_{n-1}]}{x_n-x_0}\)</span> <br>方便起见，不妨规定 <span class="math inline">\(f[x_i]=f(x_i)\)</span></p><p>用归纳法可以证明： <span class="math display">\[f[x_0,x_1,...,x_n]=\sum_{i=0}^n\frac{f(x_i)}{\prod_{j=0,j\neq i}^n(x_i-x_j)}\]</span></p><h4 id="差商表">差商表</h4><p>常用差商表来计算各个均差：</p><p><span class="math display">\[\left[\begin{array}{}x_0 &amp; f(x_0)\\x_1 &amp; f(x_1)  &amp; f[x_0,x_1]\\x_2 &amp; f(x_2) &amp; f[x_1,x_2] &amp; f[x_0,x_1,x_2]\\... &amp; ... &amp; ... &amp; ...  &amp; ...\\x_n &amp; f(x_n) &amp; f[x_{n-1},x_n] &amp; f[x_{n-2},x_{n-1},x_n] &amp;  ... &amp; f[x_0,...,x_n]\\\end{array}\right]\]</span></p><h3 id="newton-插值多项式"><span class="math inline">\(Newton\)</span> 插值多项式</h3><p><span class="math inline">\(Lagrange\)</span> 插值的缺陷是每新增一个样本点都要全部重新算一遍，<span class="math inline">\(Newton\)</span> 插值优化了这一点，其关键是将多项式考虑为如下形式： <span class="math display">\[N_n(x)=a_0+a_1(x-x_0)+a_2(x-x_0)(x-x_1)+...+a_n(x-x_0)(x-x_1)...(x-x_{n-1})\]</span> 从而不难看出 <span class="math inline">\(a_k=f[x_0,x_1,...,x_k]\)</span></p><p>若新增一插值基点 <span class="math inline">\(\bar{x}\)</span>，那么 <span class="math inline">\(f(\bar{x})-N_n(\bar{x})=N_{n+1}(\bar{x})-N_n(\bar{x})=f[x_0,x_1,...,x_n,\bar{x}]\omega_{n+1}(\bar{x})\)</span> <br>据插值多项式的唯一性，比较上一节中的余项就有： <span class="math display">\[f[x_0,x_1,...,x_n,x]=\frac{f^{(n+1)}(\xi)}{(n+1)!}\]</span></p><h3 id="有限差">有限差</h3><p>下面我们考虑样本点满足 <span class="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span> 的简单情形，方便起见，引入有限差的概念，分别称： <span class="math display">\[\Delta f(x)=f(x+h)-f(x)\\\nabla f(x)=f(x)-f(x-h)\\\delta f(x)=f(x+\frac h2)-f(x-\frac h2)\]</span> 为函数 <span class="math inline">\(f(x)\)</span> 在点 <span class="math inline">\(x\)</span> 的一阶向前差分，一阶向后差分以及一阶中心差分，易见它们都是线性算子 <br>下面以向前差分为例定义高阶情形： <span class="math display">\[\Delta^2f(x)=\Delta(\Delta f(x))=\Delta f(x+h)-\Delta f(x)\\\Delta^nf(x)=\Delta(\Delta^{n-1} f(x))=\Delta^{n-1} f(x+h)-\Delta^{n-1} f(x)\\\]</span> 类似地，方便起见我们规定 <span class="math inline">\(\Delta^0f(x)=f(x)\)</span>，用归纳法可以证明： <span class="math display">\[\Delta^n f(x)=\sum_{i=0}^n(-1)^iC_n^if(x+(n-i)h)\\\nabla^n f(x)=\sum_{i=0}^n(-1)^iC_n^if(x-ih)\\\delta^n f(x)=\sum_{i=0}^n(-1)^iC_n^if(x+(\frac n2-i)h)\]</span> 反过来，我们也有： <span class="math display">\[f(x+nh)=\sum_{i=0}C_n^i\Delta^if(x)\\f(x-nh)=\sum_{i=0}^n(-1)^iC_n^i\nabla^if(x)\\f(x+nh)=\sum_{i=0}^nC_n^i\delta^if(x+\frac i2h)\]</span> 最后，对于满足 <span class="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span> 的样本点，我们有： <span class="math display">\[f[x_0,x_1,...,x_n]=\frac{\Delta^nf(x_0)}{n!h^n}=\frac{\nabla^nf(x_n)}{n!h^n}\]</span> 对于中心差分则需要分样本点的奇偶个数作讨论，原理类似</p><h4 id="差分表">差分表</h4><p>可以用差商表类似的方法构造差分表以计算差分，以向前差分为例：</p><p><span class="math display">\[\left[\begin{array}{}x_i=x_0+ih &amp; \Delta &amp; \Delta^2 &amp; \Delta^3 &amp; ...  &amp; \Delta^{n-1} &amp; \Delta^n\\x_0 &amp; \Delta f(x_0) &amp; \Delta^2 f(x_0) &amp; \Delta^3 f(x_0) &amp;  ... &amp;\Delta^{n-1} f(x_0)&amp; \Delta^n f(x_0)\\x_1 &amp; \Delta f(x_1) &amp; \Delta^2 f(x_1) &amp; \Delta^3 f(x_1) &amp;  ... &amp;\Delta^{n-1} f(x_1)&amp;\\x_2 &amp; \Delta f(x_2) &amp; \Delta^2 f(x_2) &amp; \Delta^3 f(x_2) &amp;  ...\\... &amp; ... &amp; ... &amp; ... &amp; ... \\x_{n-1} &amp; \Delta f(x_{n-1}) &amp; \Delta^2 f(x_{n-1}) \\x_n &amp; \Delta f(x_n)\end{array}\right]\]</span></p><h3 id="newton-前插和后插公式"><span class="math inline">\(Newton\)</span> 前插和后插公式</h3><p>考虑样本点满足 <span class="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span> 的情形，利用均差和向前差分的关系，作变换：<span class="math inline">\(x=x_0+sh\)</span> <br>从而 <span class="math inline">\(Newton\)</span> 插值公式可以整理为： <span class="math display">\[N_n(x)=N_n(x_0+sh)=\sum_{k=0}^n\left(\begin{array}{}s\\k\end{array}\right)\Delta^kf(x_0)\\\left(\begin{array}{}s\\k\end{array}\right)=\frac{s(s-1)...(s-k+1)}{k!}\]</span> 即 <span class="math inline">\(Newton\)</span> 前插公式；利用向后差分，作变换：<span class="math inline">\(x=x_n+th\)</span>，同理有： <span class="math display">\[N_n(x)=N_n(x_n+th)=\sum_{k=0}^n\left(\begin{array}{}-t\\k\end{array}\right)(-1)^k\nabla^kf(x_n)\\\left(\begin{array}{}-t\\k\end{array}\right)(-1)^k=\frac{t(t+1)...(t+k-1)))}{k!}\]</span> 即 <span class="math inline">\(Newton\)</span> 后插公式</p><h2 id="hermite-插值">Hermite 插值</h2><p>在 <span class="math inline">\(Hermite\)</span> 插值中我们不仅已知样本点的值，还知道样本点的前 <span class="math inline">\(n\)</span> 阶导数值，因而我们希望寻求一插值多项式使得其导数值也与我们的已知数据符合，下面讨论 <span class="math inline">\(n=1\)</span> 的简单情形：</p><p>设已知 <span class="math inline">\(f(x)\)</span> 在插值基点 <span class="math inline">\(x_0,x_1,...,x_n\)</span> 处的函数值分别为 <span class="math inline">\(y_0,y_1,...,y_n\)</span> 以及一阶导数值分别为 <span class="math inline">\(y&#39;_0,y&#39;_1,...,y&#39;_n\)</span> <br>我们试求一多项式 <span class="math inline">\(H_{2n+1}\in R[x]_{2n+2}\)</span> 使得： <span class="math display">\[\left\{ \begin{aligned}H_{2n+1}(x_i)=y_i\\H&#39;_{2n+1}(x_i)=y&#39;_i\end{aligned}\right.\]</span> 不妨设： <span class="math display">\[H_{2n+1}=\sum_{i=0}^ny_iA_i(x)+\sum_{i=0}^ny&#39;_iB_i(x)\\A_i(x_j)=\delta_{ij},\:A&#39;_i(x_j)=0\\B_i(x_j)=0,\:B&#39;_i(x_j)=\delta_{ij}\]</span> 可以通过分析 <span class="math inline">\(A_i,\:B_i\)</span> 各自零点的重数设出其形式进而求解，最后可以得到： <span class="math display">\[B_i(x)=(x-x_i)l_i^2(x)\\A_i(x)=\left(1-2(x-x_i)\sum_{j=0,j\neq i}^n\frac1{x_i-x_j}\right)l_i^2(x)\]</span> 与 <span class="math inline">\(Lagrange\)</span> 插值类似，可以证明 <span class="math inline">\(Hermite\)</span> 插值的唯一性，以及其余项可表示为： <span class="math display">\[r(x)=\frac{f^{(2n+2)}(\xi)}{(2n+2)!}\omega_{n+1}^2(x)\]</span></p><h2 id="分段插值">分段插值</h2><p>为了解决高次多项式插值带来的 <span class="math inline">\(Runge\)</span> 现象，可以使用分段插值，也就是将插值区间细分为若干子区间，并在这些子区间内使用较低次数的多项式进行插值的办法，其中最简单的分段插值就是<strong>分段线性插值</strong></p><h3 id="分段插值误差界">分段插值误差界</h3><p>直观上，采用分段插值时，子区间分的越细，那么分段插值的误差界应该越小 <br>下面我们考虑将插值区间分为等距基点 <span class="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span> 的情形，由之前对余项的讨论，有：</p><ul><li><p>分段线性插值： <span class="math display">\[|e_{f_1(x)}|\leq\frac{1}8Mh^2\\M=\mathop{max}\limits_{x\in[a,b]}|f&#39;&#39;(x)|\]</span></p></li><li><p>分段抛物线插值（即每一个区间含三个基点采用二次多项式插值）： <span class="math display">\[|e_{f_2(x)}|\leq\frac{\sqrt{3}}{27} M h^3\\M=\mathop{max}\limits_{x\in[a,b]}|f&#39;&#39;&#39;(x)|\]</span></p></li></ul><h3 id="三次样条插值">三次样条插值</h3><p>直接作分段插值的一个严重的问题是得到的结果往往不光滑，因而我们可以考虑在每一区间 <span class="math inline">\([x_i,x_{i+1}]\)</span> 上采用三次多项式插值，并要求每一段的拼接点的导数以及二阶导数相等，这种插值办法被称为三次样条插值</p><p>直观上，我们需要求解 <span class="math inline">\(4n\)</span> 个待定系数，然而假设的条件只能给出 <span class="math inline">\(4n-2\)</span> 个方程，因而我们需要附加两个条件，常采用边界条件：</p><ul><li>自然边界条件：取插值函数在 <span class="math inline">\(x_0, x_n\)</span> 处的二阶导数为 <span class="math inline">\(0\)</span>，这样得到的插值称为<strong>自然三次样条插值</strong></li><li>完备边界条件：假设我们已知待插值函数 <span class="math inline">\(f\)</span> 在端点处的导数值，取插值函数在 <span class="math inline">\(x_0, x_n\)</span> 处的导数与之相等即可，这样得到的插值称为<strong>完备三次样条插值</strong></li></ul><p>下面简要讨论具体的计算，给定 <span class="math inline">\([a,b]\)</span> 的一组基点： <span class="math display">\[a=x_1&lt;x_2&lt;...&lt;x_{n+1}=b\]</span> 记 <span class="math inline">\([x_i,x_i+1]\)</span> 上的三次插值多项式为 <span class="math inline">\(S_i(x),\:i=1,2,...,n\)</span>，已知条件为： <span class="math display">\[S_{i-1}(x_i)=S_i(x_i)=f(x_i),\:i=2,...,n\\S&#39;_{i-1}(x_i)=S&#39;_i(x_i),\:i=2,...,n\\S&#39;&#39;_{i-1}(x_i)=S&#39;&#39;_i(x_i),\:i=2,...,n\\S_1(x_1)=f(x_1),\:S_n(x_{n+1})=f(x_{n+1})\]</span> 记 <span class="math inline">\(S&#39;&#39;_i(x_i)=m_i,\:h_i=x_{i+1}-x_i\)</span>，因为 <span class="math inline">\(deg\:S&#39;&#39;_i=1\)</span>，结合 <span class="math inline">\(S&#39;&#39;_{i-1}(x_i)=S&#39;&#39;_i(x_i)\)</span> 就知道其必形如： <span class="math display">\[S&#39;&#39;_i(x)=m_i\frac{x_{i+1}-x}{h_i}+m_{i+1}\frac{x-x_i}{h_i}\]</span> 对其积分得： <span class="math display">\[S&#39;_i(x)=-m_i\frac{(x_{i+1}-x)^2}{2h_i}+m_{i+1}\frac{(x-x_i)^2}{2h_i}+A_i\\S_i(x)=m_i\frac{(x_{i+1}-x)^3}{6h_i}+m_{i+1}\frac{(x-x_i)^3}{6h_i}+A_i(x-x_i)+B_i\]</span> 结合 <span class="math inline">\(S_i(x_i)=f(x_i),\:S_i(x_{i+1})=f(x_{i+1})\)</span> 可以解得： <span class="math display">\[B_i=f(x_i)-m_i\frac{h_i^2}6\\A_i=f[x_i,x_{i+1}]-\frac{h_i}6(m_{i+1}-m_i)\]</span> 再由 <span class="math inline">\(S&#39;_{i-1}(x_i)=S&#39;_i(x_i)\)</span> 就得到： <span class="math display">\[h_{i-1}m_{i-1}+2(h_{i-1}+h_i)m_i+h_im_{i+1}=6(f[x_i,x_{i+1}]-f[x_{i-1},x_i])\]</span> 也就是： <span class="math display">\[\left(\begin{array}{}h_1 &amp;2(h_1+h_2) &amp; h_2 &amp; 0 &amp; ... &amp; 0 \\0 &amp; h_2 &amp;2(h_2+h_3) &amp; h_3 &amp; ... &amp; 0 \\... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... \\0 &amp; ... &amp; h_{n-2} &amp;2(h_{n-2}+h_{n-1}) &amp; h_{n-1} &amp; 0\\0 &amp; 0 &amp; ... &amp; h_{n-1} &amp;2(h_{n-1}+h_{n}) &amp; h_{n} \end{array}\right)\left(\begin{array}{}m_1\\m_2\\...\\m_n\\m_{n+1}\end{array}\right)=6\left(\begin{array}{}d_2\\d_3\\...\\d_{n-1}\\d_n\end{array}\right)\\\\d_i=f[x_i,x_{i+1}]-f[x_{i-1},x_i]\]</span> 前已述该方程没有唯一解，需要补上一定的边界条件，即：</p><ul><li><p>自然边界条件：<span class="math inline">\(m_1=m_{n+1}=0\)</span></p></li><li><p>完备边界条件：<span class="math inline">\(S&#39;_1(a)=f&#39;(a),\:S&#39;_n(b)=f&#39;(b)\)</span>，进而： <span class="math display">\[2h_1m_1+h_1m_2=6(f[x_1,x_2]-f&#39;(a))\\h_nm_n+2h_nm_{n+1}=6(f&#39;(b)-f[x_n,x_{n+1}])\]</span></p></li></ul><p>补上这些边界条件即有唯一解</p><h3 id="基样条插值">基样条插值</h3><p>注意到 <span class="math inline">\(Lagrange\)</span> 插值多项式总可以写成 <span class="math inline">\(Lagrange\)</span> 基本多项式 <span class="math inline">\(l_i(x)\)</span> 的线性组合，亦可寻找一<strong>基三次样条系</strong>来表示三次样条插值函数</p><p>常见的办法是构造一在区间 <span class="math inline">\([-2,2]\)</span> 上的分段三次多项式 <span class="math inline">\(\varphi(x)\)</span>，使得其在 <span class="math inline">\(x=-1,0,1\)</span> 上面的取值以及导数值，二阶导数值较好，以及在 <span class="math inline">\(x=-2,2\)</span> 上的函数值，导数值，二阶导数值均为 <span class="math inline">\(0\)</span>，从而可以通过将其根据实际的基点位置作平移和伸缩变换得到一系列基函数</p><h1 id="函数逼近">函数逼近</h1><h2 id="正交函数系">正交函数系</h2><p>称 <span class="math inline">\(W(x)\)</span> 为 <span class="math inline">\([a,b]\)</span> 上的权函数，若满足：</p><ul><li>在 <span class="math inline">\((a,b)\)</span> 中，<span class="math inline">\(W(x)\geq 0\)</span>，且只有有限个零点</li><li><span class="math inline">\(\int_a^bx^iW(x)dx,i=1,2,...\)</span> 存在且有限</li></ul><p>则对于非负连续函数 <span class="math inline">\(f\)</span>，若 <span class="math inline">\(\int_a^bf(x)W(x)dx=0\)</span>，则在 <span class="math inline">\([a,b]\)</span> 上有 <span class="math inline">\(f(x)\equiv 0\)</span></p><p>给定 <span class="math inline">\(f,g\in C[a,b]\)</span>，称 <span class="math inline">\((f,g)=\int_a^bW(x)f(x)g(x)dx\)</span> 为函数 <span class="math inline">\(f,g\)</span> 在 <span class="math inline">\([a,b]\)</span> 上关于权 <span class="math inline">\(W(x)\)</span> 的内积 <br>（满足内积的各种性质，亦可以由此定义范数）</p><p>我们常用下面三类范数： <span class="math display">\[\Vert f\Vert_\infty=\mathop{max}_\limits{x\in[a,b]}|f(x)W(x)|\\\Vert f\Vert_1=\int_a^b|f(x)W(x)|dx\\\Vert f\Vert_2=\sqrt{(f,f)}\]</span></p><p>称函数系 <span class="math inline">\(\{f_n(x)\}\)</span> 为 <span class="math inline">\([a,b]\)</span> 上关于权函数 <span class="math inline">\(W(x)\)</span> 的正交函数系，若 <span class="math inline">\((f_i,f_j)=A_i\delta_{ij}\)</span></p><h3 id="线性无关">线性无关</h3><p>可以与线性代数理论类似考虑一族函数的线性无关性，称函数系 <span class="math inline">\(\{f_n(x)\}\)</span> 在 <span class="math inline">\([a,b]\)</span> 上线性无关，若： <span class="math display">\[\sum_{i=0}^na_if_i=0 \Rightarrow a_i=0,\forall i=0,1,...,n\]</span> 可以证明这等价于： <span class="math display">\[\left|\begin{array}{}(f_0,f_0) &amp; (f_0,f_1) &amp;... &amp;(f_0,f_n)\\(f_1,f_0) &amp; (f_1,f_1) &amp;... &amp;(f_1,f_n)\\... &amp; ... &amp; ... &amp; ... \\(f_n,f_0) &amp; (f_n,f_1) &amp;... &amp;(f_n,f_n)\end{array}\right|\neq0\]</span> 该行列式被称为 <span class="math inline">\(Gram\)</span> 行列式</p><p>可以用 <span class="math inline">\(Schmidt\)</span> 正交化将一族线性无关函数化为正交函数系，即： <span class="math display">\[\varphi_0=f_0\\\varphi_n=f_n-\sum_{i=0}^{n-1}\frac{(f_n,f_i)}{(f_i,f_i)}f_i\]</span></p><h2 id="直交多项式">直交多项式</h2><p>取线性无关的多项式序列 <span class="math inline">\(\{1,x,...,x^n\}\)</span>，称由此通过 <span class="math inline">\(Schmidt\)</span> 正交化得到的正交函数系为直交多项式 <span class="math inline">\(\{p_n(x)\}\)</span> <br>可以证明有递推关系： <span class="math display">\[\begin{aligned}&amp;p_{k+1}(x)=(x-\alpha_k)p_k(x)-\beta_kp_{k-1}(x)\\&amp;p_0=1,\:p_{-1}=0\\&amp;其中:\\&amp;\alpha_k=\frac{(xp_k(x),p_k(x))}{(p_k(x),p_k(x))}\\&amp;\beta_k=\left\{\begin{align}&amp;\frac{(p_k(x),p_k(x))}{(p_{k-1}(x),p_{k-1}(x))},k\geq1\\&amp;0,k=0\end{align}\right.\\\end{aligned}\]</span></p><h3 id="chebyshev-多项式"><span class="math inline">\(Chebyshev\)</span> 多项式</h3><p>取权函数 <span class="math inline">\(W(x)=\frac1{\sqrt{1-x^2}}\)</span>，区间 <span class="math inline">\([a,b]=[-1,1]\)</span>，由此得到 <span class="math inline">\(Chebyshev\)</span> 多项式，可表示为： <span class="math display">\[T_n(x)=cos(n\:arccos\:x)\]</span> 显然，取 <span class="math inline">\(x=cos\theta\)</span>，据三角公式就有： <span class="math display">\[T_{n\pm1}(x)=cos(n\pm1)\theta=cos(n\theta)cos\theta\mp sin(n\theta)sin\theta\]</span> 两式相加就能得到递推关系： <span class="math display">\[T_{n+1}(x)+T_{n-1}(x)=2xT_n(x)\]</span> 利用 <span class="math inline">\(Euler\)</span> 公式，有：<span class="math inline">\(cos\:n\theta=\frac{e^{in\theta}+e^{-in\theta}}2\)</span>，由此亦可直接证明： <span class="math display">\[T_n(x)=\frac12\left((x+\sqrt{x^2-1})^n+(x-\sqrt{x^2-1})^n\right)\]</span> #### 近似最佳一致逼近</p><p>固定 <span class="math inline">\(z&gt;1\)</span>，记 <span class="math inline">\(\theta_n \subseteq R[x]_{n+1}\)</span> 为满足条件 <span class="math inline">\(\forall p_n \in \theta_n\)</span> ，都有 <span class="math inline">\(p_n(z)=1\)</span> 的集合，那么： <span class="math display">\[\left\Vert\frac{T_n(x)}{T_n(z)}\right\Vert_\infty=\mathop{inf}_\limits{p_n\in \theta_n}\Vert p_n \Vert_\infty\]</span> 类似地，记 <span class="math inline">\(\bar{T}_n(x)\)</span> 为 <span class="math inline">\(T_n(x)\)</span> 的首一化多项式，也就是：<span class="math inline">\(\bar{T}_n(x)=\frac1{2^{n-1}}T_n(x)\)</span>，那么任给 <span class="math inline">\(n\)</span> 次首一多项式 <span class="math inline">\(p_n(x)\)</span>，都有： <span class="math display">\[\Vert p_n\Vert_\infty\geq\Vert\bar{T}_n\Vert_\infty=\frac1{2^{n-1}}\:\:\:\:(W(x)=1)\]</span> 当且仅当 <span class="math inline">\(p_n=\bar{T}_n\)</span> 时取等，这说明要想使得对定义在 <span class="math inline">\([-1,1]\)</span> 上的函数 <span class="math inline">\(f\)</span> 作 <span class="math inline">\(n\)</span> 次多项式插值得到的余项较小，可以将插值基点选取为 <span class="math inline">\(T_{n+1}(x)\)</span> 的零点，即： <span class="math display">\[x_i=cos\frac{(2i+1)\pi}{2(n+1)},i=0,1,...,n\]</span> 对于一般的定义在 <span class="math inline">\([a,b]\)</span> 上的函数 <span class="math inline">\(f\)</span>，作平移和伸缩变换再类似处理即可，也就是： <span class="math display">\[[a,b]\to[-1,1]:x\to\frac2{b-a}(x-\frac{b-a}2)\\\frac2{b-a}(x_i-\frac{b-a}2)=cos\frac{(2i+1)\pi}{2(n+1)},i=0,1,...,n\]</span></p><p>由此可以得到一个近似的最佳一致逼近多项式，关于最佳一致逼近的具体讨论在后续部分</p><h4 id="第二类-chebyshev-多项式">第二类 <span class="math inline">\(Chebyshev\)</span> 多项式</h4><p>与第一类的唯一差别是权函数取为 <span class="math inline">\(W(x)=\sqrt{1-x^2}\)</span>，将其记为 <span class="math inline">\(\{U_n(x)\}\)</span>，可以表示为： <span class="math display">\[U_n(x)=\frac{sin\left((n+1)arccos\:x\right)}{\sqrt{1-x^2}}\]</span> 其与第一类有关系式： <span class="math display">\[T_{n+1}&#39;(x)=(n+1)U_n(x)\]</span></p><h3 id="legendre-多项式"><span class="math inline">\(Legendre\)</span> 多项式</h3><p>取最简单的权函数 <span class="math inline">\(W(x)=1\)</span>，区间 <span class="math inline">\([a,b]=[-1,1]\)</span>，得 <span class="math inline">\(Legendre\)</span> 多项式，可以表示为： <span class="math display">\[p_n(x)=\frac1{2^nn!}\frac{d^n}{dx^n}(x^2-1)^n\]</span> 其用处在这门课主要体现在<strong>高斯型求积公式</strong>中，此处暂且不谈</p><h2 id="最佳一致逼近">最佳一致逼近</h2><p>取 <span class="math inline">\(W(x)=1\)</span>，设 <span class="math inline">\(f\in C[a,b]\)</span>，若有一列函数 <span class="math inline">\(\{f_n\}\)</span> 使得： <span class="math display">\[\lim_{n\to\infty}\Vert f-f_n\Vert_\infty=0\]</span> 称 <span class="math inline">\(\{f_n\}\)</span> 为 <span class="math inline">\(f\)</span> 的一致逼近函数，不难看出也就是在 <span class="math inline">\([a,b]\)</span> 上一致收敛于 <span class="math inline">\(f\)</span></p><p>我们在数学分析的课程上已经知道 <span class="math inline">\(Weierstrass\)</span> 给出的关于多项式一致逼近的相关结果，即 <span class="math inline">\(\forall \varepsilon&gt;0,\exists p_n(x)\)</span> 使得： <span class="math display">\[\Vert f-p_n\Vert_\infty&lt;\varepsilon\]</span> 然而我们知道多项式拟合的次数太高并不好，下面我们固定 <span class="math inline">\(n\)</span>，考虑在次数不超过 <span class="math inline">\(n\)</span> 的多项式集合 <span class="math inline">\(H_n\)</span> 中寻求 <span class="math inline">\(p_n\)</span> 使得： <span class="math display">\[\Vert f-p_n\Vert_\infty=\mathop{inf}_\limits{q_n\in H_n}\Vert f-q_n\Vert_\infty\]</span> 这就是<strong>最佳一致逼近多项式</strong>问题，关于这个问题，<span class="math inline">\(Chebyshev\)</span> 给出了以下结果：</p><ol type="1"><li><p>设 <span class="math inline">\(a\leq x_1&lt;x_2&lt;...&lt;x_n\leq b\)</span>，称 <span class="math inline">\(\{x_1,x_2,...,x_n\}\)</span> 为 <span class="math inline">\(f\)</span> 在 <span class="math inline">\([a,b]\)</span> 上的交错点组，若满足： <span class="math display">\[|f(x_i)|=\mathop{max}_\limits{x\in[a,b]}|f(x)|,\forall i=1,2,...,n\\f(x_i)=-f(x_{i+1}),\forall i=1,2,...,n-1\]</span></p></li><li><p>（<span class="math inline">\(Chebyshev\)</span> 定理）设 <span class="math inline">\(p\in H_n\)</span>，则 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(f\)</span> 的最佳一致逼近多项式当且仅当 <span class="math inline">\(f(x)-p(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上存在 <span class="math inline">\(n+2\)</span> 个点组成的交错点组</p></li><li><p>上述 <span class="math inline">\(p(x)\)</span> 在 <span class="math inline">\(H_n\)</span> 中是唯一的</p></li><li><p>若 <span class="math inline">\(f^{(n+1)}(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 中不变号，则 <span class="math inline">\(a,b\)</span> 属于交错点组</p></li></ol><h2 id="最佳平方逼近">最佳平方逼近</h2><p>与最佳一致逼近类似，只是考虑的范数由 <span class="math inline">\(\infty\)</span> 范数改为了 <span class="math inline">\(2\)</span> 范数，我们考察一般情形：</p><p>设 <span class="math inline">\(f\in C[a,b],\:\{\varphi_n\}\)</span> 为 <span class="math inline">\([a,b]\)</span> 上的线性无关函数族，我们希望寻求 <span class="math inline">\(a_0,a_1,...,a_n\)</span> 使得： <span class="math display">\[\Vert f-\sum_{k=0}^na_k\varphi_k\Vert_2\]</span> 达到极小；考察其平方不影响结果，从而可以使用多元函数求极值的办法给出结论： <span class="math display">\[F(a_0,a_1,...,a_n)=\int_a^b\left(f(x)-\sum_{k=0}^na_k\varphi_k(x)\right)^2W(x)dx\\\frac{\partial F}{\partial a_j}=2\int_a^b\left(f(x)-\sum_{k=0}^na_k\varphi_k(x)\right)(-\varphi_j(x))W(x)dx=0\]</span> 也就是： <span class="math display">\[\left(\begin{array}{}(\varphi_0,\varphi_0) &amp; (\varphi_0,\varphi_1) &amp;... &amp;(\varphi_0,\varphi_n)\\(\varphi_1,\varphi_0) &amp; (\varphi_1,\varphi_1) &amp;... &amp;(\varphi_1,\varphi_n)\\... &amp; ... &amp; ... &amp; ... \\(\varphi_n,\varphi_0) &amp; (\varphi_n,\varphi_1) &amp;... &amp;(\varphi_n,\varphi_n)\end{array}\right)\left(\begin{array}{}a_0\\a_1\\...\\a_n\end{array}\right)=\left(\begin{array}{}(f,\varphi_0)\\(f,\varphi_1)\\...\\(f,\varphi_n)\end{array}\right)\]</span> 这被称为<strong>法方程</strong>，据 <span class="math inline">\(\{\varphi_n\}\)</span> 线性无关知其系数矩阵行列式不为 <span class="math inline">\(0\)</span>，从而存在唯一解</p><p>特别地，若 <span class="math inline">\(\{\varphi_n\}\)</span> 为正交函数系，则系数矩阵为对角矩阵，进而直接有： <span class="math display">\[a_k=\frac{(f,\varphi_k)}{(\varphi_k,\varphi_k)}\]</span> 进一步，如果让 <span class="math inline">\(n\to\infty\)</span>，这就给出了 <span class="math inline">\(f\)</span> 的广义 <span class="math inline">\(Fourier\)</span> 级数</p><p>若正交函数系取为 <span class="math inline">\(Chebyshev\)</span> 多项式 <span class="math inline">\(\{T_n(x)\}\)</span>，由此就得到 <span class="math inline">\(f\)</span> 在 <span class="math inline">\([-1,1]\)</span> 上的 <span class="math inline">\(Chebyshev\)</span> 级数： <span class="math display">\[f(x)=\frac12a_0+\sum_{n=1}^\infty a_nT_n(x)\\a_k=\frac{(T_k,f)}{(T_k,T_k)}=\frac2\pi\int_{-1}^1T_k(x)f(x)\frac{dx}{\sqrt{1-x^2}}\]</span></p><h3 id="离散情形">离散情形</h3><p>与连续情形类似，若已知 <span class="math inline">\(f\)</span> 在给定点集 <span class="math inline">\(\{x_1,x_2,...,x_m\}\)</span> 上的值，记： <span class="math display">\[r_i=\sum_{j=0}^na_j\varphi_j(x_i)-f(x_i)\]</span> 为<strong>残量</strong>，亦可寻求 <span class="math inline">\(a_0,a_1,...,a_n\)</span> 使得： <span class="math display">\[\sum_{i=0}^mr_i^2\]</span> 达到极小，这样的问题被称为<strong>离散的最佳平方逼近问题</strong>，也就是<strong>线性最小二乘拟合问题</strong>，在后续部分讨论</p><p>在等距点集情形，我们有著名的 <strong>DFT</strong> 以及 <strong>FFT</strong>，此前已作过其浅析，详见：<a href="https://dasasdhba.github.io/study-FFT/" class="uri">https://dasasdhba.github.io/study-FFT/</a></p><h1 id="数据拟合">数据拟合</h1><p>数据拟合问题是指寻求一函数 <span class="math inline">\(f(x)\)</span> 来拟合一组离散数据 <span class="math inline">\(\{(x_i,y_i)\}_{i=1}^m\)</span>，与插值法不同，我们采用<strong>均方误差</strong>（mean-square error MSE）来衡量拟合的好坏，也就是考虑： <span class="math display">\[\mathcal{L}(f)=\frac1m\sum_{i=1}^m(f(x_i)-y_i)^2\]</span> 一般地，给定函数族 <span class="math inline">\(\mathcal{F}\)</span>，我们试图求解 <span class="math inline">\(f\in\mathcal{F}\)</span> 使得： <span class="math display">\[\mathcal{L}(f)=\mathop{inf}_\limits{g\in\mathcal{F}}\mathcal{L}(g)\]</span></p><h2 id="线性拟合">线性拟合</h2><p>下面介绍线性拟合的<strong>最小二乘法</strong>，这与最佳平方逼近是类似的</p><p>设 <span class="math inline">\(f\in C[a,b],\:\{\varphi_n\}\)</span> 为 <span class="math inline">\([a,b]\)</span> 上的线性无关函数族，我们希望寻求 <span class="math inline">\(a_0,a_1,...,a_n\)</span> 使得： <span class="math display">\[\varphi(x)=\sum_{j=0}^na_j\varphi_j\\\mathcal{L}(\varphi)=\frac1m\sum_{i=1}^m(\varphi(x_i)-y_i)^2\]</span> 达到极小；类似地，可以使用多元微积分求极值的理论： <span class="math display">\[F(a_0,...,a_n)=\sum_{i=1}^m(\sum_{j=0}^na_j\varphi_j(x_i)-y_i)^2\\\frac{\partial F}{\partial a_k}=2\sum_{i=1}^m\varphi_k(x_i)(\sum_{j=0}^na_j\varphi_j(x_i)-y_i)=0\]</span> 记 <span class="math inline">\(Y=(y_1,...,y_m)^T,\:\Phi_i=(\varphi_i(x_1),...,\varphi_i(x_m))^T\)</span>，取 <span class="math inline">\(\mathbb{R}^m\)</span> 这个 <span class="math inline">\(Euclid\)</span> 空间的通常内积 <span class="math inline">\((X,Y)=X^TY\)</span>，则上述方程可以改写为： <span class="math display">\[\left(\begin{array}{}(\Phi_0,\Phi_0) &amp; (\Phi_0,\Phi_1) &amp;... &amp;(\Phi_0,\Phi_n)\\(\Phi_1,\Phi_0) &amp; (\Phi_1,\Phi_1) &amp;... &amp;(\Phi_1,\Phi_n)\\... &amp; ... &amp; ... &amp; ... \\(\Phi_n,\Phi_0) &amp; (\Phi_n,\Phi_1) &amp;... &amp;(\Phi_n,\Phi_n)\end{array}\right)\left(\begin{array}{}a_0\\a_1\\...\\a_n\end{array}\right)=\left(\begin{array}{}(Y,\Phi_0)\\(Y,\Phi_1)\\...\\(Y,\Phi_n)\end{array}\right)\]</span> 由此即可解出 <span class="math inline">\(a_0,...,a_n\)</span>；特别地，若取 <span class="math inline">\(n=1, \varphi_0(x)=1,\varphi_1(x)=x\)</span>，得到： <span class="math display">\[\begin{aligned}&amp;\left\{\begin{align}&amp;a_1=\frac{(\Phi_1,Y)-m\bar{x}\bar{y}}{(\Phi_1,\Phi_1)-m\bar{x}\bar{y}}=\frac{\sum_{i=1}^m(x_i-\bar{x})(y_i-\bar{y})}{\sum_{i=1}^m(x_i-\bar{x})^2}\\&amp;a_0=\bar{y}-a_1\bar{x}\\\end{align}\right.\\&amp;其中:\\&amp;\bar{x}=\sum_{i=1}^mx_i,\:\bar{y}=\sum_{i=1}^my_i\end{aligned}\]</span> 即中学阶段已经介绍过的最小二乘法求解回归直线方程</p><h3 id="过拟合现象">过拟合现象</h3><p>若取 <span class="math inline">\(\{\varphi_n\}=\{x^n\}\)</span>，直观上 <span class="math inline">\(n\)</span> 越大误差越小，然而与 <span class="math inline">\(Runge\)</span> 现象类似，过高的拟合次数会产生<strong>过拟合现象</strong></p><h2 id="非线性拟合">非线性拟合</h2><p>非线性拟合是考虑用不能被一族函数的线性组合所表出的函数作拟合，如： <span class="math display">\[f(x)=\frac a{1+be^{cx}}\]</span> 我们的目标是寻求待定系数 <span class="math inline">\(a,b,c\)</span> 使得 <span class="math inline">\(\mathcal{L}(f)\)</span> 达到极小</p><h3 id="线性化求近似解">线性化求近似解</h3><p>若有一向量值函数 <span class="math inline">\(F:\mathbb{R}^2 \to \mathbb{R}^2\)</span> 使得 <span class="math inline">\(\{F(x_i,y_i)\}_{i=1}^m\)</span> 可以用一族函数的线性组合来拟合，则可以使用线性拟合的办法求近似解 <br>（化曲为直）</p><p>举例，若离散数据符合非线性函数： <span class="math display">\[y=\frac1{1+ae^{bx}}\]</span> 这可以改写为： <span class="math display">\[ln\left(\frac 1y-1\right)=bx+ln\:a\]</span> 这就把问题转换为了线性拟合，注意到由此得到的是： <span class="math display">\[\bar{\mathcal{L}}(a,b)=\frac1m\sum_{i=0}^m\left|bx_i+lna-ln\left(\frac 1y_i-1\right)\right|^2\]</span> 达到极小，故这是原非线性拟合问题的一个近似解</p><h3 id="梯度下降法">梯度下降法</h3><p>考虑使用非线性函数 <span class="math inline">\(f(x;a_1,...,a_n)\)</span> 作非线性拟合，其中 <span class="math inline">\(a_1,...,a_n\)</span> 为待定系数，我们试图寻求待定系数使得： <span class="math display">\[F(a_1,...,a_n)=\mathcal{L}(f(x;a_1,...,a_n))\]</span> 达到极小；据多元微积分理论，<span class="math inline">\(\forall a \in \mathbb{R}^n\)</span>，<span class="math inline">\(F\)</span> 在 <span class="math inline">\(a\)</span> 处沿着梯度方向变化最快，其中梯度是指： <span class="math display">\[\nabla F(a)=\left(\frac{\partial F}{\partial a_1},...,\frac{\partial F}{\partial a_n}\right)(a)\]</span> （方便起见，这里没有加上转置符号）</p><p>因而可以通过从某一初值 <span class="math inline">\(a\)</span> 开始，沿着梯度方向不断迭代的办法近似求解 <span class="math inline">\(F\)</span> 的极小值点，这被称为<strong>梯度下降法</strong>，算法如下： <span class="math display">\[\begin{aligned}&amp;a=(b_1,...,b_n)\:为初值\\&amp;\eta=10^{-4}\:为步长，又称学习率\\&amp;\varepsilon=10^{-8}\:为终止条件\\\\&amp;while\;\Vert\nabla F(a)\Vert_2 \geq \varepsilon:\\&amp;\;\;\;\;a=a-\eta\:\nabla F(a)\end{aligned}\]</span> 其中 <span class="math inline">\(\eta\)</span> 的选取至关重要，太大没法收敛，太小收敛太慢；另一方面，这种算法显然只能得到局部极小值，不能保证其为全局极小值点，因而适当的选取初值也较为重要，可以通过线性化先求解一近似解作为初值</p><h1 id="数值微积分">数值微积分</h1><p>假设需要处理的函数十分复杂，又或者我们只知道一些离散点 <span class="math inline">\(\{x_n,y_n\}\)</span> 的数据，此时需要考察求解微分以及积分的近似值的方法。</p><h2 id="数值微分">数值微分</h2><p>数值微分比较容易，因为只需要近似求解一个极限，下面记需要考察的函数为 <span class="math inline">\(f\)</span></p><h3 id="差商法">差商法</h3><p>据定义，可直接取 <span class="math inline">\(\frac{f(x+h)-f(x)}h\)</span> 作为近似值，即向前差商法；同理还有向后差商法和中心差商法。</p><p>以向前差商法为例考察误差，据 <span class="math inline">\(Taylor\)</span> 展开，有： <span class="math display">\[f(x+h)=f(x)+hf&#39;(x)+\frac{h^2}{2!}f&#39;&#39;(\xi)\]</span> 由此不难看出误差为 <span class="math inline">\(O(h)\)</span></p><h3 id="插值法-1">插值法</h3><p>取插值函数 <span class="math inline">\(L(x)\simeq f(x)\)</span>，并以插值函数的导数作为近似的方法<br>之前已讨论过插值函数的误差，从而不难估计此法的误差</p><h2 id="数值积分">数值积分</h2><p>假设我们只知道离散点 <span class="math inline">\(\{x_n,f(x_n)\}\)</span> 的数据，我们尝试考察 <span class="math inline">\(f\)</span> 在 <span class="math inline">\([a,b]\)</span> 上关于权函数 <span class="math inline">\(W(x)\)</span> 的积分： <span class="math display">\[I(f)=\int_a^bf(x)W(x)dx\]</span> 称基于这些数据给出的公式： <span class="math display">\[I_n(f)=\sum_{i=0}^na_if(x_i)\]</span> 为<strong>数值积分公式</strong>，其中 <span class="math inline">\(a_i\)</span> 为待定系数。为衡量公式的精确度，称 <span class="math inline">\(I_n(f)\)</span> 有 <strong>k 阶代数精度</strong>，若： <span class="math display">\[I_n(x^i)=I(x_i),i=0,1,...,k,\:I_n(x^{k+1})\neq I(x^{k+1})\]</span></p><h3 id="插值法-2">插值法</h3><p>与数值微分不同，若想直接使用积分定义作近似，作 <span class="math inline">\(Riemann\)</span> 和难以估计误差，而以 <span class="math inline">\(Lebesgue\)</span> 积分的观点来考察简单函数的逼近则更加困难，因而数值积分基本上只有插值法。以 <span class="math inline">\(Lagrange\)</span> 插值为例： <span class="math display">\[I_n(f)=\int_a^bL_n(x)W(x)dx=\sum_{i=0}^n\left(\int_a^bl_i(x)W(x)dx\right)f(x_i)\]</span> 据 <span class="math inline">\(Lagrange\)</span> 插值的性质，不难看出此法的代数精度至少为 <span class="math inline">\(n\)</span>，误差由插值函数的误差作积分给出</p><h2 id="函数的数值积分">函数的数值积分</h2><p>与之前讨论的仅知道离散点数据的情形不同，以下假设我们需要考察的被积函数 <span class="math inline">\(f\)</span> 为已知函数，积分区间为 <span class="math inline">\([a,b]\)</span><br>尽管仍然只能采取插值法，然而我们可以自由地选取插值基点，由此可以深入研究各种方法</p><h3 id="newton-cotes-求积公式">Newton-Cotes 求积公式</h3><p>我们考察 <span class="math inline">\(W(x)=1\)</span>，插值基点为 <span class="math inline">\(n+1\)</span> 个等距基点（步长 <span class="math inline">\(h=\frac{b-a}n\)</span>）的情形，此时有： <span class="math display">\[a_i=\int_a^bl_i(x)=\frac {(-1)^{n+1-i}\;h}{(i-1)!(n+1-i)!} \int_0^n\prod_{j=0,j\neq i-1}^n(t-j)dt\]</span> 若 <span class="math inline">\(n\)</span> 为偶数，且 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上有 <span class="math inline">\(n+2\)</span> 阶连续导数，那么误差： <span class="math display">\[E_n(f)=\frac{h^{n+3}f^{(n+2)}(\eta)}{(n+2)!}\int_0^nt\prod_{j=0}^n(t-j)dt\]</span> 若 <span class="math inline">\(n\)</span> 为奇数，且 <span class="math inline">\(f(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上有 <span class="math inline">\(n+1\)</span> 阶连续导数，那么误差： <span class="math display">\[E_n(f)=\frac{h^{n+2}f^{(n+1)}(\eta)}{(n+1)!}\int_0^nt\prod_{j=0}^n(t-j)dt\]</span> 还需要考虑舍入误差可能带来的数值不稳定性，有估计： <span class="math inline">\(|I_n(f)-I_n^*(f)|\leq\varepsilon\sum_{i=0}^n|a_i|\)</span>，其中 <span class="math inline">\(\varepsilon\)</span> 为最大的舍入误差<br>取 <span class="math inline">\(f(x)=1\)</span>，此时若 <span class="math inline">\(n\geq8\)</span>，那么存在 <span class="math inline">\(a_i&lt;0\)</span>，这会使得数值不稳定</p><p>通常我们只采用 <span class="math inline">\(n=1\)</span> 或 <span class="math inline">\(n=2\)</span> 的情形（原因见下节），这分别对应<strong>梯形公式</strong>与 <strong><span class="math inline">\(Simpson\)</span> 公式</strong></p><ul><li><p>梯形公式：<span class="math inline">\(I_1(f)=\frac{b-a}2(f(a)+f(b))\)</span></p><p>直观上，这是以梯形面积作为近似，因而叫梯形公式</p></li><li><p><span class="math inline">\(Simpson\)</span> 公式：<span class="math inline">\(I_2(f)=\frac{b-a}6\left(f(a)+4f(\frac{a+b}2)+f(b)\right)\)</span></p><p>直观上，这是以两端以及中点所作抛物线的面积作为近似，因而也叫抛物线公式</p></li></ul><h3 id="复合求积公式">复合求积公式</h3><p>前已述不能考虑通过提高 <span class="math inline">\(Newton-Cotes\)</span> 求积公式的阶数来减少误差，而另一方面，积分具有区间可加性，这启发我们将 <span class="math inline">\([a,b]\)</span> 分成若干小段，并对每一段分别使用梯形公式或 <span class="math inline">\(Simpson\)</span> 公式再求和，这就是复合求积公式。</p><p>下面考虑将 <span class="math inline">\([a,b]\)</span> 分为 <span class="math inline">\(n\)</span> 段，进而步长为 <span class="math inline">\(h=\frac{b-a}n\)</span>，为了衡量复合求积公式的精确度，称公式 <span class="math inline">\(p\)</span> 阶收敛，若： <span class="math display">\[\lim_{h\to0}\frac{I(f)-I_n(f)}{h^p}=C&lt;\infty,\:C\neq0\]</span> 下面分别考虑使用梯形公式和 <span class="math inline">\(Simpson\)</span> 公式作复合求积：</p><ul><li><p>复合梯形公式：<span class="math inline">\(T_n(f)=\frac h2(f(a)+f(b)+2\sum_{i=1}^{n-1}f(a+ih))\)</span></p><p>误差：<span class="math inline">\(E_n(f)=-\frac{h^2(b-a)}{12}f&#39;&#39;(\xi)\)</span>，因而是 <span class="math inline">\(2\)</span> 阶收敛的</p></li><li><p>复合 <span class="math inline">\(Simpson\)</span> 公式（为统一 <span class="math inline">\(h\)</span> 的值，假定 <span class="math inline">\(n\)</span> 为偶数，将 <span class="math inline">\([a,b]\)</span> 分为 <span class="math inline">\(m=\frac n2\)</span> 段）： <span class="math display">\[S_n(f)=\frac h3\left(f(a)+f(b)+4\sum_{i=1}^mf(a+(2i-1)h)+2\sum_{i=1}^{m-1}f(a+2ih)\right)\]</span> 误差：<span class="math inline">\(E_m(f)=-\frac{h^4(b-a)}{180}f^{(4)}(\xi)\)</span>，因而是 <span class="math inline">\(4\)</span> 阶收敛的</p></li></ul><p>可见，使用复合求积公式，只要通过控制 <span class="math inline">\(h\)</span>，就可以有效地控制误差，因而我们并不需要使用高阶的 <span class="math inline">\(Newton-Cotes\)</span> 求积公式<br></p><h3 id="区间逐次分半法">区间逐次分半法</h3><p>书接上回，使用复合求积公式时，若想控制误差界为给定的 <span class="math inline">\(\varepsilon\)</span>，由其误差估计式，往往需要考察 <span class="math inline">\(f\)</span> 的高阶导数，这会带来麻烦。</p><p>为此，常使用一种被称为<strong>区间逐次分半</strong>的办法——不断将区间二分，直到达到精度要求</p><p>由于我们不希望直接考察误差估计式，常常采用以下办法近似（以复合梯形公式为例）：<br>我们知道： <span class="math display">\[E_n(f)=I(f)-T_n(f)=-\frac{h^2(b-a)^3}{12n^2}f&#39;&#39;(\xi_1)\\E_{2n}(f)=I(f)-T_{2n}(f)=-\frac{h^2(b-a)^3}{12\times4n^2}f&#39;&#39;(\xi_2)\]</span> 如果我们认为：<span class="math inline">\(f&#39;&#39;(\xi_1)\simeq f&#39;&#39;(\xi_2)\)</span>，那么 <span class="math inline">\(E_n(f)\simeq 4E_{2n}(f)\)</span>，由此可以推出： <span class="math display">\[E_{2n}(f)\simeq \frac13(T_{2n}(f)-T_n(f))\]</span> 这样，我们就回避了直接考察 <span class="math inline">\(f&#39;&#39;\)</span></p><p>另一方面，若记 <span class="math inline">\(n=2^{m-1}\)</span> ，即将 <span class="math inline">\([a,b]\)</span> 作 <span class="math inline">\(2^{m-1}\)</span> 等分，记由此得到的梯形值为 <span class="math inline">\(T_{m,1}\)</span>（下标与 <span class="math inline">\(T_n\)</span> 作区分，无其他含义），那么： <span class="math display">\[T_{m,1}=\frac12\left(T_{m-1,1}+h_{m-1}\sum_{k=1}^{2^{m-2}}f(a+(k-\frac12)h_{m-1})\right)\\h_m=\frac{b-a}{2^{m-1}}\]</span> 即每一次半分时存在递推关系，降低了计算量；事实上，后面会介绍 <span class="math inline">\(Romberg\)</span> 积分法，想法与此十分相似</p><h3 id="自适应积分法">自适应积分法</h3><p>在区间逐次分半法中，每次我们都将区间的等分数量翻倍，尽管有递推式，但这样做仍然会导致速度较慢。<br>然而事实上，我们可以将需要控制的误差界 <span class="math inline">\(\varepsilon\)</span> 在等分的 <span class="math inline">\(n\)</span> 个区间上分别考虑，<br>只要每个区间上的误差都不超过 <span class="math inline">\(\frac\varepsilon n\)</span>，那么也能达到同样的目的</p><p>这样，我们只需要对那些误差超过 <span class="math inline">\(\frac\varepsilon n\)</span> 的区间应用逐次分半法，这就是<strong>自适应积分法</strong>。<br>不难看出，这种办法很适合递归实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">self_adaptive_integral</span><span class="params">(f,a,b,eps)</span></span></span><br><span class="line"><span class="keyword">if</span> numeric_integral_err(f,a,b) &lt; <span class="built_in">eps</span></span><br><span class="line">y = numeric_integral(f,a,b);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">c = (a+b)/<span class="number">2</span>;</span><br><span class="line">y = self_adaptive_integral(f,a,c,<span class="built_in">eps</span>/<span class="number">2</span>) + self_adaptive_integral(f,c,b,<span class="built_in">eps</span>/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中 <code>numeric_integral()</code> 是某个数值积分公式，<code>numeric_integral_err()</code> 往往类似于区间逐次分半法中的误差估计方法</p><p>需要指出的是，由于分半的过程中，各个区间需要处理的误差界也在减半，因而此法容易陷入无限递归，应当加上递归层数的限制</p><h3 id="euler-maclaurin-公式"><span class="math inline">\(Euler-Maclaurin\)</span> 公式</h3><p>后面会稍微用到，但用得不多，故只给出相关结果，证明略</p><p>记 <span class="math inline">\(B_n\)</span> 为 <span class="math inline">\(Bernoulli\)</span> 数，这是由：<span class="math inline">\(\frac{x}{e^x-1}=\sum_{n=0}^\infty \frac{B_n}{n!}x^n\)</span> 给出的，显式公式为： <span class="math display">\[B_n=\sum_{k=0}^n\frac1{k+1}\sum_{r=0}^kC_k^r(-1)^rr^n\]</span> 设 <span class="math inline">\(a,b\in\mathbb{N},\:f\in C^\infty[a,b]\)</span>，那么有 <span class="math inline">\(Euler-Maclaurin\)</span> 公式： <span class="math display">\[\sum_{n=a}^bf(n)-\int_a^bf(x)dx=\frac12(f(a)+f(b))+\sum_{n=1}^\infty \frac{B_{2n}}{2n!}(f^{(2n-1)}(b)-f^{(2n-1)}(a))\]</span> （简单来说就是利用 <span class="math inline">\(Bernoulli\)</span> 多项式的性质反复分部积分得到的）</p><p>一般地，若 <span class="math inline">\(f\in C^k[a,b]\)</span>，那么同样有： <span class="math display">\[\sum_{n=a}^bf(n)-\int_a^bf(x)dx=\frac12(f(a)+f(b))+\sum_{n=2}^{k-1} \frac{B_{n}}{n!}(f^{(n-1)}(b)-f^{(n-1)}(a))+R_k(f)\]</span> 为了描述余项，需要引入 <span class="math inline">\(Bernoulli\)</span> 多项式，类似地，这由：<span class="math inline">\(\frac{te^{tx}}{e^t-1}=\sum_{n=0}^\infty B_n(x)\frac{t^n}{n!}\)</span> 给出，有显式公式： <span class="math display">\[B_n(x)=(B+x)^n\]</span> 其中 <span class="math inline">\(B^k=B_k\)</span> 为 <span class="math inline">\(Bernoulli\)</span> 数（只是个方便的记号，<span class="math inline">\(B\)</span> 并不是一个数）</p><p>于是，记 <span class="math inline">\(\{x\}=x-[x]\)</span> 为 <span class="math inline">\(x\)</span> 的小数部分，那么余项就可以写为： <span class="math display">\[R_k(f)=(-1)^{k-1}\int_a^b\frac{B_k(\{x\})}{k!}f^{(k)}(x)dx\]</span> 对于 <span class="math inline">\(a,b\in\mathbb{R}\)</span> 的情形，可以固定 <span class="math inline">\(n\in\mathbb{N}\)</span>，由 <span class="math inline">\(x\to \frac{b-a}nx+a\)</span> 将 <span class="math inline">\([0,n]\to[a,b]\)</span>，再使用上述公式</p><p>如果记 <span class="math inline">\(h=\frac{b-a}n\)</span>，整理可以得到： <span class="math display">\[\sum_{i=0}^nhf(a+ih)-\int_a^bf(x)dx=\frac h2(f(a)+f(b))+\sum_{m=2}^{k-1} \frac{B_{m}}{m!}h^{m}(f^{(m-1)}(b)-f^{(m-1)}(a))+R_k(f)\\R_k(f)=(-1)^{k-1}h^k\int_a^b\frac{B_k(\{\frac{x-a}h\})}{k!}f^{(k)}(x)dx\]</span></p><p>注意， <span class="math inline">\(\sum_{i=0}^nhf(a+ih)-\frac h2(f(a)+f(b))\)</span> 恰为复合梯形公式！<br>故 <span class="math inline">\(Euler-Maclaurin\)</span> 公式事实上给出了复合梯形公式的一个极为精确的误差估计</p><h3 id="romberg-积分法"><span class="math inline">\(Romberg\)</span> 积分法</h3><p>沿用区间逐次分半法的相关记号，将 <span class="math inline">\([a,b]\)</span> 作 <span class="math inline">\(2^{m-1}\)</span> 等分，记由此得到的梯形值为 <span class="math inline">\(T_{m,1}\)</span></p><p><span class="math inline">\(Romberg\)</span> 积分法实质上是利用 <span class="math inline">\(Euler-Maclaurin\)</span> 公式对此做了改进，从而大大加快了收敛速度<br>事实上，据 <span class="math inline">\(Euler-Maclaurin\)</span> 公式，有： <span class="math display">\[I(f)-T_{m,1}=a_2h^2+a_4h^4+O(h^6)\]</span> 其中 <span class="math inline">\(a_2,a_4\)</span> 只与 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(a,b\)</span> 处的相关导数值有关，若进一步考察 <span class="math inline">\(T_{m-1,1}\)</span>，有： <span class="math display">\[I(f)-T_{m-1,1}=2^2a_2h^2+2^4a_4h^4+O(h^6)\]</span> 由此，我们容易消去误差中的 <span class="math inline">\(h^2\)</span> 项，从而直接将误差缩小至 <span class="math inline">\(O(h^4)\)</span>！<br>我们记： <span class="math display">\[T_{m,2}=\frac{4T_{m,1}-T_{m-1,1}}{3}\]</span> （不难验证，这恰为复合 <span class="math inline">\(Simpson\)</span> 公式）</p><p>仿此，可以继续考虑： <span class="math display">\[I(f)-T_{m,2}=b_4h^4+b_6h^6+O(h^8)\\I(f)-T_{m-1,2}=2^4b_4h^4+2^6b_6h^6+O(h^8)\\\Rightarrow T_{m,3}=\frac{16T_{m,2}-T_{m-1,2}}{15}\]</span> 一般地，有： <span class="math display">\[T_{m,j}=\frac{4^{j-1}T_{m,j-1}-T_{m-1,j-1}}{4^{j-1}-1}\]</span> 再结合区间逐次分半法中提到的递推式： <span class="math display">\[T_{m,1}=\frac12\left(T_{m-1,1}+h_{m-1}\sum_{k=1}^{2^{m-2}}f(a+(k-\frac12)h_{m-1})\right)\\T_{1,1}=\frac{h_1}2(f(a)+f(b)),\;h_m=\frac{b-a}{2^{m-1}}\]</span> 这就给出了 <span class="math inline">\(Romberg\)</span> 积分法，计算顺序呈三角式，也就是： <span class="math display">\[\begin{aligned}&amp;T_{1,1}\\&amp;T_{2,1} &amp;T_{2,2}\\&amp;T_{3,1} &amp;T_{3,2} &amp;&amp;T_{3,3}\\&amp;...\end{aligned}\]</span></p><h3 id="gauss-求积公式"><span class="math inline">\(Gauss\)</span> 求积公式</h3><p>到目前为止，我们的讨论大都基于 <span class="math inline">\(Newton-Cotes\)</span> 求积公式——一个选取等距基点的方法</p><p>一个自然的问题是，若选取一些特殊的基点作插值，是否可以达到更好的效果？这就是 <span class="math inline">\(Gauss\)</span> 求积公式要讨论的问题</p><p>之前已经讨论过，<span class="math inline">\(n+1\)</span> 个插值基点 <span class="math inline">\(a\leq x_0&lt;x_1&lt;...&lt;x_n\leq b\)</span> 给出的求积公式： <span class="math display">\[I_n(f)=\int_a^bL_n(x)W(x)dx=\sum_{i=0}^n\left(\int_a^bl_i(x)W(x)dx\right)f(x_i)\]</span> 的代数精度至少为 <span class="math inline">\(n\)</span>，如果记 <span class="math inline">\(\omega_{n+1}(x)=\prod_{i=0}^n(x-x_i)\)</span>，则上式又可以写为： <span class="math display">\[I_n(f)=\sum_{i=0}^n\left(\int_a^b\frac{\omega_{n+1}(x)}{(x-x_i)\omega&#39;_{n+1}(x)}W(x_i)dx\right)f(x_i)\]</span> 可以证明，上述求积公式的代数精度至多是 <span class="math inline">\(2n+1\)</span>，且达到 <span class="math inline">\(2n+1\)</span> 的充分必要条件为：</p><p><span class="math inline">\(\omega_{n+1}(x)\)</span> 与不高于 <span class="math inline">\(n\)</span> 次的任何多项式都关于区间 <span class="math inline">\([a,b]\)</span> 上的权函数 <span class="math inline">\(W(x)\)</span> 直交</p><p>事实上，如果 <span class="math inline">\(p(x)\)</span> 为一个不高于 <span class="math inline">\(2n+1\)</span> 次的多项式，由带余除法： <span class="math display">\[p(x)=q(x)\omega_{n+1}(x)+r(x)\]</span> 再结合直交的条件就不难看出结论成立</p><p>一般地，我们称选取了 <span class="math inline">\(n+1\)</span> 个插值基点的求积公式为 <span class="math inline">\(Gauss\)</span> 型求积公式，若其代数精度为 <span class="math inline">\(2n+1\)</span></p><p>下面我们简单考虑其误差，因为代数精度为 <span class="math inline">\(2n+1\)</span>，可选 <span class="math inline">\(Hermite\)</span> 插值逼近 <span class="math inline">\(f\)</span> 来作误差估计，由此可以证明离散误差为： <span class="math display">\[E_n(f)=Cf^{(2n+2)}(\xi)\\C=\frac{d^2}{(2n+2)!}\int_a^bp^2_{n+1}(x)dx\]</span> 其中，<span class="math inline">\(p_{n+1}(x)\)</span> 为 <span class="math inline">\([a,b]\)</span> 上关于权函数 <span class="math inline">\(W(x)\)</span> 的 <span class="math inline">\(n+1\)</span> 次直交多项式，<span class="math inline">\(d\)</span> 为 <span class="math inline">\(p_{n+1}(x)\)</span> 首项系数的倒数</p><p>下面我们讨论几个特殊情形：</p><ul><li><p><span class="math inline">\([a,b]=[-1,1],\;W(x)=1\)</span>，我们知道此时直交多项式为 <span class="math inline">\(Legendre\)</span> 多项式，取 <span class="math inline">\(n=1\)</span>，有 <span class="math inline">\(P_2(x)=\frac12(3x^2-1)\)</span></p><p>因而只要取 <span class="math inline">\(P_2(x)\)</span> 的两个根 <span class="math inline">\(x=\pm\frac1{\sqrt{3}}\)</span> 为插值基点，就得到代数精度为 <span class="math inline">\(3\)</span> 的插值公式 <span class="math display">\[\int_{-1}^1f(x)dx\simeq f(-\frac1{\sqrt{3}})+f(\frac1{\sqrt{3}})\]</span></p><p>称为 <span class="math inline">\(Gauss-Legendre\)</span> 两点公式，离散误差 <span class="math inline">\(E_1(f)=\frac1{135}f^{(4)}(\xi)\)</span></p></li><li><p><span class="math inline">\([a,b]=[-1,1],\;W(x)=\frac1{\sqrt{1-x^2}}\)</span>，我们知道此时直交多项式为 <span class="math inline">\(Chebyshev\)</span> 多项式 <span class="math inline">\(T_{n+1}(x)=cos((n+1)arccos\:x)\)</span> 因而只要取插值基点为 <span class="math inline">\(x_i=cos\left(\frac{2i-1}{2(n+1)}\pi\right),\;i=1,2,...,n+1\)</span>，就得到 <span class="math inline">\(Gauss-Chebyshev\)</span> 求积公式</p><p>利用 <span class="math inline">\(Chebyshev\)</span> 多项式的相关性质，化简后的最终结果为： <span class="math display">\[\int_{-1}^1f(x)\frac{dx}{\sqrt{1-x^2}}\simeq\frac{\pi}{n+1}\sum_{k=1}^{n+1}f(x_i)\]</span></p></li></ul><p>对于一般的情形，我们可以仿照复合求积公式的想法，首先将 <span class="math inline">\([a,b]\)</span> 等分为若干小区间，然后在每个小区间上通过积分变换将其变换为 <span class="math inline">\([-1,1]\)</span> 上的积分，应用上述公式即可</p><h2 id="重积分与广义积分">重积分与广义积分</h2><p>重积分只要处理为累次积分，就可以导出类似的积分公式（当然，概率论上有一个著名的重积分计算方法，不过此处不作介绍）</p><p>广义积分通常有两种办法处理，一是使用 <span class="math inline">\(Gauss\)</span> 型求积公式，只需要寻找相关的直交多项式；二是截断法，我们知道广义积分收敛的必要条件是在奇点附近的积分趋于 <span class="math inline">\(0\)</span>，从求解近似解的角度来讲，直接截去即可</p><h1 id="ode-初值问题数值解">ODE 初值问题数值解</h1><p>给定一个存在唯一解的 ODE 初值问题：</p><p><span class="math display">\[\left\{\begin{aligned}&amp;y&#39;=f(t,y),\;a\leq t \leq b\\&amp;y(a)=\eta\end{aligned}\right.\]</span></p><p>称在一系列离散点 <span class="math inline">\(t_0,t_1,...,,t_n\)</span> 处的近似值 <span class="math inline">\(y_0,y_1,...,y_n\)</span> 为该问题的数值解（称为离散变量法）</p><p>通常采用递推的方法，假定我们已知 <span class="math inline">\(y_0,y_1,...,y_{k-1}\)</span>，我们设计算法：<span class="math inline">\(y_k\simeq \varphi(y_0,y_1,...,y_k)\)</span><br>注意，算法两边可能同时出现 <span class="math inline">\(y_k\)</span>，这种情况我们称方法是隐式的（即需要解方程），否则是显式的</p><p>通常，我们有三种思路：</p><ul><li><p>差商代替倒数，即：<span class="math inline">\(y&#39;(t_k)\simeq \frac{y(t_{k+1})-y(t_k)}{h_k},\:h_k=t_{k+1}-t_k\)</span>，于是： <span class="math display">\[y(t_{k+1})\simeq y(t_k)+h_kf(t_k,y(t_k))\]</span> 这被称为 <span class="math inline">\(Euler\)</span> 法</p></li><li><p><span class="math inline">\(Taylor\)</span> 级数法：取等距离散点，步长 <span class="math inline">\(h=t_k-t_{k-1}\)</span>，视 <span class="math inline">\(y(t+h)\)</span> 为关于 <span class="math inline">\(h\)</span> 的函数，考察 <span class="math inline">\(h=0\)</span> 处的 <span class="math inline">\(Taylor\)</span> 展开： <span class="math display">\[\begin{aligned}&amp;y(t+h)=y(t)+hy&#39;(t)+\frac12h^2y&#39;&#39;(t)+\frac1{3!}h^3y&#39;&#39;&#39;(t)+...+\frac1{p!}h^py^{(p)}(t)+\frac1{(p+1)!}h^{p+1}y^{(p+1)}(\xi)\\&amp;=y(t)+hf(t,y)+\frac12h^2\frac d{dt}f(t,y)+\frac1{3!}h^3\frac {d^2}{dt^2}f(t,y)+...+\frac1{(p+1)!}h^{p+1}\frac{d^{p}}{dt^{p}}f(\xi,y(\xi))\end{aligned}\]</span> 截去余项就得到递推公式，不难看出 <span class="math inline">\(p=1\)</span> 时这就是 <span class="math inline">\(Euler\)</span> 法</p></li><li><p>数值积分法：<span class="math inline">\(y(t_{k+1})-y(t_k)=\int_{t_k}^{t_{k+1}}f(t,y)dt\)</span>，将右边替换为数值积分公式即可</p></li></ul><p>为了研究误差，可以假定 <span class="math inline">\(y_0,y_1,...,y_{k-1}\)</span> 是精确的，称这种情况下算法 <span class="math inline">\(\varphi(y_0,y_1,...,y_k)\)</span> 的误差为<strong>局部离散误差</strong><br>记 <span class="math inline">\(h_k=t_{k+1}-t_{k}\)</span>，我们称算法为 <span class="math inline">\(p\)</span> 阶方法，若 <span class="math inline">\(y_{k+1}\)</span> 的局部离散误差为 <span class="math inline">\(O^*(h_k^{p+1})\)</span></p><p>从整体上来看，我们称 <span class="math inline">\(y_n\)</span> 与其精确解之间的误差为<strong>整体离散误差</strong></p><h2 id="单步法">单步法</h2><p>单步法是说递推算法形如：<span class="math inline">\(y_k\simeq \varphi(y_{k-1},y_k)\)</span>，即每次递推只用到上一步的数据<br></p><p>对于等距、显式的情形，我们通常写为： <span class="math display">\[y_{k+1}\simeq y_k+h\Phi(t_k,y_k,h)\]</span> 我们首先讨论一些具体的方法，然后再从理论上系统研究误差问题</p><h3 id="euler-法及其改进"><span class="math inline">\(Euler\)</span> 法及其改进</h3><p>前已述 <span class="math inline">\(Euler\)</span> 法的原理，在等距情形，也就是 <span class="math inline">\(\Phi(t_k,y_k,h)=f(t_k,y_k)\)</span><br>因为 <span class="math inline">\(Euler\)</span> 法可以由 <span class="math inline">\(Taylor\)</span> 级数法取 <span class="math inline">\(p=1\)</span> 得到，这就不难看出其局部离散误差为 <span class="math inline">\(O^*(h^2)\)</span>，因而是一阶方法</p><p>此法精度不高，故需改进，如果我们采用数值积分法中的梯形公式，可以得到一隐式方法： <span class="math display">\[y_{k+1}\simeq y_k+\frac h2(f(t_k,y_k)+f(t_{k+1},y_{k+1}))\]</span> 据梯形公式的误差估计，我们知道此法为二阶方法，然而此法作为隐式方法，一般需要通过迭代求近似解<br>迭代求解需要一个初值，我们可以使用 <span class="math inline">\(Euler\)</span> 法提供，具体来说，也就是： <span class="math display">\[\begin{aligned}&amp;y_{k+1,0}\simeq y_k+hf(t_k,y_k)\\&amp;y_{k+1,m}\simeq y_k+\frac h2(f(t_k,y_k)+f(t_{k+1},y_{k+1,m-1}))\end{aligned}\]</span> 这个过程也被称作 <strong>PECE</strong>，即 <strong>Predict-Evaluate-Correct-Evaluate</strong>，迭代 <span class="math inline">\(k\)</span> 次的模式记为 <span class="math inline">\(P(EC)^kE\)</span><br>简单来说，就是先用显式方法作<strong>预测</strong>，再将该预测值用于隐式方法作<strong>校正</strong>（并反复迭代）的过程。</p><p>（注：如果对预测值和校正值的离散误差有较好的把握，可以通过 <span class="math inline">\(Romberg\)</span> 积分法类似的想法去进一步修正误差）</p><p>当 <span class="math inline">\(h\)</span> 足够小时，迭代一两次就已经能够得到较好的结果，由此就得到了改进的 <span class="math inline">\(Euler\)</span> 方法： <span class="math display">\[y_{k+1}\simeq y_k+\frac h2(f(t_k,y_k)+f(t_{k+1},y_k+hf(t_k,y_k)))\]</span></p><p>### <span class="math inline">\(Runge-Kutta\)</span> 方法</p><p>若直接采用 <span class="math inline">\(Taylor\)</span> 法，则有： <span class="math display">\[\Phi(t_k,y_k,h)=f(t_k,y_k)+\frac12h\frac d{dt}f(t_k,y_k)+\frac1{3!}h^2\frac {d^2}{dt^2}f(t_k,y_k)+...+\frac1{p!}h^{p-1}\frac{d^{p-1}}{dt^{p-1}}f(t_k,y_k)\]</span> 此法看似容易，然而计算 <span class="math inline">\(\frac{d^p}{dt^p}f(t,y(t))\)</span> 绝非易事，<span class="math inline">\(Runge-Kutta\)</span> 给出了一个想法，绕过了求解偏导数的麻烦</p><p>以 <span class="math inline">\(p=2\)</span> 为例（称为二阶 <span class="math inline">\(Runge-Kutta\)</span> 方法），此时： <span class="math display">\[\Phi(t,y,h)=f(t,y(t))+\frac12 h \frac d{dt}f(t,y(t))\]</span> 其中： <span class="math display">\[\frac d{dt}f(t,y(t))=f_t&#39;(t,y)+f_y&#39;(t,y)\cdot y&#39;(t)=f&#39;_t(t,y)+f&#39;_y(t,y)\cdot f(t,y)\]</span> 我们用待定系数法求一 <span class="math inline">\(\Phi\)</span> 的近似解，如下： <span class="math display">\[\begin{aligned}&amp;\Psi(t,y,h)=c_1K_1+c_2K_2\\&amp;K_1=f(t,y)\\&amp;K_2=f(t+a_1h,y+a_2hK_1)\end{aligned}\]</span> 用 <span class="math inline">\(Taylor\)</span> 展开 <span class="math inline">\(K_2\)</span>（视为 <span class="math inline">\(h\)</span> 的函数），得到： <span class="math display">\[K_2=f(t,y)+a_1hf_t&#39;(t,y)+a_2hf(t,y)f_y&#39;(t,y)+O(h^2)\]</span> 于是： <span class="math display">\[\Psi(t,y,h)=(c_1+c_2)f(t,y)+c_2h(a_1f_t&#39;(t,y)+a_2f_y&#39;(t,y)f(t,y))+O(h^2)\]</span> 我们知道： <span class="math display">\[y(t+h)=y(t)+h\Phi(t,y,h)+O(h^3)\]</span> 要想使得上式将 <span class="math inline">\(\Phi\)</span> 替换为 <span class="math inline">\(\Psi\)</span> 仍然成立，这只要求： <span class="math display">\[(c_1+c_2)f(t,y)+c_2h(a_1f_t&#39;(t,y)+a_2f_y&#39;(t,y)f(t,y))=\Phi(x,y,h)\]</span> 比较各项系数，得方程组： <span class="math display">\[\left\{\begin{aligned}&amp;c_1+c_2=1\\&amp;c_2a_1=c_2a_2=\frac12\\\end{aligned}\right.\]</span> 可自由选取一个变量的值，从而解出该方程，这样就导出了二阶 <span class="math inline">\(Runge-Kutta\)</span> 方法<br>特别地，取 <span class="math inline">\(a_1=1\)</span>，得到 <span class="math inline">\(a_2=1,\;c_1=c_2=\frac12\)</span>，由此恰好得到改进的 <span class="math inline">\(Euler\)</span> 方法</p><p>至今最常用的是一个四阶 <span class="math inline">\(Runge-Kutta\)</span> 方法： <span class="math display">\[\begin{aligned}&amp;y_{k+1}=y_k+\frac h6(K_1+2K_2+2K_3+K_4)\\&amp;K_1=f(t_k,y_k)\\&amp;K_2=f(t_k+\frac12h,y_k+\frac12hK_1)\\&amp;K_3=f(t_k+\frac12h,y_k+\frac12hK_2)\\&amp;K_4=f(t_k+h,y_k+hK_3)\end{aligned}\]</span> 其局部离散误差为 <span class="math inline">\(O^*(h^5)\)</span></p><h3 id="理论误差分析">理论误差分析</h3><p>我们从理论角度研究一些一般性的误差问题</p><h4 id="相容性">相容性</h4><p>对于等距情形，我们当然希望近似解关于 <span class="math inline">\(h\)</span> 能够收敛到精确解，而这有一个必要条件： <span class="math display">\[\lim_{h\to0}\left(\frac{y(t+h)-y(t)}{h}-\Phi(t,y,h)\right)=0\]</span> 如果 <span class="math inline">\(\Phi\)</span> 是连续函数，这个事情实际上是在说：<span class="math inline">\(y&#39;(t)=\Phi(t,y,0)\)</span>，这给出如下定义：</p><p>称单步法与初值问题是<strong>相容的</strong>，若：<span class="math inline">\(\Phi(t,y,0)=f(t,y)\)</span></p><p>如果只知道一个单步法是相容的，实际上并不能给出太多信息，这只能保证这个方法至少为一阶方法<br></p><h4 id="收敛性">收敛性</h4><p>首先我们给出收敛性的定义：任给 <span class="math inline">\(t\in[a,b]\)</span>，固定 <span class="math inline">\(t_n=t\)</span>，若有 <span class="math inline">\(\lim_{h\to0}y_n=y(t)\)</span>，则称方法是<strong>收敛的</strong><br>对于单步法，我们有如下定理：</p><p>若 <span class="math inline">\(\Phi(t,y,h)\)</span> 对 <span class="math inline">\(y\)</span> 满足 <span class="math inline">\(Lipschitz\)</span> 条件，<span class="math inline">\(\forall t,h\)</span>，则单步法收敛的充分必要条件是相容条件成立<br><span class="math inline">\(Lipshitz\)</span> 条件就是说，<span class="math inline">\(\forall y_1,y_2\in\mathbb{R}\)</span>，存在 <span class="math inline">\(L&gt;0\;s.t.\)</span> <span class="math display">\[|\Phi(t,y_1,h)-\Phi(t,y_2,h)|\leq L|y_1-y_2|,\;\forall t,h\]</span> 进一步，这给出了整体离散误差的一个估计，我们记 <span class="math inline">\(R(t,h)\)</span> 为局部离散误差，对于 <span class="math inline">\(p\)</span> 阶方法来说，应该有： <span class="math display">\[|R(t,h)|\leq Mh^{p+1}\]</span> 于是，只要 <span class="math inline">\(Lipschitz\)</span> 条件满足，那么整体离散误差 <span class="math inline">\(\varepsilon_n=y(t_n)-y_n\)</span> 就满足： <span class="math display">\[|\varepsilon_n|\leq e^{L(b-a)}|\varepsilon_0|+h^p\frac ML(e^{L(b-a)}-1)\]</span> 如果有 <span class="math inline">\(\varepsilon_0=0\)</span>，那么这个 <span class="math inline">\(p\)</span> 阶单步法的整体离散误差就为 <span class="math inline">\(O^*(h^p)\)</span></p><h4 id="稳定性">稳定性</h4><p>稳定性是指数值稳定性，在误差分析一章中有提到；<br>在 ODE 初值问题中，我们可以通过考察对初值作扰动而产生的变化来考察稳定性，具体来说：</p><p>若存在 <span class="math inline">\(h_0,C&gt;0\)</span>，使得对任意的初值 <span class="math inline">\(y_0,\bar{y}_0\)</span>，通过步长小于 <span class="math inline">\(h_0\)</span> 的单步法得到的相应的解 <span class="math inline">\(y_n,\bar{y}_n\)</span>，都满足： <span class="math display">\[|y_n-\bar{y}_n|\leq C|y_0-\bar{y}_0|\]</span> 就称单步法是<strong>稳定的</strong>；事实上，只要 <span class="math inline">\(\Phi(t,y,h)\)</span> 对 <span class="math inline">\(y\)</span> 满足 <span class="math inline">\(Lipschitz\)</span> 条件，那么单步法就是稳定的</p><p>而在实际应用中，讨论某个固定的 <span class="math inline">\(h\)</span> 的情形更有意义，为此引入<strong>绝对稳定性</strong>：</p><p>称单步法是<strong>绝对稳定的</strong>，若由初值 <span class="math inline">\(y_k,\bar{y}_k\)</span> 满足： <span class="math inline">\(\bar{y}_k=y_k+\delta\)</span> 分别给出的 <span class="math inline">\(y_{k+1},\bar{y}_{k+1}\)</span> 都有：<span class="math inline">\(\vert \bar{y}_{k+1}-y_{k+1}\vert&lt;\vert\delta\vert\)</span><br>通常，我们只讨论初值问题 <span class="math inline">\(y&#39;=\mu y\)</span> 的绝对稳定性，称 <span class="math inline">\((\alpha,\beta)\)</span> 为绝对稳定区间，若任给 <span class="math inline">\(\mu h\in(\alpha,\beta)\)</span> 单步法都绝对稳定</p><p>举例：考虑 <span class="math inline">\(Euler\)</span> 法的绝对稳定区间，这由： <span class="math display">\[|\bar{y}_{k+1}-y_{k+1}|=|1+\mu h||\delta|&lt;|\delta|\]</span> 不难看出 <span class="math inline">\(\mu h\in(-2,0)\)</span></p><h2 id="多步法">多步法</h2><p>与单步法相对的，多步法是说递推算法形如：<span class="math inline">\(y_k\simeq \varphi(y_{k-},...,y_k),\;m&gt;1\)</span></p><p>我们仍然考虑一些具体方法，然后理论分析误差</p><h3 id="adams-方法"><span class="math inline">\(Adams\)</span> 方法</h3><p>使用数值积分法 <span class="math inline">\(y(t_{k+1})-y(t_k)=\int_{t_k}^{t_{k+1}}f(t,y)dt\)</span> 的问题在于右边的积分公式一般不能显式地给出<br><span class="math inline">\(Adams\)</span> 方法指出，可以用 <span class="math inline">\(y_{k-m},...,y_k\)</span> 这些已知点作 <span class="math inline">\(f(t,y)\)</span> 的插值多项式 <span class="math inline">\(p_m(t)\)</span>，于是就得到近似公式： <span class="math display">\[y_{k+1}\simeq y_k+\int_{t_k}^{t_{k+1}}p_m(t)dt\]</span> 可以证明，<span class="math inline">\(m\)</span> 步显式 <span class="math inline">\(Adams\)</span> 方法至少为 <span class="math inline">\(m\)</span> 阶方法</p><p>亦可以将 <span class="math inline">\(y_{k+1}\)</span> 也作为插值点，由此得到方法被称为隐式 <span class="math inline">\(Adams\)</span> 方法<br>可以证明 ，<span class="math inline">\(m\)</span> 步隐式 <span class="math inline">\(Adams\)</span> 方法至少为 <span class="math inline">\((m+1)\)</span> 阶方法</p><p>（注：<span class="math inline">\(m=1\)</span> 时，隐式 <span class="math inline">\(Adams\)</span> 公式恰为梯形公式）</p><p>由于是隐式方法，通常也需要配合 <strong>PECE</strong> 模式使用，这里不详细叙述</p><p>还有一被称为 <span class="math inline">\(Milne\)</span> 方法的多步法与 <span class="math inline">\(Adams\)</span> 方法类似，只是将考虑的积分区间扩大： <span class="math inline">\(y(t_{n+1})-y(t_{n-p})=\int_{t_{n-p}}^{t_{n+1}}f(t,y)dt\)</span><br>然后仍然考虑使用插值多项式代替 <span class="math inline">\(f(t,y)\)</span>，故也不详细叙述</p><h3 id="hamming-方法"><span class="math inline">\(Hamming\)</span> 方法</h3><p>与 <span class="math inline">\(Runge-Kutta\)</span> 方法的想法类似，在等距情形，我们可以使用待定系数结合 <span class="math inline">\(Taylor\)</span> 展开的方法来构造多步法，令： <span class="math display">\[L(y(t),h)=\sum_{j=0}^k(\alpha_jy(t+jh)-h\beta_jy&#39;(t+jh))\]</span> 视为 <span class="math inline">\(h\)</span> 的函数，考虑 <span class="math inline">\(h=0\)</span> 处的 <span class="math inline">\(Taylor\)</span> 展开，我们知道其必然形如： <span class="math display">\[L(y(t),h)=c_0y(t)+c_1hy&#39;(t)+...+c_ph^py^{(p)}(t)+...\]</span> 其中 <span class="math inline">\(c_j\)</span> 与 <span class="math inline">\(y(t)\)</span> 无关，故我们分别令 <span class="math inline">\(y(t)=1,t,t^2,...\)</span> 并取 <span class="math inline">\(t=0\)</span>，就不难得到 <span class="math inline">\(c_j\)</span> 的值： <span class="math display">\[\begin{aligned}&amp;c_0=\alpha_0+\alpha_1+...+\alpha_k\\&amp;c_1=\alpha_1+2\alpha_2+...+k\alpha_k-(\beta_0+\beta_1+...+\beta_k)\\&amp;...\\&amp;c_p=\frac1{p!}(\alpha_1+2^p\alpha_2+...+k^p\alpha_k)-\frac1{(p-1)!}(\beta_1+2^{p-1}\beta_2+...+k^{p-1}\beta_k)\\&amp;...\end{aligned}\]</span> 要想使得 <span class="math inline">\(L(y(t),h)\)</span> 导出一个至少 <span class="math inline">\(p\)</span> 阶的线性多步法，这就要求：<span class="math inline">\(c_0=c_1=...=c_p=0\)</span><br>解出 <span class="math inline">\(\alpha_j,\beta_j\)</span> 即可</p><p>注：<span class="math inline">\(Hamming\)</span> 方法似乎只是 <span class="math inline">\(k=3,\;p=4,\;\alpha_k=1,\;\alpha_{k-1}=\beta_0=0\)</span> 时导出的特例</p><h3 id="理论误差分析-1">理论误差分析</h3><p>与单步法对应小节类似，我们考察形如： <span class="math display">\[\sum_{j=0}^ka_jy_{m+j}=h \sum_{j=0}^k\beta_j f(t_{m+j},y_{m+j})\]</span> 这样的线性 <span class="math inline">\(k\)</span> 步法，我们记： <span class="math display">\[\rho(\lambda)=\alpha_k\lambda^k+\alpha_{k-1}\lambda^{k-1}+...+\alpha_1\lambda+\alpha_0\\\sigma(\lambda)=\beta_k\lambda^k+\beta_{k-1}\lambda^{k-1}+...+\beta_1\lambda+\beta_0\\\]</span> 显然，这两个多项式与线性 <span class="math inline">\(k\)</span> 步法一一对应，称 <span class="math inline">\(\rho(\lambda)\)</span> 为线性 <span class="math inline">\(k\)</span> 步法的特征多项式</p><p>仿照单步法的讨论，有如下结果：</p><ul><li><p>相容性：称线性 <span class="math inline">\(k\)</span> 步法是<strong>相容的</strong>，若它至少是一阶方法</p><p>可以证明，这等价于：<span class="math inline">\(\rho(1)=0,\;\rho&#39;(1)=\sigma(1)\)</span></p></li><li><p>收敛性：称线性 <span class="math inline">\(k\)</span> 步法是<strong>收敛的</strong>，若任给 <span class="math inline">\(t\in[a,b]\)</span>，固定 <span class="math inline">\(t_n=t\)</span>，都有 <span class="math inline">\(\lim_{h\to0}y_n=y(t)\)</span></p><p>对于线性 <span class="math inline">\(k\)</span> 步法而言，难以考察收敛性，但是有等价关系：收敛 <span class="math inline">\(\Leftrightarrow\)</span> 相容且稳定</p></li><li><p>稳定性：称线性 <span class="math inline">\(k\)</span> 步法是<strong>稳定的</strong>，若存在 <span class="math inline">\(h_0,C&gt;0\)</span>，使得对任意的初值 <span class="math inline">\(y_0,\bar{y}_0\)</span><br>通过步长小于 <span class="math inline">\(h_0\)</span> 的线性 <span class="math inline">\(k\)</span> 步法得到的相应的解 <span class="math inline">\(y_n,\bar{y}_n\)</span>，都满足： <span class="math display">\[|y_n-\bar{y}_n|\leq C\mathop{max}_\limits{0\leq j \leq k-1}|y_j-\bar{y}_j|\]</span></p><p>可以证明，这等价于 <span class="math inline">\(\rho(\lambda)\)</span> 满足一个所谓的<strong>特征根条件</strong>，即：</p><p><span class="math inline">\(\rho(\lambda)\)</span> 的所有根都在单位圆中，且在单位圆上的根只能是单重根</p></li><li><p>强稳定性：上述稳定性一般又称弱稳定性（误差可能会震荡），特征根条件称为弱根条件，若进一步满足：</p><p><span class="math inline">\(\rho(\lambda)\)</span> 的全部根除了 <span class="math inline">\(\lambda =1\)</span> 外均在单位圆内（强根条件），则称满足<strong>强稳定性</strong></p></li><li><p>绝对稳定性：仍然只讨论 <span class="math inline">\(y&#39;=\mu y\)</span>，此时线性 <span class="math inline">\(k\)</span> 步法可以看成 <span class="math inline">\(k\)</span> 阶常系数递推数列，有特征方程： <span class="math display">\[\rho(\lambda)-\mu h\sigma(\lambda) = 0\]</span> 我们称线性 <span class="math inline">\(k\)</span> 步法是<strong>绝对稳定的</strong>，若上述方程的根 <span class="math inline">\(\lambda_r\)</span> 都满足 <span class="math inline">\(|\lambda_r|&lt;1\)</span><br>称 <span class="math inline">\((\alpha,\beta)\)</span> 为绝对稳定区间，若任给 <span class="math inline">\(\mu h\in(\alpha,\beta)\)</span> 多步法都绝对稳定</p><p>可以证明，当 <span class="math inline">\(h\)</span> 接近 <span class="math inline">\(0\)</span> 时，想要达成绝对稳定必须要有 <span class="math inline">\(\mu h&lt;0\)</span></p></li></ul><h2 id="高阶-ode-和-ode-方程组">高阶 ODE 和 ODE 方程组</h2><p>对于一阶 ODE 方程组，只要简单地记 <span class="math inline">\(Y=(y_1,...,y_m),\;F=(f_1,...,f_m),\;\eta=(\eta_1,...,\eta_m)\)</span>，那么初值问题就形如： <span class="math display">\[\left\{\begin{aligned}&amp;Y&#39;=F(t,Y),\;a\leq t \leq b\\&amp;Y(a)=\eta\end{aligned}\right.\]</span> 之前讨论的方法对此是完全适用的，而对于高阶 ODE： <span class="math display">\[\left\{\begin{aligned}&amp;y^{(m)}=f(t,y,y&#39;,...,y^{(m-1)}),\;a\leq t \leq b\\&amp;y(a)=\eta_1,\;y&#39;(a)=\eta_2,...,y^{(m-1)}(a)=\eta_m\end{aligned}\right.\]</span> 只要令：<span class="math inline">\(y_1=y,\;y_2=y&#39;,...,y_m=y^{(m-1)}\)</span>，就化为了方程组： <span class="math display">\[\left\{\begin{aligned}&amp;y_1&#39;=y_2,\;y_1(a)=\eta_1\\&amp;y_2&#39;=y_3,\;y_2(a)=\eta_2\\&amp;...\\&amp;y_m&#39;=f(t,y_1,y_2,...,y_m),\;y_m(a)=\eta_m\\\end{aligned}\right.\]</span> 故无需多言</p><h1 id="后记">后记</h1><ol type="1"><li>这门课其实还讲了点 <strong>M-P 神经网络</strong>，然而感觉讲的太快太浅，偏科普性质（问就是感觉自己学了个寂寞），故没有整理至此。</li><li>没有整理<strong>差分方程</strong>一节，个人认为本质上跟 <span class="math inline">\(k\)</span> 阶递推数列相关理论没什么区别，反正都是线代的活。</li><li>封面是我有一次把梯度下降方向搞反了搞成了“梯度上升”的图像捏，挺壮观的是不是（（（</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇为应付考试而整理的复习笔记，因而只是整理我个人认为考前需要速通的点，因而不一定全面以及完备。&lt;/p&gt;
&lt;h1 id=&quot;误差分析&quot;&gt;误差分析&lt;/h1&gt;
&lt;h2 id=&quot;两类基本误差&quot;&gt;两类基本误差&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;绝对误差：&lt;span class
      
    
    </summary>
    
    
      <category term="学习" scheme="http://dasasdhba.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://dasasdhba.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>「数值分析」浅析快速傅里叶变换 FFT</title>
    <link href="http://dasasdhba.github.io/study-FFT/"/>
    <id>http://dasasdhba.github.io/study-FFT/</id>
    <published>2023-03-29T11:57:26.000Z</published>
    <updated>2023-03-30T10:29:28.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近学数值分析这门课的时候碰到了 <strong>DFT</strong> 与 <strong>FFT</strong>，然而我们学校 <strong>PPT</strong> 上给出的 <strong>FFT</strong> 看起来实在是令人费解，教材更是直接摆烂不写了。</p><p>于是我想在网上找找教程看看，又发现网上的教程跟我们教材的思路又不完全相同，其看起来似乎是一个更加易懂的改进，所以我想在此简单记录一下。仅解析原理，不提供具体算法实现。</p><h1 id="解析">解析</h1><p>我们考虑 <span class="math inline">\(f\)</span> 在等距点集 <span class="math inline">\(\left\{x_j=\frac{2\pi j}N|j=0,1,...,N-1\right\}\)</span> 上用正交函数族 <span class="math inline">\(1,e^{ix},...,e^{i(N-1)x}\)</span> 得到的最佳平方逼近： <span class="math display">\[S(x)=\sum_{k=0}^{N-1}c_ke^{ikx}\]</span> 其中 <span class="math display">\[c_k=\frac1N \sum_{j=0}^{N-1}f(x_j)e^{-ik\frac{2\pi j}N}\;(k=0,1,...,N-1)\]</span> 被称为 <strong>DFT</strong>，要想得到所有 <span class="math inline">\(c_k\)</span> 共需要计算 <span class="math inline">\(N^2\)</span> 次乘法和加法，<strong>FFT</strong> 给出了该计算的快速实现。</p><h2 id="思路">思路</h2><p>方便起见，记 <span class="math inline">\(f_j=f(x_j),\:\omega_N=e^{-i\frac{2\pi}N}\)</span>，那么 <span class="math inline">\(c_k=\frac1N \sum_{j=0}^{N-1}f_j\omega_N^{kj}\)</span></p><p>注意到，<span class="math inline">\(\omega_N^{kj}\)</span> 事实上只有 <span class="math inline">\(1,\omega_N,...,\omega_N^{N-1}\)</span> 这 <span class="math inline">\(N\)</span> 个值，这实际上是复平面上单位圆的 <span class="math inline">\(N\)</span> 等分点</p><p>因而不难发现，若 <span class="math inline">\(N\)</span> 为偶数，由对称性就有 <span class="math inline">\(\omega_N^k+\omega_N^{\frac N2+k}=0\)</span></p><p>一个自然的想法是合并公因子，所以我们可以将 <span class="math inline">\(c_k\)</span> 改写为： <span class="math display">\[c_k=\frac1N\left(\sum_{j=0}^{\frac N2-1}f_j\omega_N^{kj}+\sum_{j=0}^{\frac N2-1}f_{\frac N2+j}\omega_N^{k(\frac N2+j)}\right)=\frac1N\left(\sum_{j=0}^{\frac N2-1}f_j\omega_N^{kj}+\sum_{j=0}^{\frac N2-1}(-1)^kf_{\frac N2+j}\omega_N^{kj}\right)=\frac1N\sum_{j=0}^{\frac N2-1}(f_j+(-1)^kf_{\frac N2+j})\omega_N^{kj}\]</span> 具体考虑 <span class="math inline">\(k\)</span> 为奇数或者偶数的情况，有： <span class="math display">\[c_{2k}=\frac1N\sum_{j=0}^{\frac N2-1}(f_j+f_{\frac N2+j})\omega_{\frac N2}^{kj}\\c_{2k+1}=\frac1N\sum_{j=0}^{\frac N2-1}(f_j-f_{\frac N2+j})\omega_N^{j}\omega_{\frac N2}^{kj}\]</span> 从而如果 <span class="math inline">\(\frac N2\)</span> 仍为偶数，我们就可以对 <span class="math inline">\(c_{2k}\)</span> 与 <span class="math inline">\(c_{2k+1}\)</span> 重复上述过程</p><p>特别地，若 <span class="math inline">\(N=2^p\)</span>，则该过程可以一直重复下去</p><h2 id="改进">改进</h2><p>一个简单的改进是直接考察 <span class="math inline">\(c_k\)</span> 中的奇数项和 <span class="math inline">\(S_k\)</span> 与偶数项和 <span class="math inline">\(T_k\)</span>： <span class="math display">\[c_k=\frac1N \sum_{j=0}^{N-1}f_j\omega_N^{kj}=S_k+T_k\\S_k=\frac1N \sum_{j=0}^{\frac N2-1}f_{2j+1}\omega_N^k\omega_{\frac N2}^{kj}\\T_k=\frac1N \sum_{j=0}^{\frac N2-1}f_{2j}\omega_{\frac N2}^{kj}\]</span> 那么由于 <span class="math inline">\(\frac N2\)</span> 仍为偶数，可以对 <span class="math inline">\(S_k\)</span> 与 <span class="math inline">\(T_k\)</span> 反复作相同操作，而这个改进的关键在于： <span class="math display">\[c_{k+\frac N2}=\frac1N \sum_{j=0}^{N-1}f_j\omega_N^{(k+\frac N2)j}=\frac1N \sum_{j=0}^{N-1}(-1)^jf_j\omega_N^{kj}=T_k-S_k\]</span> 由此我们事实上只需要计算 <span class="math inline">\(c_0,c_1,...,c_{\frac N2-1}\)</span>，对于 <span class="math inline">\(S_k\)</span> 与 <span class="math inline">\(T_k\)</span> 亦然</p><h1 id="参考文献">参考文献</h1><p>[1] 李庆扬, 王能超, 易大义. 数值分析第 5 版 [M]. 清华大学出版社, 2009. P87</p><p>[2] 快速理解 FFT 算法. 2022. <a href="https://zhuanlan.zhihu.com/p/407885496" target="_blank" rel="noopener" class="uri">https://zhuanlan.zhihu.com/p/407885496</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近学数值分析这门课的时候碰到了 &lt;strong&gt;DFT&lt;/strong&gt; 与 &lt;strong&gt;FFT&lt;/strong&gt;，然而我们学校 &lt;strong&gt;PPT&lt;/strong&gt; 上给出的 &lt;strong&gt;FFT&lt;/strong&gt; 看
      
    
    </summary>
    
    
      <category term="学习" scheme="http://dasasdhba.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://dasasdhba.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Godot 自学指南</title>
    <link href="http://dasasdhba.github.io/tutorial-Godot/"/>
    <id>http://dasasdhba.github.io/tutorial-Godot/</id>
    <published>2022-11-17T05:35:00.000Z</published>
    <updated>2022-11-19T11:07:26.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>（本文使用版本为 <strong><em>Godot 3.5.x</em></strong>）</p><p>首先说一个观点，我们自学 <strong><em>Godot</em></strong> 主要是看自己的需求（想学的一般是想做独立游戏的吧，想吃饭的我建议你还是去学 <strong><em>Unity</em></strong>），不能说是这个引擎能干的事情我们都去学（除非你的目标是成为什么 <em>Godot 砖家</em>）。</p><p>基于这样的观点，本文并不是传统意义的什么 <strong><em>Godot</em></strong> 教程（比如什么<strong>如何用 Godot 制作 xxx</strong>，这样的教程我相信太多了），而是如何自学 <strong><em>Godot</em></strong> 的教程。换句话说，本文仅仅是给你自学指个路，毕竟这软件门槛确实有那么一点高。</p><h1 id="官方文档最好的参考资料">官方文档——最好的参考资料</h1><p><strong>温馨提示</strong>：接下来我会贴很多链接，但你没有必要每读到一个链接就去把这个链接的内容看完（可以先收藏），除非你看到了新的<strong>温馨提示</strong>，那里我会建议你先回来看看这些链接。</p><p>首先在此附上官方文档链接：<a href="https://docs.godotengine.org/en/stable/" target="_blank" rel="noopener" class="uri">https://docs.godotengine.org/en/stable/</a></p><p>我这里贴的是英文版，<strong>有能力阅读英文的尽量直接看英文版</strong>，因为别的语言都是基于英文版翻译而来的，至少中文版确实存在错误和漏翻的现象。</p><p>实在看不动英文也不要勉强，中文也不是不行，左下角就可以切换语言。</p><h2 id="入门级教程">入门级教程</h2><p>从官方文档的 <em>Getting Start</em> 部分开始可以帮助你快速熟悉软件界面，我建议阅读前两节，后面那两个 <em>Your First 2D/3D Game</em> 不算特别需要，直接跳过也无妨。</p><h2 id="编程语言基础教程">编程语言基础教程</h2><p>直接附上链接：<a href="https://docs.godotengine.org/en/stable/tutorials/scripting/index.html#programming-languages" target="_blank" rel="noopener" class="uri">https://docs.godotengine.org/en/stable/tutorials/scripting/index.html#programming-languages</a></p><p>一般来说只看 <strong><em>GDScript</em></strong> 就可以，这门语言特别简单（特别像 <strong><em>Python</em></strong>），你但凡稍微有点基础就能够快速入手。</p><p>这里的基础指的是程序设计基础，一般来说大学的 <strong><em>C/C++/Python</em></strong> 通识课程够用（前提是你好好学了而不是水过去的），中学的 <strong><em>VB/Python</em></strong> 课程因地区而异，我不好说。</p><p>如果你没啥基础的话，那我也不能保证你看这个够不够用，大概率是不够用的，毕竟程序设计的基本思想不是一个讲语法的教程能够教会的。对于这种情况，我建议你还是直接先去学我上面提到的课程再说（上面提到了 <strong><em>GDScript</em></strong> 特别像 <strong><em>Python</em></strong>，所以你直接去学习 <strong><em>Python</em></strong> 程序设计基础就可以）。当然，你也可以先不管，说不定你的需求特别简单，不需要太多基础也能做；你也可以选择多看看 <strong><em>Godot</em></strong> 自带示例项目以及别的开源项目，学习别人的写法，如果真没基础的话这样会比较难，但相对比较快。</p><p>顺带一提，官网也推荐了一个零基础教程：<a href="https://gdquest.github.io/learn-gdscript/?ref=godot-docs" target="_blank" rel="noopener" class="uri">https://gdquest.github.io/learn-gdscript/?ref=godot-docs</a></p><p>不过没有中文版，我也不知道效果好不好，感兴趣可以试试。</p><p>以及，尽管 <strong><em>Godot</em></strong> 支持 <em>C#</em>，而且就算你恰好也会 <em>C#</em>，我还是建议你简单学学 <strong><em>GDScript</em></strong>（我相信你有这么好的基础的话肯定学的很快），因为在 <strong><em>Godot</em></strong> 里很多事情用后者处理会方便得多。</p><h2 id="程序设计进阶教程">程序设计进阶教程</h2><p>（没基础的话可以先跳过）</p><p>首先是<strong>最佳实践</strong>：<a href="https://docs.godotengine.org/en/stable/tutorials/best_practices/index.html" target="_blank" rel="noopener" class="uri">https://docs.godotengine.org/en/stable/tutorials/best_practices/index.html</a></p><p>这里面讲了一些比较基本的面向对象思想，并且对于如何组织项目等问题都给出了建议，非常值得参考。</p><p>其次是<strong>优化</strong>：<a href="https://docs.godotengine.org/en/stable/tutorials/performance/index.html" target="_blank" rel="noopener" class="uri">https://docs.godotengine.org/en/stable/tutorials/performance/index.html</a></p><p>这里面给出了如何进行调试分析以及优化的基本建议，推荐有一定开发经验的人员阅读，还算是比较实用；没什么开发经验的话就不建议看得太深入，比如假设你根本不知道什么时候该用线程，就别想着用线程优化，因为你很有可能搞成负优化。</p><h2 id="功能实现类教程">功能实现类教程</h2><p>官方文档的 <em>Tutorials</em> 部分主要是关于引擎对于特定功能（往往都是基础功能）如何实现的具体说明，这个就看自己的需求去阅读了。</p><p>比如假设我想做一个 <strong>2D Platform</strong>，那么我就需要去看 <em>2D</em> 以及 <em>Physics</em> 部分。</p><h2 id="api-文档">API 文档</h2><p>这部分内容与在引擎内使用 <code>F1</code> 的效果完全相同，而且引擎内的版本一方面是离线版（网页版加载有时候会很慢），另一方面也有非常方便的检索机制，因此我推荐在引擎内阅读这一部分，而将网页端作为一个备选项。</p><p>如果你不知道 <strong>API</strong> 是啥，你可以先大致理解为这部分内容是对引擎里面的各种东西具体能做什么的一个说明。总之，<strong>API 文档</strong> 放在任何一个游戏引擎都是非常重要的内容，但从学习的角度来说我们对于这部分内容一般都是即查即用（然后你会自然地记住特别常用的内容），之后对于特别常用的内容我会贴链接以及作部分讲解说明。</p><h2 id="官方-qa-平台">官方 Q&amp;A 平台</h2><p>还是直接附上链接：<a href="https://godotengine.org/qa/" target="_blank" rel="noopener" class="uri">https://godotengine.org/qa/</a></p><p>遇到问题可以首先在这里搜索（需要使用英文），很多时候你遇到的问题都是别人遇到过的。</p><p>此外，官方论坛的性质也类似：<a href="https://godotforums.org/" target="_blank" rel="noopener" class="uri">https://godotforums.org/</a></p><p>不过论坛上肯定不是纯粹的 <strong>Q&amp;A</strong>，也有很多其他有用的资源，自己探索吧。</p><h2 id="使用搜索引擎">使用搜索引擎</h2><p>使用 <strong><em>Google/Bing</em></strong> 等搜索引擎直接搜索问题一般也能找到一些资料。（最好用英文）</p><p>当然你很有可能搜到的就是刚才提到的 <strong>Q&amp;A</strong> 平台上的问题，不过这也无妨。</p><h2 id="其他资源">其他资源</h2><ul><li><p>官方资源网站：<a href="https://godotengine.org/asset-library/asset" target="_blank" rel="noopener" class="uri">https://godotengine.org/asset-library/asset</a></p><p>这里面资源不少，还能找到很多实用的插件（<strong><em>Addon</em></strong>），需要的功能引擎不直接提供的话可以来翻翻看。</p></li><li><p><strong>Shader</strong> 资源网站：<a href="https://godotshaders.com/" target="_blank" rel="noopener" class="uri">https://godotshaders.com/</a></p><p>里面有很多开源的 <strong>Shader</strong> 可以直接使用和学习。</p></li><li><p>一个相对火的教程网站：<a href="https://godottutorials.com/" target="_blank" rel="noopener" class="uri">https://godottutorials.com/</a></p><p>这个并不是官方教程，我自己也没看过，不过既然比较火还是在这里贴一下，可以参考。</p></li></ul><p>至于别的非官方教程资源我就更没有看过了，自己取舍吧，说不定能找到适合你的。</p><h1 id="godot-程序基础">Godot 程序基础</h1><p><strong>温馨提示 2</strong>：阅读本节之前，你最好先至少看完了官方文档的 <em>Getting Start</em> 部分的前两节，且保证自己有一定的程序设计基础。</p><h2 id="前言-1">前言</h2><p>这一节是为了解决官方文档缺少的一个重要内容：<strong>Godot 程序是怎么跑起来的？</strong></p><p>（也不能这么说，因为在 <strong>API</strong> 文档里面有）</p><p>我个人认为足够了解自己的程序的运作机制是十分必要的，否则做程序设计时总会感觉不少地方有些含糊不清（比如不知道代码的运行顺序等等）。</p><h2 id="主循环mainloop">主循环（Mainloop）</h2><p>游戏程序本质上是一个 <strong>while 循环</strong>，游戏引擎提供了一个框架，你要做的就是往这个循环里面填东西，这一小节我们简单介绍 <strong><em>Godot</em></strong> 的主循环。</p><h3 id="官方文档参考">官方文档参考</h3><p>在 <strong>API</strong> 文档中可以找到这部分内容：<a href="https://docs.godotengine.org/en/stable/classes/class_mainloop.html" target="_blank" rel="noopener" class="uri">https://docs.godotengine.org/en/stable/classes/class_mainloop.html</a></p><p>你不看也没关系因为我接下来就是要讲这个。</p><h3 id="process-与-physics_process">process 与 physics_process</h3><p><strong><em>Godot</em></strong> 提供了本小节标题所述的两类主循环，它们是独立运行的，下面我们作简单介绍：</p><ul><li><p><strong><em>physics_process</em></strong>：大部分游戏引擎都提供的一类主循环，且部分游戏引擎（如 <strong><em>Gamemaker</em></strong>）只提供了这一类。</p><p>具体来说，这个循环是根据你预先设定的一个<strong>帧率</strong>（默认60）稳定运作的。当然，如果性能承受不住，那就会出现所谓的“掉帧”现象。</p></li><li><p><strong><em>process</em></strong>：这个循环的速度取决于屏幕刷新率，你也可以简单理解为要多快有多快。</p><p>对于一些需要高刷的游戏（如音游），或者说对于特定的功能实现（如高精度计时器）来说很有用。</p></li></ul><h3 id="delta-参数将行为与帧率独立">delta 参数：将行为与帧率独立</h3><p>当你看到我对 <strong><em>process</em></strong> 的介绍时，你可能会疑惑：既然是要多快有多快，那我怎么保证我能做出我需要的速度呢？</p><p>事实上，<strong><em>Godot</em></strong> 的这两类主循环都会提供一个 <strong>delta</strong> 参数：从上一帧到这一帧所经过的真实时间，单位为秒。</p><p>因此，利用这样一个参数，一方面可以在 <strong><em>process</em></strong> 中有效地控制速度，另一方面对于 <strong><em>physics_process</em></strong> 来说，即使掉帧也不会出现“变速”现象。</p><p>当然，这要求你使用 <strong>px/s</strong>、<strong>px/s^2</strong> （px 是像素）作为速度和加速度的单位，如果你以前使用的都是 <strong>px/frame</strong> 的体系，需要稍微适应一下。</p><p>（或者你继续用 <strong>px/frame</strong> 也行，只是掉帧就会变速）</p><h2 id="scenetree默认的主循环结构">SceneTree：默认的主循环结构</h2><p><strong>SceneTree</strong> 是 <strong><em>Godot</em></strong> 程序默认采用的主循环结构（这意味着你也可以自己做主循环结构，虽然大部分情况下这不太必要），也算是非常核心的一环。</p><h3 id="官方文档参考-1">官方文档参考</h3><p><strong>API</strong> 文档中同样对 <strong>SceneTree</strong> 有介绍：<a href="https://docs.godotengine.org/en/stable/classes/class_scenetree.html" target="_blank" rel="noopener" class="uri">https://docs.godotengine.org/en/stable/classes/class_scenetree.html</a></p><p>我们可以看到 <strong>SceneTree</strong> 继承于 <strong>Mainloop</strong>，它就是默认的主循环。</p><p>（如果你不知道“继承”是什么，说明你对 <strong>Class</strong> 以及<strong>面向对象</strong>的概念不熟悉，可以参考官方文档中的<strong>最佳实践</strong>部分，也可以看一些讲面向对象的教程。当然，也可以暂时先不管。）</p><p>不过我不会讲这里面的太多内容，这一节我的目标是讲清楚 <strong>SceneTree</strong> 的基本组织方式，至于其他的功能，感兴趣的话自己在上面提到的文档中查阅。</p><h3 id="节点树">节点树</h3><p><strong>SceneTree</strong> 管理的是节点（<strong>Node</strong>），组织节点的结构为树状结构。我相信你已经在 <em>Getting Start</em> 部分对于节点以及这样的树状结构的概念有了一定认识，接下来我们将会深入其实质。</p><h4 id="受管控的函数">受“管控”的函数：</h4><p>节点由树状进行组织，统一由 <strong>SceneTree</strong> 进行管理，以下是一些由 <strong>SceneTree</strong> 调用的属于节点的虚函数：</p><p>（虚函数是指函数内容默认为空，你有需要的话就往里面加东西，专业术语叫作 <strong>Override</strong>。）</p><ul><li><p><code>_process(delta)</code>：由 <strong>SceneTree</strong> 按照树的结构从上到下由外到内依次调用，调用频率与主循环 <strong><em>process</em></strong> 相同。</p><p>注：如果节点为暂停状态，则不会被调用，亦可手动用相关函数（<code>set_process(enable: bool)</code>）直接禁用 <code>_process()</code>。</p></li><li><p><code>_physics_process(delta)</code>：同理，只是对应的主循环为 <strong><em>physics_process</em></strong>。</p></li><li><p><code>_enter_tree()</code>：节点被加入 <strong><em>SceneTree</em></strong> 时调用。对于同时加入的情形，依照同样的从上到下由外到内的顺序。</p></li><li><p><code>_ready()</code>：优先级晚于 <code>_enter_tree()</code>，且顺序与之不相同。具体来说，整体上仍然按照从上到下的顺序，但是如果一个节点 A 有子节点，则首先“尝试”调用其子节点的 <code>_ready()</code>（这里说“尝试”是因为子节点可能也有子节点，这是一个递归过程），当节点 A 的全体子节点 <strong>ready</strong> 完毕后，再调用节点 A 的 <code>_ready()</code>。简单来说，这是从上到下但是由内到外的顺序。</p></li><li><p><code>_exit_tree()</code>：与 <code>_enter_tree()</code> 类似，节点被移出 <strong><em>SceneTree</em></strong> 时调用，但是顺序与 <code>_ready()</code> 同理。</p></li></ul><h4 id="enter_tree-还是-_ready">_enter_tree() 还是 _ready()？</h4><p>相信一些读者可以注意到，本小节标题提到的这两个函数似乎都是用作“初始化”的，考虑到它们被调用的顺序不同，用处也自然不相同。事实上很多情况下两者并无太大差别，它们可以做相同的事情，只是实现方式有所差别。</p><p>不过考虑到官方开发了一个 <code>onready</code> 语法糖（参考官方文档<strong>编程语言基础教程</strong>部分），我们往往都首选 <code>_ready()</code>。</p><p>此外，还有一个关于初始化的虚函数 <code>_init()</code>，刚才没提是因为这个函数不归 <strong>SceneTree</strong> 管。事实上，这个函数是 <strong>Class</strong> 的构造函数，它比 <code>_enter_tree()</code> 的优先级还要更早，可以简单理解为载入内存的时候就被调用了。需要注意的是，当一个节点的 <code>_init()</code> 被调用时，它的子节点甚至都还没被载入内存，因此你不可能在这里调用到一个节点的子节点。</p><h4 id="树函数">树函数</h4><p><strong>Godot</strong> 游戏运作的核心就是对节点树的操作，下面介绍一些常用的关于树的函数。</p><p>通用函数：</p><ul><li><p><code>get_node(path :NodePath)</code>：获取指定路径的节点，路径与文件路径相似，<strong>"."</strong> 代表 <strong>Node</strong> 本身，<strong>"root"</strong> 代表根节点。</p><p>举例：</p><ul><li><code>get_node(".")</code>：这是 <strong>Self</strong></li><li><code>get_node("..")</code>：这是父节点</li><li><code>get_node("root/Test")</code>：获取根节点名为 <strong>Test</strong> 的子节点</li><li><code>get_node("./Sprite")</code>：获取名为 <strong>Sprite</strong> 的子节点（可以省略<strong>“./”</strong>）</li></ul><p>注 1：如果 <strong>Script</strong> 的主语为 <strong>Node</strong>，则可使用语法糖 <code>$path</code> 代替 <code>get_node(path)</code>，如 <code>$Sprite</code>。</p><p>注 2：<strong>"xxx"</strong> 实际上为 <strong>String</strong>，严格的 <strong>NodePath</strong> 应该为 <strong>@"xxx"</strong>，只是这个函数会自动转换 <strong>String</strong> 为 <strong>NodePath</strong>。</p></li><li><p><code>is_instance_valid(object: Object)</code>：检查某个对象是否有效，往往用于检查某个变量所指向的节点是不是被删除了。</p></li></ul><p>关于<strong>父级</strong>的函数：</p><ul><li><code>get_parent()</code>：获取父节点，等价于<code>get_node("..")</code></li><li><code>get_tree()</code>：获取 <strong>SceneTree</strong> 对象</li></ul><p>关于<strong>子级</strong>的函数：</p><ul><li><code>get_child(index: int)</code>：获取第 <strong>index</strong> 个子节点（从 0 开始）</li><li><code>get_child_count()</code>：返回有多少个子节点</li><li><code>get_children()</code>：将全体子节点作为 <strong>Array</strong> 返回</li><li><code>add_child(node: Node, goodname = false)</code>：将 <strong>node</strong> 作为子节点加入，若 <strong>goodname</strong> 为 true，给这个 <strong>node</strong> 起一个人性化的名字而不是一些乱七八糟的字符（除非这个 <strong>node</strong> 本来就有名字）</li><li><code>move_child(node: Node, index: int)</code>：将指定的子节点移到第 <strong>index</strong> 个位置</li><li><code>remove_child(node :Node)</code>：将指定的子节点移除（这并不会删除该子节点）</li></ul><p>关于<strong>删除</strong>的函数：</p><ul><li><p><code>queue_free()</code>：将节点加入到<strong>“待删除队列”</strong>中，每帧结束的时候统一删除，这将把节点的子节点一并删除。</p><p>注：关于删除操作还有另一个函数 <code>free()</code>，这是 <strong>Object</strong> 意义上的基础删除，尽管可以立刻删除，但它作为 <strong>Object</strong> 基础功能并不会删除子节点，并且会带来很多问题（因为它并不是为 <strong>Node</strong> 量身定做的函数）。</p></li></ul><p>对于初学者来说，只记住 <code>queue_free()</code> 就行了，另一个函数可以当它不存在。但要记住<strong>“待删除队列”</strong>的概念，有时候你会很自然地认为一个节点删了之后，一些代码就不再会运作了，但实际上删除的时机是每一帧结束的时候，所以可能会跟你想的不太一样。</p><h3 id="场景节点scene">场景节点（Scene）</h3><p>关于 <strong>SceneTree</strong> 的另一个重要概念当然是 <strong>Scene</strong>。简单来说，<strong>Scene</strong> 就是你设计节点树的载体，<strong><em>Godot</em></strong> 引擎会要求你给 <strong>SceneTree</strong> 提供一个 <em>Main Scene</em>（或者你可以理解为 <em>First Scene</em>），然后在程序开始运行时，<em>Main Scene</em> 就会被加入 <strong>SceneTree</strong>。</p><h4 id="packedscene">PackedScene</h4><p>你在编辑界面编辑和保存的 <em>tscn/scn</em> 文件都属于 <strong>PackedScene</strong>，字面意义就是被“打包”的场景节点。<strong>PackedScene</strong> 属于资源，与图片资源、音频资源等类似，它并不是节点，但它可以变成节点：</p><p><strong>PackedScene</strong> 有一个 <code>instance()</code>函数，调用该函数将返回一个由该 <strong>PackedScene</strong> 打包好的节点，你可以将这个新节点加到 <em>Main Scene</em> 里面去（通过将其作为其中某些节点的 <strong>child</strong> 加入）。此外，你甚至可以将其作为根节点加入到另一个 <em>tscn</em> 文件中，相当于新建了一个继承场景。</p><p>此外，你也可以直接在 <strong>Scene</strong> 的编辑界面中加入 <strong>PackedScene</strong>，换句话说，你可以把 <strong>PackedScene</strong> 看作一个节点直接放到其他的节点树中。</p><p>（这应该是官方文档 <em>Getting Start</em> 部分介绍过的内容，只是没有提到这些具体概念，我相信你现在已经有了更好的理解）</p><h4 id="切换场景">切换场景</h4><p><strong>SceneTree</strong> 提供了切换 <em>Main Scene</em> 的函数 <code>change_scene_to(scene: PackedScene)</code>，这将允许你进行场景切换，但有时候我们也许不希望直接换掉 <em>Main Scene</em>（比如分屏类游戏），我们也可以选择手动删除既有节点以及从特定的 <strong>PackedScene</strong> 调用 <code>instance()</code> 并将返回的新节点加入到 <strong>SceneTree</strong> 中。</p><h2 id="结语">结语</h2><p>这一节的内容并不多，因为都是 <strong>Godot</strong> 程序的基础内容，理解这些内容能够更好地帮助你理解和使用 <strong>Godot</strong> 引擎。（当然，不理解也不影响使用，很多例子已经证明了这一点）</p><p>我编写这一节仅仅是因为官方文档没有在 <em>Tutorial</em> 栏目中专门讲解这些内容，而是将它们分散在 <strong>API</strong> 文档的各个板块，属实是给我个人自学带来了诸多不便。</p><p><strong>温馨提示 3</strong>：如果读到这里，你还没有阅读之前提到的官方文档中<strong>最佳实践</strong>的内容，那么强烈建议现在去看看。</p><h1 id="尾声">尾声</h1><p>距离我上一次更新这个网站都不知道过了多久了，不过我确实也一直懒得更新（</p><p>这篇文章主要是给我的一些朋友参考的，所以普适性可能不是那么强，但如果能帮到一些陌生人，我也会很开心的（</p><p>总之，欢迎留言评论（</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;（本文使用版本为 &lt;strong&gt;&lt;em&gt;Godot 3.5.x&lt;/em&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;首先说一个观点，我们自学 &lt;strong&gt;&lt;em&gt;Godot&lt;/em&gt;&lt;/strong&gt; 主要是看自己的需求（想学的一般
      
    
    </summary>
    
    
      <category term="教程" scheme="http://dasasdhba.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://dasasdhba.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【持续更新】Super Mario Ultra Edition Legacy</title>
    <link href="http://dasasdhba.github.io/res-UEL/"/>
    <id>http://dasasdhba.github.io/res-UEL/</id>
    <published>2022-01-20T03:40:00.000Z</published>
    <updated>2023-03-30T10:46:19.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p><strong>Super Mario Ultra Edition Legacy</strong> 是一个以全新思路重构的基于 <strong>Clickteam Fusion 2.5+</strong> 的 <em>Mario Forever</em> 制作模板。 <br>我们的目标并非还原原版，而是制作更舒适的 <strong>MF</strong>。我们这里有：</p><ul><li><strong>体系完备</strong>的分组系统</li><li><strong>完全精确</strong>的碰撞检测</li><li><strong>方便快捷</strong>的可扩展性</li><li><strong>不计其数</strong>的细节优化</li></ul><p>你可以：</p><ul><li><strong>肆无忌惮</strong>地摆放地形，<strong>不必担心穿墙问题</strong></li><li><strong>轻松迅速</strong>地开发新物件，<strong>将难搞的碰撞检测交由各分组</strong></li><li>充分利用 <strong>CTF2.5+</strong> 的特性，更方便地<strong>开发维护</strong></li></ul><h2 id="清晰的事件结构">清晰的事件结构</h2><p>与传统的 <strong>Mario Forever Remake Engine</strong> 以及当下流行的 <strong>Rainbow Engine</strong> 不同，该引擎的思路是 <strong>物理</strong> 与 <strong>对象</strong> 分开处理：<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CopLR.png"  /></p><p>为对象加入 <strong>Group.Instance</strong> 和 <strong>Group.Gravity</strong>，附加一个简单的 <strong>init</strong>（参考已有物件）即可获得重力，就是如此简单。</p><p>为充分发挥 <strong>CTF2.5+</strong> 的特性，引擎核心事件写入了两个对象：<img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CoPdx.png"  /></p><p><br>（右为 <strong>Frame End Event</strong>）<br>其中包括各类分组的事件，滚屏等核心内容。由于 <strong>物理</strong> 已经隔离开来，像 <strong>马里奥</strong> 一类的对象，便<strong>只需编写操作事件。</strong><br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0Coio6.png"  style="zoom:50%;" /></p><h2 id="强大的分组功能">强大的分组功能</h2><ul><li><p>你是否曾设想过 <strong>360°</strong> 的重力系统？<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CokFK.png"  style="zoom:50%;" /></p><p>真正的 <strong>"Mario Forever Galaxy"</strong> 已不再是梦想！！！<br>（当然，本引擎不会提供自动生成圆形重力场之类的功能，这类功能难以做成统一方便的模式，需要开发者自行解决。<br>同时，如果你需要变换重力方向，除了<strong>马里奥</strong>以外你都需要自行修改贴图，或者使用 <strong>Angle</strong> 方法进行动态的调整，<br>此类事件的技术细节仍然比较复杂，所以在短时间内，让 <strong>Mario Forever Galaxy</strong> 的编辑跟 <strong>RE</strong> 一样方便基本是不可能的。）</p></li><li><p>抛弃 <strong>Bouncing Ball</strong>，<strong>Group.Movable</strong> 更加强健<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CoEWD.png"  style="zoom:50%;" /></p><p>有碰撞检测的 <strong>Bouncing Ball</strong>，它不香吗.jpg</p></li><li><p>什么？<strong>啥都能放到运动实心上了</strong>？<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CoZSe.png"  style="zoom:50%;" /></p></li></ul><p>（好吧我承认性能上的消耗会大很多，但 <strong>directX 11</strong> 也给我们提供了更多的性能）</p><h2 id="稳固的游戏系统">稳固的游戏系统</h2><p>我们有<strong>完善的滚屏系统</strong>（后续有教程介绍）<br><strong>完善的暂停系统</strong>（当然，这同时也给开发带来了一些不便）<br>你甚至可以自己做自己的暂停系统。<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0Comyd.png"  /></p><h1 id="下载">下载</h1><p>注：</p><ol type="1"><li><p><strong>UEL Boss</strong> 为素材库性质，尽量避免直接用其进行关卡制作。</p></li><li><p><strong>UER</strong> 为一个分支版本，其手感更接近原版 <em>Mario Forever</em>。</p></li><li><p>使用了 <strong>F-ini</strong> 插件，详见：<a href="https://www.marioforever.net/thread-1589-1-1.html" target="_blank" rel="noopener" class="uri">https://www.marioforever.net/thread-1589-1-1.html</a></p></li></ol><p>更新日志可参考 <a href="https://www.marioforever.net/thread-705-1-1.html" target="_blank" rel="noopener">MF 论坛</a>，或直接下载源文件于 <strong>Frame Event Editor</strong> 查看。</p><p>永硕：<a href="http://dasasdhba.ys168.com/" target="_blank" rel="noopener" class="uri">http://dasasdhba.ys168.com/</a><br>蓝奏：<a href="https://wwi.lanzoui.com/b02bgtrub" target="_blank" rel="noopener" class="uri">https://wwi.lanzoui.com/b02bgtrub</a><br></p><p>后续将会不断提供稳定性更新，功能性更新可能会以 <strong>Mod</strong> 的形式放出。</p><h1 id="教程">教程</h1><p>详见：<a href="https://dasasdhba.github.io/course-UELManual" class="uri">https://dasasdhba.github.io/course-UELManual</a></p><h1 id="特别鸣谢">特别鸣谢</h1><ol type="1"><li>感谢 <strong><span class="citation" data-cites="虹原翼">@虹原翼</span></strong> 的 <strong>Rainbow Engine</strong> 为本引擎提供了大量素材和源代码参考。</li><li>感谢 <strong><span class="citation" data-cites="2333ty">@2333ty</span></strong> 在开发之初为部分移植工作作出的贡献。</li><li>感谢 <strong><span class="citation" data-cites="s小s飞s侠s">@s小s飞s侠s</span></strong> 在测试阶段积极做关寻找问题。</li><li>感谢 <strong><span class="citation" data-cites="koopa4">@koopa4</span></strong> <strong><span class="citation" data-cites="马里奥x7">@马里奥x7</span></strong> 为部分事件提供最初的灵感来源。</li><li>感谢 <strong><span class="citation" data-cites="数字1528君">@数字1528君</span></strong> <strong><span class="citation" data-cites="色粉堵塞">@色粉堵塞</span></strong> 积极反馈 bug。</li><li>感谢 <strong><span class="citation" data-cites="大爷23大买卖吗">@大爷23大买卖吗</span></strong> 为本引擎提供的建议。</li></ol><p>最后，欢迎评论，有 bug 欢迎指出，在这里和论坛都可以（</p><p>论坛链接：<a href="https://www.marioforever.net/thread-705-1-1.html" target="_blank" rel="noopener" class="uri">https://www.marioforever.net/thread-705-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Super Mario Ultra Edition Legacy&lt;/strong&gt; 是一个以全新思路重构的基于 &lt;strong&gt;Clickteam Fusion 2.5+&lt;/strong&gt; 的 &lt;em&gt;Mario F
      
    
    </summary>
    
    
      <category term="资源" scheme="http://dasasdhba.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="资源" scheme="http://dasasdhba.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Ultra Edition Legacy 开发文档</title>
    <link href="http://dasasdhba.github.io/tutorial-UELManual/"/>
    <id>http://dasasdhba.github.io/tutorial-UELManual/</id>
    <published>2021-08-07T12:00:00.000Z</published>
    <updated>2023-03-30T10:36:53.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编辑手册">编辑手册</h1><p>介绍 <strong>Super Mario Ultra Edition Legacy</strong>（<strong>210807.1ver</strong> 及以后版本，后简称 <strong>UEL</strong>） 的编辑注意事项以及各种物件的使用方法。</p><h2 id="编辑须知">编辑须知</h2><p>这是在使用 <strong>UEL</strong> 时特别需要注意的一些地方，请一定要仔细阅读！！！</p><ol type="1"><li><strong>不要随意删改已有的图层及其名称</strong><br>否则将会导致各种问题的出现！！！</li><li><strong>level_main</strong> 为关卡主图层，<strong>level_back</strong> 为第一背景层<br><strong>食人花</strong>，<strong>进水管的马里奥</strong>等将会被移至第一背景层<br>因此做背景时请<strong>特别注意遮挡问题</strong>的出现<br>当然，你可以随意添加新的图层，放在第一背景层之后，这是万无一失的做法。</li><li>不要删除 <strong>Frame Start Event</strong> 和 <strong>Frame End Event</strong> 对象，否则事件顺序会被永久打乱！</li><li>在同一工程中，建议<strong>保持各个物件的名称相同</strong>，以方便未来维护<br>（若有<strong>重大 bug 修复</strong>，你到时候才能用 <strong>Global Object</strong> 进行全局修改）</li><li>由于 <strong>UEL</strong> 物理系统的精确性，<strong><del>辣鸡</del> CTF</strong> 不能单独设置对象的碰撞遮罩，请尽量保证动画尺寸的一致性！<br>如不容易解决，可尝试使用 <strong>Bouncing</strong> 动画碰撞遮罩，或 给物件添加 <strong>Group.AutoPlace</strong>。</li></ol><h2 id="程序设置">程序设置</h2><p>建议直接使用 <strong>UEL</strong> 默认程序设置，如果需要转移到其他程序，请注意以下两点：</p><ol type="1"><li><p>事件顺序：</p><p><strong>UEL</strong> 修改了程序默认事件顺序，这非常重要。</p><p><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CoMwt.png"  /></p></li><li><p>全局事件： <strong>UEL</strong> 全局事件与内置暂停（现默认关闭）有关。 <img src="/" class="lazyload" data-src="https://files.catbox.moe/91xvsa.png"  /> <em>frame_end</em> loop 非常重要，缺失该 loop 会出现很多问题。</p></li></ol><h2 id="图层介绍">图层介绍</h2><ol type="1"><li><strong>sys_setting</strong>：用于存放核心事件相关的对象。你可以<strong>启用该图层可视性</strong>并将其作为背景图层使用，但一般不推荐这么做。</li><li><strong>level_back</strong>：马里奥进出水管，食人花，升起的道具，部分背景等处于此图层。因此你需要注意在 <strong>level_main</strong> 中不要有物件遮挡了该图层，你可以将滚屏范围置于此图层。</li><li><strong>level_main</strong>：关卡运行的核心图层。</li><li><strong>level_info</strong>：存放 <strong>HUD</strong> 的图层。</li><li><strong>level_circle</strong>：圈圈转场特效的图层。</li><li><strong>sys_pause</strong>：内置暂停的预留图层（现默认关闭）。</li><li><strong>sys_overlap</strong>：用于物理引擎处理碰撞检测的临时图层。请不要编辑此图层。</li></ol><h2 id="部分物件说明">部分物件说明</h2><h3 id="系统">系统</h3><ol type="1"><li><p>在图层 <strong>level_info</strong> 的 <strong>Info Time</strong> 对象中设置时间：<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0Co3Y8.png"  /></p><p>若设置为 <strong>≤0</strong>，则不限时</p></li><li><p><strong>通关器</strong> 和 <strong>小通关器</strong> 的相对位置决定其方向，可放心摆放。</p></li><li><p><strong>滚屏</strong> 的使用：<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0Co8fS.png"  /><br>当 <strong>马里奥</strong> 与 <strong>Scroll Free/Scroll Set</strong> 碰撞时，将会切换滚屏；<br><strong>Scroll Set</strong> 拥有变量 <strong>ID</strong>，马里奥触发滚屏时，滚屏将会切换到拥有同样 <strong>ID</strong> 的 <strong>Scroll Region</strong> 对象中，<br><strong>该对象的覆盖范围即为滚屏的范围。</strong><br>如果 <strong>Scroll Set</strong> 的 <strong>渐变 Flag</strong> 打开，则会渐变式切换滚屏。<br>因此，当你需要制作不同区域的滚屏时，克隆 <strong>Scroll Set</strong> 和 <strong>Scroll Region</strong> 对象，修改 <strong>ID</strong> 使其对应即可。<br>新版滚屏追加<strong>视野调整</strong>功能，开启之后将会根据目标（默认为马里奥）的运动调整滚屏的视野。</p><p>使用样例（<strong>SMMWW 2-2</strong>）：<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CoJSg.png"  /></p></li></ol><h3 id="敌人">敌人</h3><p>你可以轻松地指定一个敌人的<strong>初始方向</strong>，如图：<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0Cotyj.png"  /><br></p><p>部分敌人支持 <strong>32 个方向</strong>，包括：</p><ul><li>食人花：你应该 <strong>Clone</strong> 食人花并修改其方向，以此获得其他方向的食人花。<br>如有需要，你可以修改 <strong>Clone</strong> 后的食人花的编辑界面贴图，以方便编辑。</li><li>火球：不作过多解释，但需要说明的是，火球会<strong>记忆其初始距离岩浆的高度</strong>，<br>如果没有岩浆，那火球也回不来了。</li><li>石盾：也不需要太多解释，但需要注意的是，<br>以一个比较奇怪的方向砸到<strong>与其不垂直的实心</strong>上可能导致<strong>爆炸特效</strong>创建失败。</li></ul><p>此外，<strong>炮台</strong>也支持 <strong>4 个方向</strong>。</p><h3 id="道具">道具</h3><p>将 <strong>道具</strong> 覆盖于 <strong>问号砖/砖块</strong> 上，以装入此道具：<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0Coamn.png"  /></p><p>注意，<strong>道具</strong> 在升起的过程中也位于 <strong>level_back</strong> 图层。</p><h3 id="水管链接">水管链接</h3><p><strong>红绿箭头对象</strong>只拥有动画效果。<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CowT0.png"  /></p><p>特别地，在一开始将马里奥与<strong>红色箭头</strong>重叠可以使其在一开始的时候出水管。<br>而后，我们需要其他的对象来完成水管的传送，跳帧等事件：</p><ol type="1"><li>传送：<br><strong>红绿 Warp 对象</strong> 根据其摆放的顺序进行瞬移式传送。<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CoBkV.png"  /></li><li>滚屏：<br><strong>紫色 Warp 对象</strong> 将会开启滚屏式传送，通过<strong>黄色箭头</strong>更改滚屏的方向。<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CoypF.png"  /></li></ol><h3 id="运动实心">运动实心</h3><ol type="1"><li>修改实心类型：<br>对于平台和实心的转换，修改分组即可：<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0Coc6J.png"  /><br>你还可以修改变量 <strong>实心类型</strong>：<br>0：正常实心<br>1：马里奥实心<br>2：敌人实心</li><li><strong>Reverse</strong> 的使用：<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CoRmR.png"  /><br>运动实心正常情况下为 <strong>Normal</strong> （后简称 <strong>N</strong>）状态，与其边缘接触后将会进入 <strong>Reverse</strong> （后简称 <strong>R</strong>）状态；<br>同样，处于 <strong>R</strong> 状态的运动实心与其接触后会切回 <strong>N</strong> 状态。<br>而后在特定的设置下会进行相应的速度反向。<br>当运动实心同时具有 <strong>x、y速度</strong> 时，<strong>Reverse</strong> 对象的 <strong>单方向碰撞 Flag</strong> 将决定反向一个方向的速度还是两个。</li><li>箭头的使用：<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CoW01.png"  /><br>当运动实心只在单方向拥有速度的时候可以响应运动箭头，其响应的位置在<strong>箭头的中心</strong>。<br>若运动实心处于 <strong>N</strong> 状态，则响应<strong>绿色箭头</strong>；<br>若运动实心处于 <strong>R</strong> 状态，则响应<strong>红色箭头</strong>；<br>以此我们就可以制作复杂路径的往返。</li><li>需要注意的是，在某些情况下，<strong>最后一个摆放的运动实心可能会出现问题</strong>（原因不明），此时你最后在屏外摆一个运动实心即可。</li></ol><h1 id="开发手册">开发手册</h1><p>介绍 <strong>UEL</strong> 开发的注意事项和使用参考。</p><h2 id="分组介绍">分组介绍</h2><p>介绍主要分组的功能。</p><h3 id="group.instance-介绍">Group.Instance 介绍</h3><p>本引擎物理核心分组，<strong>Group.Gravity</strong> 与 <strong>Group.Movable</strong> 均依赖于此组。</p><h4 id="变量坐标">变量坐标</h4><p>本条目对 <strong>Group.MovingBlock</strong> 也适用。</p><p>由于 <strong>CTF</strong> 的物件坐标只支持整数，属于本组的物件均采用 <strong>Alterable Value X</strong> 与 <strong>Alterable Value Y</strong> （后简称 <strong>变量 X</strong> <strong>变量 Y</strong>）作为<strong>坐标</strong>进行运算，具体流程如下： 1. 帧开始时或创建对象时将物件的坐标 <strong>X Y</strong> 写入 <strong>变量 X Y</strong>； 2. 通过 <strong>变量 X Y</strong> 对物理过程进行相关计算； 3. 将物件的坐标 <strong>X Y</strong> 设置为 <strong>变量 X Y</strong>。</p><p>若你开发的物件属于此组，且你需要直接修改物件坐标，请参照上述流程的 <strong>2 3</strong> 完成。<br>你亦可直接修改物件的坐标 <strong>X Y</strong>，并在最后将物件的 <strong>变量 X Y</strong> 修改为坐标 <strong>X Y</strong>。</p><h4 id="功能介绍">功能介绍</h4><p>以下内容摘编自 <strong>UEL Group.Instance 注释</strong>： 使用变量：1000~1099 1000 = -1: 禁用该对象所有相关事件 = 0: 初始化，完成后赋值为 1 = 2: 恢复，完成后赋值为 1 需要注意的是，在编写物件行为的时候也应注意加上这个条件 <em>（现内置暂停默认禁用，确定不使用内置暂停可以不管）</em></p><p>1001 = 1: 下一帧即销毁（模拟绘制功能） 你可以创建一个 Instance，并将其变量 1001 赋值为 1，这样它在下一帧就会被销毁，从而达到“绘制”的目的； 但如果需要用的话，一定要节约！！！ <em>（目前没有物件使用该功能）</em></p><p>1002 = -1: 不进行碰撞检测（对 Group.Gravity, Movable 等均适用） = 0: 正常碰撞检测 = 1: 马里奥实心 = 2: 敌人实心 <em>（事实上你可以添加更多的编号，只要 Group.Solid &amp; Platform 的 <strong>变量 900</strong> 与之匹配即可）</em></p><p>1003 = 0: 不禁用 = 1: 出屏禁用 = 2: 禁用直到入屏</p><p>1004 = 1: 被运动实心挤</p><p>1005 = 1: 调整图层至 level_back <em>（物件会在每一帧最开始被调至 <strong>level_main</strong>，每一帧最后被调至 <strong>level_back</strong>）</em></p><p>1011 = 1: 对象属于 Group.Gravity 1012 = 1: 对象属于 Group.Movable 1013 = 1: 对象属于 Group.MovingBlock 1014 = 1: 对象属于 Group.Enemy = 2: 对象属于 Group.Shell = 3: 对象属于 Group.HardShell 1019 = 1: 对象属于 Group.Solid = 2: 对象属于 Group.Platform</p><p>2000 &amp; 2001 &amp; 2002: 用于内置暂停</p><p>Bouncing 动画碰撞箱 物件将会以 <strong>Bouncing</strong> 动画作为碰撞箱，同时其动画必须手动设置。 3000 = 1: 开启 3001: 动画切换间隔 3002: 动画帧数 3003: 当前动画序列 3004: 当前动画帧</p><h4 id="使用-instance_place_fix">使用 instance_place_fix</h4><p>instance_place_fix：陷入实心补正 -Argument: --1098: 需要检测的实心类型（参见实心说明） --1097 = 1: 无视 Backdrop &amp; Group.Solid --1096 = 1: 无视 Group.Platform --1095: 方向（角度制） --1094: 最大深度 --1093 = 1: 禁用最大深度 -Return: --1099 = 1: 执行成功 = 0: 未执行（超过最大深度）</p><p>使用样例： <img src="/" class="lazyload" data-src="https://files.catbox.moe/9m4w1r.png"  /></p><h3 id="group.gravity-介绍">Group.Gravity 介绍</h3><p>基于 <strong>Group.Instance</strong> 的重力事件组。</p><h4 id="功能介绍-1">功能介绍</h4><p>以下内容摘编自 <strong>UEL Group.Gravity 注释</strong>： 使用变量 100~199</p><p>100 = -1: 禁用 = 0: 在地面上 = 1: 在空中</p><p>101：速度 102：重力方向（角度制） 103：空中加速度 104：空中减速度 105：水中加速度 106：水中减速度 107：空中最大速度（=0为无限制，&lt;0为上浮） 108：水中最大速度（=0为无限制，&lt;0为上浮） （以上参数将会默认初始化为<strong>普通敌人</strong>的配置）</p><p>109= 0: 应用加速度</p><p>180: 坦克滚屏相关</p><h4 id="foreach-介绍">Foreach 介绍</h4><p>物件着地瞬间将会执行 <strong>Foreach</strong>：<em>gravity_down_finished</em> 物件顶头瞬间将会执行 <strong>Foreach</strong>：<em>gravity_up_finished</em></p><p>使用样例： <img src="/" class="lazyload" data-src="https://files.catbox.moe/hon73d.png"  /></p><h3 id="group.movable-介绍">Group.Movable 介绍</h3><p>基于 <strong>Group.Instance</strong> 的直线运动事件组。</p><h4 id="功能介绍-2">功能介绍</h4><p>以下内容摘编自 <strong>UEL Group.Movable 注释</strong>： 使用变量 200~299</p><p>200=-1: 禁用</p><p>201：速度 202：移动方向（角度制）</p><p>203：碰撞行为 =-1：什么都不发生 = 0：停止，速度（201）归 0 = 1：反向（方向角+180） = 2：返回 204 = 1，后续处理交由物件</p><p>205：斜坡容错</p><h4 id="foreach-介绍-1">Foreach 介绍</h4><p>物件碰撞瞬间将会执行 <strong>Foreach</strong>：<em>movable_place_finished</em></p><h3 id="group.enemy-介绍">Group.Enemy 介绍</h3><p>用于处理龟壳/无敌星刷分，以及部分部分攻击判定的事件组。 以下内容摘自 <strong>UEL Group.Enemy 注释</strong>：</p><p>400 = 0: 正常 =1: 死亡</p><p>401 = -2: 不与龟壳和无敌星进行判定 =-1: 不与龟壳进行判定 = 0: 能被普通龟壳砸死 = 1: 能反死普通龟壳但能被硬壳砸死</p><p>402 = 0: 能被岩浆搞死 404 = 0: 出界销毁 405 = 0: 能被挤死 406 = 0: 能被顶死（有重力且在地面上时）</p><p>403=1: 位于 level_back 图层的调整</p><p>420: 砸砖块记录</p><h3 id="group.block-介绍">Group.Block 介绍</h3><p>以下内容摘自 <strong>Block</strong> 注释： Flag 9 on: 开启隐藏 Flag 10 on: 添加实心 Flag 11 on: 顶 Flag 12 on: 控制顶的动画 Flag 13 on: 金砖计时 Flag 14 on: 金砖控制 Flag 15 on: 属于 Brick</p><p>对于 <strong>Instance 组</strong>对象，添加砸砖事件可参考甜菜。 对于其他对象，在 <strong>overlapping</strong> 到 <strong>Group.Block</strong> 时打开其 Flag 11 并关闭 Flag 9 即可。</p><h2 id="物理实现方法">物理实现方法</h2><h3 id="马里奥">马里奥</h3><p>移动：在操作事件执行完成之后，马里奥会将<strong>速度</strong>和<strong>运动方向</strong>分别写入<strong>变量 201 202</strong>。 跳跃：直接利用<strong>变量 100 101</strong> 进行相关计算。 需要注意的是，马里奥的方向为<strong>变量 AS</strong>，-1 为左，1 为右（相对于重力向下时）。 马里奥的速度是用<strong>变量 AT</strong> 计算的。 与水管直接相关的是<strong>变量 AP</strong>，与受伤/无敌直接相关的是<strong>变量 AH</strong>。 具体内容可在 <em>Mario</em> 对象中寻找相关注释。</p><h3 id="一般敌人">一般敌人</h3><p>属于 <strong>Group.Instance</strong> 的一般敌人会在 <strong>init</strong> 时对重力进行默认配置，并将<strong>速度</strong>和<strong>运动方向</strong>分别写入<strong>变量 201 202</strong>。 需要注意的是， <strong>Group.Instance</strong> 对象才会调用 <strong>Foreach init</strong> 进行 init 操作，不属于此组的敌人一般属于不需要进行碰撞检测的，这类敌人你可能会在行为中看到 <strong>gravity</strong>、<strong>movable</strong>，这些行为属于没有碰撞检测的物理过程。而对于这类敌人，你可以这样进行 init： <img src="/" class="lazyload" data-src="https://files.catbox.moe/capny3.png"  /> 这些对象为什么不可以加入 <strong>Group.Instance</strong> 并将<strong>变量 1002</strong> 设为 -1？ 因为在目前主流的 CTF2.5+ 版本中，有着分组溢出的 bug，这是规避此 bug 的无奈之举。</p><h3 id="运动实心group.movingblock">运动实心（Group.MovingBlock）</h3><p>运动实心会在每一帧的<strong>开始</strong>和<strong>结束</strong>记录其当前的坐标，并以这个坐标为依据去修正其他与之接触的对象。 其原生运动系统详见 <strong>Frame End Event</strong> 中的注释。</p><h3 id="bouncing-动画指定碰撞遮罩">Bouncing 动画指定碰撞遮罩</h3><p>使用 <strong>Bouncing</strong> 动画作为碰撞遮罩以规避物件动画尺寸不规整带来的问题。 目前使用该功能的物件包括：锤子龟系列，刺球。</p><h3 id="group.autoplace">Group.AutoPlace</h3><p>处理极端情况的极端策略，如果实在没办法再考虑使用。 该分组的对象会在每一帧的最后检测是否与实心重叠，如果重叠，则从上下左右四个方向选取最短的一个方向执行防陷入。</p><h2 id="滚屏实现方法">滚屏实现方法</h2><p>滚屏核心事件位于对象 <strong>Camera</strong> 中，以下内容摘自其注释： 1.设置滚屏跟随对象 滚屏模式 = 0：初始化并启动模式 1 = 1：将滚屏目标设置为 "Mario" = 其他：你需要手动设置目标 X Y 坐标和滚屏补正速度 （滚屏补正速度用于滚屏渐变的参数，否则可能会出现滚屏渐变追不上滚屏目标的问题）</p><p>2.设置晃屏功能 你需要打开 "晃屏" Flag，并设置变量 "晃屏时间" 晃屏时间&gt;0：不允许晃屏超过当前的滚屏边界 晃屏时间&lt;0：允许晃屏超过当前的滚屏边界</p><p>3.禁用滚屏系统 你可以打开 "禁用" Flag，也可以直接删除 Camera 的 Behavior 如果只需要禁用封位实心，打开 "禁用封位实心" Flag 即可</p><h2 id="内置暂停实现方法">内置暂停实现方法</h2><p>该功能现默认关闭，如果不需要可以略过以下内容。</p><p>对于 <strong>Group.Instance</strong> 对象，<strong>变量 1000</strong>，直接控制物件是否暂停，包括其动画和 CTF 自带运动。 对于非 <strong>Group.Instance</strong> 对象，<strong>Pause</strong> 对象的 Flag 0（命名为 <em>Pause</em>）直接控制物件是否暂停，但不包括其动画和 CTF 自带运动，对于后者的暂停请参考其他相关物件的 <strong>Pause</strong> 行为。</p><p>如果你需要使用内置暂停功能，在开发时必须要注意添加<strong>暂停条件的限制</strong>。</p><h2 id="全局变量实现方法">全局变量实现方法</h2><p>全局变量实际上是 <strong>Frame Start Event</strong> 和 <strong>Frame End Event</strong> 的变量。 由于 CTF 的 bug，<em>Restart current frame</em> 会重置全局物件的变量，且此动作不会被判定为 <em>Frame End</em>，因此所有变量将会在<strong>帧开始时，帧结束时/Foreach: frame_restart</strong> 时<strong>读取</strong>/<strong>存入</strong>全局变量。 据此原理，<strong>UEL</strong> 理论上可以兼容任意其他工程的全局变量，参考：</p><ol type="1"><li><p>在 <strong>Frame Start Event</strong> 中，激活/禁用相关事件<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CoKeI.png"  /></p></li><li><p>将 <strong>Global Event</strong> 复制至移植目标工程</p></li><li><p>修改工程设置，如图：<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/09/25/0CoMwt.png"  /><br>将 <strong>Event Order</strong> 调整为<strong>"Frame events, Behaviors, Global events"</strong></p></li></ol><p>你亦可将 <em>Restart current frame</em> 改为 <em>jump to frame frame</em>，如果没有移植至其他工程的需求，就不需要在<strong>帧开始时，帧结束时/Foreach: frame_restart</strong> 时<strong>读取</strong>/<strong>存入</strong>全局变量。</p><h2 id="致开发者">致开发者</h2><ol type="1"><li>如果需要使用内置暂停功能，开发过程中请特别注意 <strong>暂停条件</strong> 的限制，其中<br>对于 <strong>Group.Instance</strong> 对象，暂停条件应为 <strong>Var.1000 = -1</strong><br>对于其他对象，暂停条件应为 <strong>Pause 对象的 Flag 0 on</strong>。</li><li>我在开发过程中，对于一些重要的东西都写了较为详细的注释，可供参考。<br>而对于一些外源引用的事件（均注明来源）则并没有作太多的处理。</li><li>你可能会注意到，有一些物件并不属于 <strong>Group.Instance</strong>，<br>理论上我们把所有物件都加上此组，那么就根本不需要 <strong>Pause</strong> 对象了。<br>你可能也已经发现，部分物件的行为中有 <strong>“低配版”</strong> <strong>Gravity</strong> 和 <strong>Movable</strong>。<br>其原因在于，<strong>CTF</strong> 对于分组的使用<strong>有上限！！！</strong><br>这个上限具体我并不清楚，但这个上限是存在的，<br>如果超过，将会导致 <strong>Out of memory</strong>，<strong>编译直接崩溃！</strong><br><del><strong>别问我怎么知道的，辣鸡 Clickteam</strong></del><br>因此，对于不需要碰撞检测的对象，用<strong>"低配版"</strong>是更好的选择。<br></li><li><strong>Group.MovingBlock</strong> 绝对不能同时与 <strong>Group.Instance/Gravity</strong> 等加在同一个对象上，<br>原因可参见 <strong>Group.Solid&amp;Platform</strong> 的注释。<br>如果需要开发其他运动方式的平台（如圆周运动），<br>直接禁用掉原生运动事件（比如将 <strong>Var.300</strong> 设为 233），然后自行在 <strong>Behavior</strong> 中编写即可。<br>这不会影响补正事件，因为补正事件用的是差值法计算。<br></li><li>我深知我使用的一些 <strong>Foreach</strong> 事件存在风险，<br>比如我迫不得已修改全局事件顺序来保证 <strong>Frame End Event</strong> 的正常运行（已改为 loop），<br>如果你实在担心，也可以自己改一改。</li></ol><h1 id="尾声">尾声</h1><p>UEL 介绍&amp;下载地址：<a href="https://dasasdhba.github.io/res-UEL" class="uri">https://dasasdhba.github.io/res-UEL</a> 论坛地址：<a href="https://www.marioforever.net/thread-705-1-1.html" target="_blank" rel="noopener" class="uri">https://www.marioforever.net/thread-705-1-1.html</a></p><p>欢迎评论~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编辑手册&quot;&gt;编辑手册&lt;/h1&gt;
&lt;p&gt;介绍 &lt;strong&gt;Super Mario Ultra Edition Legacy&lt;/strong&gt;（&lt;strong&gt;210807.1ver&lt;/strong&gt; 及以后版本，后简称 &lt;strong&gt;UEL&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="教程" scheme="http://dasasdhba.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://dasasdhba.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【四年之约】MRI2 Chapter5 Rainbow Treasure</title>
    <link href="http://dasasdhba.github.io/game-MRI2C5/"/>
    <id>http://dasasdhba.github.io/game-MRI2C5/</id>
    <published>2021-07-25T06:00:00.000Z</published>
    <updated>2023-03-30T10:38:32.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysterious-island-2-chapter-5-rainbow-treasure">Mysterious Island 2 Chapter 5: Rainbow Treasure</h1><h2 id="年4月15日晚">2017年4月15日晚</h2><p>“这关我做了一半实在是没有灵感了。”w11 带着完成了一半的 MRI2 5-1，对 das 如是说道。 “我在开发新引擎，挺有意思的。”das 一边调试冰花一边回复道。 “怎么办？我现在学习也挺忙的，对 MF 越来越没兴趣了。”w11 叹息道，“但 MRI2 C5 总得要给大家一个交代啊……” “那咋办，总不可能我来做吧？”das 笑着说道，继续考虑 Neverland Engine 的冰块 bug 怎么修。 “你去年 MW 杯关卡风格跟我挺接近的，你来做说不定还真行呢。”w11 说道，“我现在得全心投入到数竞，真的没办法搞 MF 了。” “行吧，我先试试能不能续一下这个 5-1。”……</p><h2 id="年8月23日下午">2017年8月23日下午</h2><p>“5-1 到 5-4 基本完成了，你来改改？” das 对 w11 说道。 “嗯嗯，我作修改还是没问题的。”w11 回复道。 “5-5 和 5-6 我有一些比较好的想法，5-7 我不太有思路，要不你做一下 5-7？” das 对 w11 说道。 “紫色，嗯……我可以做个九宫格？”w11 略加思考后说道。 “那就这么定了。”……</p><h2 id="年1月6日晚">2018年1月6日晚</h2><p>“5-6 做完啦！现在就等你 5-7 啦。”das 高兴地对 w11 说道。 “我还没开工呢，我先抽时间看一下这两关。”w11 回复道，“你们中考复习不忙吗？” “中考啊，我不太想复习（（”das 笑着说道。 “我现在也是越来越没时间了，明年我就高考了，5-7 等我高考完之后吧。”w11 说道。 “行吧”……</p><h2 id="年7月9日下午">2019年7月9日下午</h2><p>”啊啊啊啊啊啊啊啊我做一半又没灵感了。”w11 沮丧着说道。 “那就先不做嘛，我们可以先筹划一下前四世界的修改工作。”das 建议道。 “我想先改一下 Bowser Tower，分成三个难度。”w11 说道。 “等等，难道你想做 75 个 frame？其实可以合并。”……</p><h2 id="年7月14日下午">2019年7月14日下午</h2><p>“上午发的 MRI2 宣传视频反响还不错。”w11 说道。 “不错是不错，你咕了怎么办（”das 笑道。 “诶诶诶，你怎么也发了个宣传视频？”w11 问道。 “害，我放弃 NE 用自己从零写的引擎来做新作了。”das 回复道。 “哇！我能测试吗？”……</p><h2 id="年1月24日晚">2020年1月24日晚</h2><p>“看来你还是咕了。”das 对 w11 说道。 “我打算明天发个单关测试，意思一下（”w11 无奈地说道。 “害，我这几天也得狂赶新作进度了。”……</p><h2 id="年8月26日上午">2020年8月26日上午</h2><p>“这是目前 5-1 到 5-6 的整合版。”das 对 w11 说道，“我马上就正式高三了，你能在我高考前发布吗？（” “我尽量。”w11 回复道。 “说起来我最近又在写一个新引擎，打算再开一个作品来宣传这个引擎。”das 说道。 “你高三还有时间？”w11 问道。 “可以合作嘛。”……</p><h2 id="年2月11日晚">2021年2月11日晚</h2><p>“我新作发了，你进度还是零吗（”das 笑着问道。 “现在真的越来越没兴趣了……”w11 叹息道。 “害，我接下来到高考前也没啥时间了。”…</p><h2 id="年7月6日上午">2021年7月6日上午</h2><p>“我来把 5-7 做完得了。”das 计划着……</p><h2 id="年7月22日晚">2021年7月22日晚</h2><p>“唉，我现在也越来越没兴趣了……”das 想着，“这个样子 MRI2 2.0 肯定是做不完了，要不单独发个 C5 版本？”……</p><h2 id="年7月25日">2021年7月25日</h2><p>作品名：<em>Mysterious Island 2 Chapter 5: Rainbow Treasure</em> 作品规模：7+1 关 制作耗时：见上文 主要关卡作者：dasasdhba 修改工作：dasasdhba、w1194600239 其他杂项：详见游戏内 Credits</p><p>作品截图： <img src="/" class="lazyload" data-src="https://ftp.bmp.ovh/imgs/2021/07/696f55e5454e911e.png"  /> <img src="/" class="lazyload" data-src="https://ftp.bmp.ovh/imgs/2021/07/f88f0b75aff34376.png"  /> <img src="/" class="lazyload" data-src="https://ftp.bmp.ovh/imgs/2021/07/6b61917bded0a00a.png"  /> <img src="/" class="lazyload" data-src="https://ftp.bmp.ovh/imgs/2021/07/49f1990f776235b9.png"  /> <img src="/" class="lazyload" data-src="https://ftp.bmp.ovh/imgs/2021/07/202d65a1150bf603.png"  /> <img src="/" class="lazyload" data-src="https://ftp.bmp.ovh/imgs/2021/07/3e7411004194a776.png"  /></p><p>注意事项：</p><ol type="1"><li>手感基于 RE 作了一定优化</li><li>天黑了，金币商店打烊了</li><li>Bowser Tower 新增三个难度分级，欢迎挑战</li><li>没有其他内容了</li></ol><p>下载地址(v2)：<a href="https://wwi.lanzoui.com/igfVAru41tg" target="_blank" rel="noopener" class="uri">https://wwi.lanzoui.com/igfVAru41tg</a></p><ol type="1"><li>修复了红色关卡某食人花由于不明原因概率错位的 bug</li><li>修复了进入最终关卡时间能带到其他关卡的 bug</li></ol><p>论坛地址：<a href="https://www.marioforever.net/thread-1323-1-1.html" target="_blank" rel="noopener" class="uri">https://www.marioforever.net/thread-1323-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mysterious-island-2-chapter-5-rainbow-treasure&quot;&gt;Mysterious Island 2 Chapter 5: Rainbow Treasure&lt;/h1&gt;
&lt;h2 id=&quot;年4月15日晚&quot;&gt;2017年4月15日晚&lt;/
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://dasasdhba.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="游戏" scheme="http://dasasdhba.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="资源" scheme="http://dasasdhba.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>【游戏】Mario Forever Euphoria</title>
    <link href="http://dasasdhba.github.io/game-MFE/"/>
    <id>http://dasasdhba.github.io/game-MFE/</id>
    <published>2021-02-27T15:33:33.000Z</published>
    <updated>2023-03-30T10:39:29.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mario-forever-euphoria">Mario Forever Euphoria</h1><p><strong>Ultra Team</strong> 合作作品。</p><h2 id="its-not-mf-enough-but-does-it-matter">It's not ''MF'' enough, but <strong><font color=red>DOES IT MATTER?</font></strong></h2><p>不喜欢硬核关卡，认为硬核关卡不符合时代？<br>不喜欢硬核关卡，认为马里奥关卡不适合做硬核？<br>喜欢硬核关卡，但觉得MF作品的操作手感不精确？<br>喜欢硬核关卡，但无法接受很多作品的高死亡代价？</p><p>无论你是哪一种情况，我们都相信，这部全新的作品：<strong>Mario Forever Euphoria</strong>，会给你一个非同寻常的体验！！</p><h2 id="作品介绍">作品介绍</h2><p><strong>Mario Forever Euphoria</strong> 是 <strong>Ultra Team</strong> 推出的合作作品。整体难度很高，但是一次全新的尝试。</p><p>一方面，众所周知，原版MF和永吧最流行的引擎——<strong>RE</strong> 的碰撞判定是不够精确的，但本作品在原有参数的基础下，将参数和碰撞判定精确化。另一方面，永吧大多数硬核关卡都是传统的马里奥式关卡，<strong>但本作大大降低了关卡的失败成本，而关卡设计也是毫不忸怩，难得直截了当</strong>。你明确你的目标，你知道关卡的难点，你也只需要去战胜它。</p><p>本作品分为6个章节，总共包含超过100个关卡。每个关卡都将是一场非凡的体验，尽情享受吧！</p><h2 id="作品信息">作品信息</h2><p><strong>作品名</strong>：<em>Mario Forever Euphoria</em><br><strong>开发平台</strong>：Clickteam Fusion 2.5+<br><strong>引擎</strong>：<a href="https://dasasdhba.github.io/res-UEL">Ultra Edition Legacy</a> (by <strong>dasasdhba</strong>)<br><strong>开发工作室</strong>：<br>Ultra Team<br><strong>关卡作者</strong>：<br>dasasdhba<br>zqh——123<br>2333ty<br><strong>其它工作</strong>：<br>dasasdhba<br>大爷23大买卖吗<br><strong>工作室成员</strong>：<br>dasasdhba<br>zqh——123<br>2333ty<br>大爷23大买卖吗<br>s小s飞s侠s<br>w1194600239<br></p><h2 id="作品截图">作品截图</h2><p><img src="/" class="lazyload" data-src="https://z3.ax1x.com/2021/05/18/ghvqWF.png"  /> <img src="/" class="lazyload" data-src="https://z3.ax1x.com/2021/05/18/ghvHiT.png"  /> <img src="/" class="lazyload" data-src="https://z3.ax1x.com/2021/05/18/ghvLz4.png"  /></p><h2 id="下载地址">下载地址</h2><p>最新版本：v4<br>蓝奏云：<a href="https://wwi.lanzoui.com/iaAQYo867rc" target="_blank" rel="noopener" class="uri">https://wwi.lanzoui.com/iaAQYo867rc</a></p><h2 id="相关链接">相关链接</h2><p>发布帖：<a href="https://www.marioforever.net/thread-922-1-1.html" target="_blank" rel="noopener" class="uri">https://www.marioforever.net/thread-922-1-1.html</a><br>Wiki：<a href="https://zh.wiki.marioforever.net/wiki/Mario_Forever_Euphoria" target="_blank" rel="noopener" class="uri">https://zh.wiki.marioforever.net/wiki/Mario_Forever_Euphoria</a><br>宣传片：<a href="https://www.bilibili.com/video/BV1H54y1t7b6" target="_blank" rel="noopener" class="uri">https://www.bilibili.com/video/BV1H54y1t7b6</a><br></p><p>嗯，欢迎评论~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mario-forever-euphoria&quot;&gt;Mario Forever Euphoria&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Ultra Team&lt;/strong&gt; 合作作品。&lt;/p&gt;
&lt;h2 id=&quot;its-not-mf-enough-but-does-it
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://dasasdhba.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="游戏" scheme="http://dasasdhba.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="资源" scheme="http://dasasdhba.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>【Archived】Clickteam Fusion 系列教程 第一章</title>
    <link href="http://dasasdhba.github.io/tutorial-CTFC1/"/>
    <id>http://dasasdhba.github.io/tutorial-CTFC1/</id>
    <published>2020-08-05T04:30:00.000Z</published>
    <updated>2023-03-29T15:51:10.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章入门">第一章：入门</h1><h2 id="前言">前言</h2><p>大概算是深度使用过这个软件，现在属于被这个软件坑得心理阴影非常严重的那种。至于为什么这么说，这个软件入门怎么说确实很友好，但只要想<strong>稍微构建一些复杂的东西</strong>，做起来就相当的麻烦（至少比同类软件麻烦得多）。</p><p>我在这个软件下搞了一个规模比较大的项目：<a href="https://dasasdhba.github.io/game-SMMWW"><strong>Super Mario Milky Way Wishes</strong></a>。<br>在这个过程中，<strong>我不知道被坑了多少次，踩了多少雷</strong>。<br><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/fd97d7628fcbde2db89663dbad4a898e.png"  /></p><p>我开这个教程，是不想让我以前踩过的雷就这么踩过了，希望如果还有人想用的这个软件的话，能够帮到一些忙。<br>本教程主要面向 <a href="https://www.marioforever.net/forum.php" target="_blank" rel="noopener"><strong>Mario Forever 社区</strong></a>，这里的小伙伴们基本上全都在用这个软件，，，<br>而且由于 <a href="https://zh.wiki.marioforever.net/wiki/Rainbow_Engine" target="_blank" rel="noopener"><strong>Rainbow Engine</strong></a> 大大降低了制作一个简单的 <strong>Mario Forever</strong> 同人作品的门槛，现在社区里面的制作者普遍欠缺了一些基本能力，而苦于没有比较能看的教程，想学也没有方向，基本上都处于<strong>瞎摸索状态</strong>。</p><h2 id="第一节认识软件">第一节：认识软件</h2><p>不管怎么说，至少要先把软件认识认识，其实现在很多制作者连软件都还没有认识深刻呢……</p><h3 id="安装软件">1.1：安装软件</h3><p>目前比较推荐的版本是 <strong>Clickteam Fusion 2.5+</strong>，这里是官网：<a href="https://www.clickteam.com" target="_blank" rel="noopener" class="uri">https://www.clickteam.com</a><br>当然，推荐在 <strong>Steam</strong> 购买（如果有能力的话）</p><p>实在不行，<strong>Mario Forever 社区</strong> 其实有资源的，<a href="https://www.marioforever.net/thread-421-1-1.html" target="_blank" rel="noopener">点击这里</a><br>其实先拿来学习还是不错的，可以以后再考虑入正。<br>对于这个资源，下载之后，找一个地方解压，双击下图所示文件启动：<br><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/9b5ceff309897202563785df55f08856.png"  /></p><p>不管怎么样，这是最终正常的启动画面：<br><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/270657a5a268ccea85ffadea9db27b06.png"  /></p><h3 id="工作区介绍">1.2 ：工作区介绍</h3><p>首先让我们新建一个应用程序，并进入 <strong>Frame 1</strong>，下图是一个非常简单的介绍：<br><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/d4e68401e918c79af32d2ff8b5b6b9ce.png"  /></p><p>除了图中提到的以外，没有什么特别需要说明的地方，建议自己再研究研究。</p><h3 id="对象与事件基础">1.3：对象与事件基础</h3><p>双击空白处以弹出 <strong>创建对象</strong> 窗口，如图：<br><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/6ded231f3c93e918c15093739e06267b.png"  /></p><p>如你所见，一个新的 <strong>Frame</strong> 最开始空空如也，我们需要创建各种各样的 <strong>对象</strong>，来填充这些 <strong>Frame</strong>，最终达到我们需要的效果，这便是 <strong>Clickteam Fusion</strong> 的核心工作流程。</p><p>但 <strong>对象</strong> 不会自己动，我们需要通过编写 <strong>事件</strong> 来让 <strong>对象</strong> 动起来。一般地，在工具栏中有两个事件编辑器区，如图：<br><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/4480822403b1c2e000bdb5e9e3ae0e5a.png"  /></p><p>左边那个为 <strong>Global Event Editor</strong>，右边的两个为 <strong>Frame Event Editor</strong> 。<br>顾名思义，一个作用于全局，一个作用于当前的 <strong>Frame</strong>，而右边的两个按钮对应的是两个 <strong>显示模式</strong> ：</p><ul><li><strong>Form</strong>：事件像 <strong>表格</strong> 一样排列的显示模式；</li><li><strong>List</strong>：事件像 <strong>正常的编程</strong> 一样的显示模式；</li></ul><p>为了便于显示，本教程一律使用 <strong>List</strong> 模式，顺带一提，最右侧的按钮负责这两个模式的 <strong>切换</strong>。</p><p>除了 <strong>Global Event</strong> 和 <strong>Frame Event</strong> 之外，我们还有一种事件类型可以使用：<strong>Behavior Event</strong>。<br>让我们创建一个 <code>Active</code> 对象，单击创建好的对象使 <strong>Properties</strong> 面板显示其属性，来到如下界面进行创建：<br><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/07fa67e5b8c3f6d872cca14b1f622f49.png"  /></p><p>类似的，<strong>Behavior Event</strong> 可以看作是 <strong>对象</strong> 的事件，<br>相较于 <strong>Frame Event</strong>，对象可以轻易地 <strong>Clone</strong>，复制到其他 <strong>Frame</strong>，<br>于是 <strong>Behavior Event</strong> 的优势就体现出来了。</p><p>关于事件具体的编写方法我们在 <strong>第二节</strong> 及 <strong>后续章节</strong> 介绍。</p><h3 id="编辑的小技巧">1.4：编辑的小技巧</h3><p>在编辑的时候，我们可以通过一些方法来提高我们编辑的效率。</p><h4 id="使用网格">1.4.1：使用网格</h4><p>我们可以在工具栏中开启网格，如图：<br><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/8233c6ee885d25d54bd012eb0dd11816.png"  /></p><p>而其中的第二个选项控制网格的 <strong>显示</strong> 与否，第一个选项是具体的设置，如图：<br><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/b0f03245db4a78b00bd448e3c34866f0.png"  /></p><p>使用网格可以更方便地进行对齐，如果你不用网格的话，那……祝你好运。</p><h4 id="善用-ctrl">1.4.2：善用 <strong>Ctrl</strong></h4><p>按住 <strong>Ctrl</strong> 并拖动一个 <strong>已存在对象</strong> 到其他位置，你会发现这等效于 <strong>复制</strong>。<br>我们甚至可以选择一大片的 <strong>对象</strong>，并按住 <strong>Ctrl</strong> 进行复制，这往往非常便捷。<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/04/24/JBZEUP.gif"  /></p><h4 id="duplicate-与-clone">1.4.3：<strong>Duplicate</strong> 与 <strong>Clone</strong></h4><p><strong>Duplicate</strong> 是一个很有趣的功能，可以帮助我们以一定的方式快速复制一些对象。<br>右键单击对象，选择 <strong>Duplicate</strong>，来到下图界面：<br><img src="/" class="lazyload" data-src="https://s1.ax1x.com/2020/04/24/JBZfrd.png"  /></p><p>可以看到，我们可以复制对象为 <strong>每行 x 个</strong>，<strong>每列 y 个</strong>；<br>我们甚至还可以调整 <strong>行间距</strong> 和 <strong>列间距</strong>。</p><p><strong>Clone</strong> 的界面与之类似，但一般情况下不建议 <strong>Clone</strong> 过多的对象。<br>原因我们将在第二节具体说明。</p><h2 id="第二节事件的基本思想">第二节：事件的基本思想</h2><p>可参考：<a href="https://www.marioforever.net/thread-2235-1-1.html" target="_blank" rel="noopener" class="uri">https://www.marioforever.net/thread-2235-1-1.html</a></p><h2 id="第三节常见设置的简单介绍">第三节：常见设置的简单介绍</h2><p>可参考：<a href="https://www.marioforever.net/thread-2665-1-1.html" target="_blank" rel="noopener" class="uri">https://www.marioforever.net/thread-2665-1-1.html</a></p><h2 id="尾声">尾声</h2><p>由于写教程实在是吃力不讨好，所以这个坑还是弃了，不过我在 MF 论坛开设的 CTF 问答帖还是能有一定参考价值的：<a href="https://www.marioforever.net/forum.php?mod=viewthread&amp;tid=732" target="_blank" rel="noopener" class="uri">https://www.marioforever.net/forum.php?mod=viewthread&amp;tid=732</a></p><p>顺带一提，我写这一段尾声的时候距离开这个坑也有几年了，现在我也有了一些新的感悟。学习游戏引擎，关键还是要自己实践，教程的作用大部分情况下应该是帮助你快速熟悉软件功能才对。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章入门&quot;&gt;第一章：入门&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;大概算是深度使用过这个软件，现在属于被这个软件坑得心理阴影非常严重的那种。至于为什么这么说，这个软件入门怎么说确实很友好，但只要想&lt;strong&gt;稍微构建一些复杂的东西&lt;/st
      
    
    </summary>
    
    
      <category term="教程" scheme="http://dasasdhba.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://dasasdhba.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【资源】Clickteam Fusion 2.5+ 部分自制 &amp; 优化特效</title>
    <link href="http://dasasdhba.github.io/res-CTFeffect/"/>
    <id>http://dasasdhba.github.io/res-CTFeffect/</id>
    <published>2020-04-18T05:23:59.000Z</published>
    <updated>2023-03-29T12:01:08.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="clickteam-fusion-2.5-部分自制-优化特效">Clickteam Fusion 2.5+ 部分自制 &amp; 优化特效</h1><p>一开始搞这个是因为 <strong>CTF2.5+</strong> 的 dx11 模式下挺多特效爆炸了，所以我就修复优化了一些常用的。<br>后来在学习了一些 Shader 之后，也开始自己搞了一些特效，具体可以详见论坛的帖子。</p><h2 id="下载地址">下载地址</h2><p>永硕：<a href="http://dasasdhba.ys168.com/" target="_blank" rel="noopener" class="uri">http://dasasdhba.ys168.com/</a><br></p><h2 id="相关链接">相关链接</h2><p>论坛帖子：<a href="https://www.marioforever.net/forum.php?mod=viewthread&amp;tid=425" target="_blank" rel="noopener" class="uri">https://www.marioforever.net/forum.php?mod=viewthread&amp;tid=425</a></p><p>嗯，欢迎评论~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;clickteam-fusion-2.5-部分自制-优化特效&quot;&gt;Clickteam Fusion 2.5+ 部分自制 &amp;amp; 优化特效&lt;/h1&gt;
&lt;p&gt;一开始搞这个是因为 &lt;strong&gt;CTF2.5+&lt;/strong&gt; 的 dx11 模式下挺多特效爆炸了，
      
    
    </summary>
    
    
      <category term="资源" scheme="http://dasasdhba.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="资源" scheme="http://dasasdhba.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>【游戏】Super Mario Milky Way Wishes</title>
    <link href="http://dasasdhba.github.io/game-SMMWW/"/>
    <id>http://dasasdhba.github.io/game-SMMWW/</id>
    <published>2020-04-18T05:05:04.000Z</published>
    <updated>2021-06-27T16:31:55.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="super-mario-milky-way-wishes">Super Mario Milky Way Wishes</h1><p>本人的第一个，也很有可能是最后一个大型马里奥同人作品。<br>制作模板已开源，详见 <a href="https://dasasdhba.github.io/res-UE"><strong>Super Mario Ultra Engine</strong></a></p><p>这一作大概算是 <strong>童年的梦想？</strong>，不过现在已经力不从心了哈哈哈……</p><p>放几张预览图：</p><p><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/dc366945c892e697e32d01b4eb476646.png"  /></p><p><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/ecf9657d5c794731fe079310b99e5cc0.png"  /></p><p><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/5272fe20014197a207733465e04b5ac7.png"  /></p><p><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/8643f5169939d6283055043f433462df.png"  /></p><p><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/f8e05b66a910d372cc88e6317eb83e60.png"  /></p><p><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/b2b989000b9d116ccba181b061607d37.png"  /></p><p>在此还要感谢在制作过程中不断帮助鼓励我的人们！！！<br><strong><span class="citation" data-cites="s小s飞s侠s">@s小s飞s侠s</span></strong> <strong><span class="citation" data-cites="zqh">@zqh</span>——123</strong> <del>就算是假的 at 我还是要 at（（</del><br>顺便也感谢一下第一位达成 <strong>200%</strong> 的玩家 <strong><span class="citation" data-cites="2333ty">@2333ty</span></strong>（不</p><h2 id="下载地址">下载地址：</h2><p>蓝奏云：<a href="https://lanzoui.com/b02avrc8b" target="_blank" rel="noopener" class="uri">https://lanzoui.com/b02avrc8b</a><br>（这年头应该不会有人不知道分卷压缩）<br>百度云：<a href="https://pan.baidu.com/s/1SKfNAwcPSsdbwZ4ixEWxDg" target="_blank" rel="noopener" class="uri">https://pan.baidu.com/s/1SKfNAwcPSsdbwZ4ixEWxDg</a> 提取码:mmww</p><h2 id="相关链接">相关链接</h2><p>发布帖：<a href="https://www.marioforever.net/thread-318-1-1.html" target="_blank" rel="noopener" class="uri">https://www.marioforever.net/thread-318-1-1.html</a><br>Wiki：<a href="https://zh.wiki.marioforever.net/wiki/Super_Mario_Milky_Way_Wishes" target="_blank" rel="noopener" class="uri">https://zh.wiki.marioforever.net/wiki/Super_Mario_Milky_Way_Wishes</a><br>宣传视频：<a href="https://www.bilibili.com/video/av85876184/" target="_blank" rel="noopener" class="uri">https://www.bilibili.com/video/av85876184/</a> （再次感谢 <strong><span class="citation" data-cites="s小s飞s侠s">@s小s飞s侠s</span></strong>）</p><p>嗯，欢迎评论哦~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;super-mario-milky-way-wishes&quot;&gt;Super Mario Milky Way Wishes&lt;/h1&gt;
&lt;p&gt;本人的第一个，也很有可能是最后一个大型马里奥同人作品。&lt;br&gt;制作模板已开源，详见 &lt;a href=&quot;https://dasas
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://dasasdhba.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="游戏" scheme="http://dasasdhba.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="资源" scheme="http://dasasdhba.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>【资源】Super Mario Ultra Engine</title>
    <link href="http://dasasdhba.github.io/res-UE/"/>
    <id>http://dasasdhba.github.io/res-UE/</id>
    <published>2020-04-18T04:51:28.000Z</published>
    <updated>2021-06-27T16:31:05.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="super-mario-ultra-engine">Super Mario Ultra Engine</h1><p>在 <strong>Clickteam Fusion 2.5</strong> 平台上编写的马里奥引擎，功能比较丰富。</p><p><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/4cfc9d727503141f6de6cae1ef5e25fa.jpg"  /></p><p><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/f4a6788417b0dbe2ce23cd04b6fe2bb3.png"  /></p><p>具体可以参见这个视频：<a href="https://www.bilibili.com/video/BV1kb411m7zh" target="_blank" rel="noopener" class="uri">https://www.bilibili.com/video/BV1kb411m7zh</a></p><p><strong>不再提供功能性更新</strong>，后续会进行 bug 修复。</p><p>最新版 <strong>1.0.200309</strong>：</p><ul><li>修复 <em>无效攻击</em> 和 <em>秒杀攻击</em> 的“！”配置错误</li></ul><h2 id="下载地址">下载地址</h2><p>永硕：<a href="http://dasasdhba.ys168.com/" target="_blank" rel="noopener" class="uri">http://dasasdhba.ys168.com/</a><br>蓝奏：<a href="https://lanzoui.com/b0bd46ji" target="_blank" rel="noopener" class="uri">https://lanzoui.com/b0bd46ji</a></p><h2 id="相关链接">相关链接</h2><p>发布帖：<a href="https://www.marioforever.net/thread-383-1-1.html" target="_blank" rel="noopener" class="uri">https://www.marioforever.net/thread-383-1-1.html</a></p><p>嗯，欢迎评论~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;super-mario-ultra-engine&quot;&gt;Super Mario Ultra Engine&lt;/h1&gt;
&lt;p&gt;在 &lt;strong&gt;Clickteam Fusion 2.5&lt;/strong&gt; 平台上编写的马里奥引擎，功能比较丰富。&lt;/p&gt;
&lt;p&gt;&lt;img
      
    
    </summary>
    
    
      <category term="资源" scheme="http://dasasdhba.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="资源" scheme="http://dasasdhba.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>【资源】Rainbow Engine Android</title>
    <link href="http://dasasdhba.github.io/res-REAndroid/"/>
    <id>http://dasasdhba.github.io/res-REAndroid/</id>
    <published>2020-04-18T04:36:23.000Z</published>
    <updated>2021-06-27T16:31:29.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rainbow-engine-android">Rainbow Engine Android</h1><p><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/bb0aa3c8cd9b7405213c0670c5bdaeb5.png"  /></p><p>一个基于 <strong>Rainbow Engine</strong> 的 <strong>Android</strong> 编译版， 平台是 <strong>Clickteam Fusion 2.5</strong>。<br>主要是自带的虚拟摇杆太反人类了，故自己搞了个虚拟按键。<br>顺便也做了一套还算比较完整的存档，应该也算是够用，不过 <strong>RE</strong> 版本不太跟得上。</p><p>现只提供 bug 修复更新。</p><h2 id="下载地址">下载地址</h2><p>永硕：<a href="http://dasasdhba.ys168.com/" target="_blank" rel="noopener" class="uri">http://dasasdhba.ys168.com/</a><br>蓝奏：<a href="https://lanzoui.com/iy97ba" target="_blank" rel="noopener" class="uri">https://lanzoui.com/iy97ba</a></p><p>嗯，欢迎评论~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;rainbow-engine-android&quot;&gt;Rainbow Engine Android&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; class=&quot;lazyload&quot; data-src=&quot;http://yanxuan.nosdn.127.net/bb0aa3c
      
    
    </summary>
    
    
      <category term="资源" scheme="http://dasasdhba.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="资源" scheme="http://dasasdhba.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>【资源】Mario Forever Neverland Engine</title>
    <link href="http://dasasdhba.github.io/res-NE/"/>
    <id>http://dasasdhba.github.io/res-NE/</id>
    <published>2020-04-18T04:27:35.000Z</published>
    <updated>2021-06-27T16:31:44.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mario-forever-neverland-engine">Mario Forever Neverland Engine</h1><p>基于 <strong>Rainbow Engine</strong> 的二次开发，加入了大量的马里奥状态，比较稳定。<br>平台是 <strong>Clickteam Fusion 2.5</strong>。</p><p><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/4fa9dddd7edc815f7b72e0b17b862dd3.png"  /></p><p>然而基于 <strong>RE</strong> 根本无法达到我的需求，故开源。<br>现以不再提供更新。</p><h2 id="下载地址">下载地址</h2><p>永硕：<a href="http://dasasdhba.ys168.com/" target="_blank" rel="noopener" class="uri">http://dasasdhba.ys168.com/</a><br>蓝奏：<a href="https://lanzoui.com/b007o2eh" target="_blank" rel="noopener" class="uri">https://lanzoui.com/b007o2eh</a></p><p>不过如果有特别严重的 bug 我可能还是会修（<br>嗯，欢迎评论~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mario-forever-neverland-engine&quot;&gt;Mario Forever Neverland Engine&lt;/h1&gt;
&lt;p&gt;基于 &lt;strong&gt;Rainbow Engine&lt;/strong&gt; 的二次开发，加入了大量的马里奥状态，比较稳定。&lt;b
      
    
    </summary>
    
    
      <category term="资源" scheme="http://dasasdhba.github.io/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="资源" scheme="http://dasasdhba.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>【游戏】Mario Forever Another Space</title>
    <link href="http://dasasdhba.github.io/game-MFAS/"/>
    <id>http://dasasdhba.github.io/game-MFAS/</id>
    <published>2020-04-18T04:19:58.000Z</published>
    <updated>2021-06-27T16:32:21.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mario-forever-another-space">Mario Forever Another Space</h1><p><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/c0a738d931fceca0eb3a91dd2b9f575b.png"  /></p><p>沉迷 <strong>Not Another Needle Game</strong> 的时候的产物，难度较大，质量也还可以。<br>大概算是第一个我自认为像样的作品，说起来当时也是想在圈子里面掀起一波非主流风格。<br><del>结果就 MFXD 被我带偏了（不</del></p><p>蓝奏云：<a href="https://lanzoui.com/i0j9vqf" target="_blank" rel="noopener" class="uri">https://lanzoui.com/i0j9vqf</a></p><p>祝游玩愉快，欢迎评论~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mario-forever-another-space&quot;&gt;Mario Forever Another Space&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; class=&quot;lazyload&quot; data-src=&quot;http://yanxuan.nosdn.127.n
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://dasasdhba.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="游戏" scheme="http://dasasdhba.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="资源" scheme="http://dasasdhba.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>【游戏】Mario Forever World Y</title>
    <link href="http://dasasdhba.github.io/game-mfWorldY/"/>
    <id>http://dasasdhba.github.io/game-mfWorldY/</id>
    <published>2020-04-18T04:14:06.000Z</published>
    <updated>2021-06-27T16:31:59.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mario-forever-world-y">Mario Forever World Y</h1><p><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/3484b300fb91396ab9e7d3c981b97507.png"  /></p><p>嗯……本人的第一个 MF 作品，质量就那样吧，除了素材在那个时代有点新颖也没啥特别亮眼的地方（</p><p>蓝奏云：<a href="https://lanzoui.com/ibjzhah" target="_blank" rel="noopener" class="uri">https://lanzoui.com/ibjzhah</a></p><p>黑历史还是不要吐槽了，不过还是欢迎评论哦~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mario-forever-world-y&quot;&gt;Mario Forever World Y&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; class=&quot;lazyload&quot; data-src=&quot;http://yanxuan.nosdn.127.net/3484b300f
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://dasasdhba.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="游戏" scheme="http://dasasdhba.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="资源" scheme="http://dasasdhba.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>【游戏】Mario Worker 部分作品</title>
    <link href="http://dasasdhba.github.io/game-marioworker/"/>
    <id>http://dasasdhba.github.io/game-marioworker/</id>
    <published>2020-04-18T03:53:46.000Z</published>
    <updated>2021-06-27T16:32:58.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mario-worker-部分作品">Mario Worker 部分作品</h1><p>嗯，这里是我很久以前的一些 <strong>Mario Worker</strong> 作品，都是 4.4 时代的产物，没啥好说的，留作纪念（</p><h2 id="mario-forever-fantasy-romance">Mario Forever Fantasy Romance</h2><figure><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/22519642858c755e3bcecd18d34c835b.png"  alt="Fantasy Romance" /><figcaption aria-hidden="true">Fantasy Romance</figcaption></figure><p>满满黑历史啊……那时的我在干嘛（</p><h2 id="kirby-world">Kirby World</h2><figure><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/ab32613b03fcc9f5f886b068c1665748.png"  alt="Kirby World" /><figcaption aria-hidden="true">Kirby World</figcaption></figure><p>我当年到底在干什么哈哈哈哈哈哈哈哈哈哈哈哈</p><h2 id="hazy-maze-cavern">Hazy Maze Cavern</h2><figure><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/e4266cd28af0121691a6504015b317f1.png"  alt="Hazy Maze Cavern" /><figcaption aria-hidden="true">Hazy Maze Cavern</figcaption></figure><p>这关质量其实还行，当年还是个小学生左上角是机翻的就别吐槽了（（</p><h2 id="mario-return-to-neverland">Mario Return to Neverland</h2><figure><img src="/" class="lazyload" data-src="http://yanxuan.nosdn.127.net/1b30ac14dbc8e36dc61c3e565eaf9f12.png"  alt="MRTN" /><figcaption aria-hidden="true">MRTN</figcaption></figure><p>说起来这个坑还没填完，才做了三世界不过难度已经足够崩坏了（（<br>其实也算是设计风格成熟的标志作品，也是最后一作吧……</p><h2 id="下载地址">下载地址</h2><p>蓝奏云：<a href="https://lanzoui.com/b02b1jurg" target="_blank" rel="noopener" class="uri">https://lanzoui.com/b02b1jurg</a></p><p>嗯，黑历史什么的就不要吐槽了，不过还是欢迎评论~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mario-worker-部分作品&quot;&gt;Mario Worker 部分作品&lt;/h1&gt;
&lt;p&gt;嗯，这里是我很久以前的一些 &lt;strong&gt;Mario Worker&lt;/strong&gt; 作品，都是 4.4 时代的产物，没啥好说的，留作纪念（&lt;/p&gt;
&lt;h2 id=&quot;m
      
    
    </summary>
    
    
      <category term="游戏" scheme="http://dasasdhba.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="游戏" scheme="http://dasasdhba.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="资源" scheme="http://dasasdhba.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>dasasdhba 的个人博客上线啦！！！</title>
    <link href="http://dasasdhba.github.io/life-%E4%B8%8A%E7%BA%BF/"/>
    <id>http://dasasdhba.github.io/life-%E4%B8%8A%E7%BA%BF/</id>
    <published>2020-04-16T16:03:49.653Z</published>
    <updated>2020-04-17T15:31:04.909Z</updated>
    
    <content type="html"><![CDATA[<p>搞了半天总算是把这个博客架好了，以后有啥东西就往这里放啦~<br>不过还是有很多东西需要不断学习不断调整，嗯，继续努力！<br>域名啥的等我上大学再考虑，先就用这个（<br><a href="https://dasasdhba.github.io" class="uri">https://dasasdhba.github.io</a></p><p>嗯，欢迎评论哦~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;搞了半天总算是把这个博客架好了，以后有啥东西就往这里放啦~&lt;br&gt;不过还是有很多东西需要不断学习不断调整，嗯，继续努力！&lt;br&gt;域名啥的等我上大学再考虑，先就用这个（&lt;br&gt;&lt;a href=&quot;https://dasasdhba.github.io&quot; class=&quot;uri&quot;&gt;
      
    
    </summary>
    
    
      <category term="生活琐事" scheme="http://dasasdhba.github.io/categories/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
    
      <category term="生活琐事" scheme="http://dasasdhba.github.io/tags/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
  </entry>
  
</feed>
