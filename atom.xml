<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>das&#39;s Blog</title>
  
  <subtitle>Moonstruck Blossom</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dasasdhba.github.io/"/>
  <updated>2026-01-06T14:02:05.054Z</updated>
  <id>http://dasasdhba.github.io/</id>
  
  <author>
    <name>dasasdhba</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人 MF 开发资源汇总</title>
    <link href="http://dasasdhba.github.io/personal/mfengine/"/>
    <id>http://dasasdhba.github.io/personal/mfengine/</id>
    <published>2026-01-06T12:46:00.000Z</published>
    <updated>2026-01-06T14:02:05.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="clickteam-fusion">Clickteam Fusion</h1><p>这个引擎相关的资源都可以在我的<ahref="http://dasasdhba.ysepan.com">永硕网盘</a>里边找到。</p><h2 id="effect-相关">Effect 相关</h2><p>Fusion 2.5+ 版本引入了 Direct3D 11，Shader 语言的升级导致了很多Effect 失效。我针对部分特效做了修复，也借此机会自己学了一点Shader，自己做了一些效果。</p><p>详见：<a href="https://www.marioforever.net/thread-425-1-1.html"class="uri">https://www.marioforever.net/thread-425-1-1.html</a></p><h2 id="super-mario-ultra-edition">Super Mario Ultra Edition</h2><p>经典 Mario Forever的再演绎，提供了体验相对稳定的物理系统，也有社区共同维护的 Mod生态。代表作：</p><p><imgsrc="https://www.marioforever.net/data/attachment/forum/202508/03/184953nz0y6x6ir4y0i0tk.png"alt="MFRJ" /> <imgsrc="https://www.marioforever.net/data/attachment/forum/202411/17/200045k3gqgd51dfka5ggj.png"alt="MFBL" /></p><p>更新帖：<a href="https://www.marioforever.net/thread-705-1-1.html"class="uri">https://www.marioforever.net/thread-705-1-1.html</a></p><h2 id="super-mario-ultra-engine">Super Mario Ultra Engine</h2><p>功能对标 New Super Mario Bros. 的模板，开发负担较重。代表作：</p><figure><imgsrc="http://yanxuan.nosdn.127.net/fd97d7628fcbde2db89663dbad4a898e.png"alt="SMMWW" /><figcaption aria-hidden="true">SMMWW</figcaption></figure><p>发布帖：<a href="https://www.marioforever.net/thread-383-1-1.html"class="uri">https://www.marioforever.net/thread-383-1-1.html</a></p><h2 id="rainbow-engine-android">Rainbow Engine Android</h2><figure><imgsrc="https://imgsa.baidu.com/forum/w%3D580/sign=8f73bb0fd91b0ef46ce89856edc551a1/26b685529822720e274211db70cb0a46f31fabc0.jpg"alt="安卓 MF" /><figcaption aria-hidden="true">安卓 MF</figcaption></figure><p>尝试将 RE编译到安卓平台并提供虚拟按键支持，不过意义不大，毕竟没人会想一份工做两次。</p><p>发布帖：<a href="https://tieba.baidu.com/p/5315180841"class="uri">https://tieba.baidu.com/p/5315180841</a></p><h2 id="neverland-engine">Neverland Engine</h2><figure><imgsrc="http://yanxuan.nosdn.127.net/4fa9dddd7edc815f7b72e0b17b862dd3.png"alt="很多马里奥" /><figcaption aria-hidden="true">很多马里奥</figcaption></figure><p>本人早期基于 <ahref="https://zh.wiki.marioforever.net/wiki/Rainbow_Engine">RainbowEngine</a> 的二次开发，加入了大量的马里奥状态，原本的目标是达到 UltraEngine 的水准，但是基于 RE 的底子实在是做不到，遂放弃。</p><p>发布帖：<a href="https://tieba.baidu.com/p/5052963558"class="uri">https://tieba.baidu.com/p/5052963558</a></p><h1 id="game-maker">Game Maker</h1><h2 id="super-mario-vandal-editor">Super Mario Vandal Editor</h2><p>基于 Game Maker 8.2 的 Mario Forever单关模板，甚至没有提供完整的标题、选关界面等功能，只是拿来复刻 MWCW用的。</p><figure><img src="/img/loading.gif" class="lazyload" data-src="https://s41.ax1x.com/2026/01/06/pZdgc9J.png"  alt="MFCW" /><figcaption aria-hidden="true">MFCW</figcaption></figure><p>详见：<a href="https://www.marioforever.net/thread-1458-1-2.html"class="uri">https://www.marioforever.net/thread-1458-1-2.html</a></p><h1 id="godot">Godot</h1><h2 id="mario-forever-berry-editor">Mario Forever Berry Editor</h2><p>基于 Godot 3.x 的 MF 模板，算是自己初学 Godot的产物，还算比较完整。但是现在 Godot 4 都出了，所以没啥用了。</p><figure><img src="/img/loading.gif" class="lazyload" data-src="https://s1.ax1x.com/2022/04/10/LAWZ79.md.png"  alt="Godot 3" /><figcaption aria-hidden="true">Godot 3</figcaption></figure><p>详见：<a href="https://www.marioforever.net/thread-2020-1-1.html"class="uri">https://www.marioforever.net/thread-2020-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;clickteam-fusion&quot;&gt;Clickteam Fusion&lt;/h1&gt;
&lt;p&gt;这个引擎相关的资源都可以在我的&lt;a
href=&quot;http://dasasdhba.ysepan.com&quot;&gt;永硕网盘&lt;/a&gt;里边找到。&lt;/p&gt;
&lt;h2 id=&quot;effect-
      
    
    </summary>
    
    
      <category term="开发" scheme="http://dasasdhba.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="http://dasasdhba.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>个人 MF/MW 作品汇总</title>
    <link href="http://dasasdhba.github.io/personal/mfmw/"/>
    <id>http://dasasdhba.github.io/personal/mfmw/</id>
    <published>2026-01-06T10:26:00.000Z</published>
    <updated>2026-01-06T14:03:18.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人作">个人作</h1><h2 id="mario-forever-horizon">Mario Forever Horizon</h2><figure><img src="/img/loading.gif" class="lazyload" data-src="https://s21.ax1x.com/2024/07/19/pkojnsO.png"  alt="标题界面" /><figcaption aria-hidden="true">标题界面</figcaption></figure><p>同人游戏创作，最大的好处大概就是不用太担心原创性问题，从而可以把自己喜欢的游戏元素原封不动地抄起来。MarioForever Horizon 就是这样一部猎奇的类银恶 / ARPG作品，你会在作品中看到很多其他游戏的影子，只是唯独没什么马里奥的影子就是。至于剧情和设计方面，基本都是随性而为，谈不上精巧，毕竟这只是一部耗时半年的作品。</p><p>手感问题是一个比较受争议的点，而且从结果来看反馈比较两极分化。我的角度，我本人不太愿意去做平凡的，别人都做过都玩过的东西，我很希望能做出自己的创新点。这也是为什么我特别喜欢Phoenotopia的手感设计，敢于跳出框架，才能有全新的体验。普罗大众都容易接受的手感是怎样的我固然清楚，但为了创新我更乐意剑走偏锋吧。</p><p>不得不承认的是，我完全忽略了玩家适应新的手感和操作模式，是需要良好的引导和难度曲线的。这个事情也直接导致，星卡，或者空洞，或者别的比较类似的游戏的老玩家上手这个作品就会很快适应，新玩家能比较快适应的也有但是很少，更有很多玩家到最后都没适应。反观星卡，难度本身不高；空洞，有良好的难度曲线和引导。总之，这方面确实是我忽略掉的一个致命问题，仔细想来，我自己曾经从事的创作，都是同人创作，而玩家也是事先早就熟悉手感的，我也自然从未考虑过这个问题。现在总结来看，既然想要在这方面剑走偏锋，其实就不得不考虑这个问题，否则就还是只能做普罗大众能比较容易接受的手感。（好巧不巧，测试人员里边，要么恰好也是星卡老玩家，要么空洞也至少通关了，于是愣是没人提出很大的意见）</p><p>总之，制作这个作品，对我来说算是一个不小的收获吧。</p><h3 id="相关链接">相关链接</h3><ul><li>发布帖：<a href="https://www.marioforever.net/thread-3273-1-1.html"class="uri">https://www.marioforever.net/thread-3273-1-1.html</a></li><li>宣传片：<a href="https://www.bilibili.com/video/BV1Fi421Q7Rj"class="uri">https://www.bilibili.com/video/BV1Fi421Q7Rj</a></li><li>剧情解说：<a href="https://www.bilibili.com/video/BV1pBudzTEGP"class="uri">https://www.bilibili.com/video/BV1pBudzTEGP</a>（感谢<ahref="https://www.bilibili.com/video/BV1pBudzTEGP/?spm_id_from=333.999.0.0">原力总督</a>）</li></ul><h2 id="super-mario-milky-way-wishes">Super Mario Milky Way Wishes</h2><figure><imgsrc="http://yanxuan.nosdn.127.net/fd97d7628fcbde2db89663dbad4a898e.png"alt="标题界面" /><figcaption aria-hidden="true">标题界面</figcaption></figure><p>童真的梦想，梦幻的风格，不成熟的自我。中学时期比较压抑的那几年做出来的作品，设计方面堆料和重复严重，像极了中学时期堆成山的作业，只能说明人的精神状态会极大影响其创作风格。中后期的游戏体验大多难而无趣，游玩需谨慎。</p><h3 id="相关链接-1">相关链接</h3><ul><li>宣传片：<a href="https://www.bilibili.com/video/av85876184/"class="uri">https://www.bilibili.com/video/av85876184/</a> （感谢 <ahref="https://space.bilibili.com/32717471">s小s飞s侠s</a>）</li><li>发布帖：<a href="https://www.marioforever.net/thread-318-1-1.html"class="uri">https://www.marioforever.net/thread-318-1-1.html</a></li></ul><h2 id="mario-forever-another-space">Mario Forever Another Space</h2><figure><imgsrc="http://yanxuan.nosdn.127.net/c0a738d931fceca0eb3a91dd2b9f575b.png"alt="Stage 1" /><figcaption aria-hidden="true">Stage 1</figcaption></figure><p>沉迷 <ahref="https://delicious-fruit.com/ratings/game_details.php?id=12534">NotAnother Needle Game</a> 的产物，也有 <ahref="https://delicious-fruit.com/ratings/game_details.php?id=11706">Iwanna see the Moon</a>的影子，难度较大，质量也还可以，大概算是第一个我自认为像样的作品。说起来，当时我也是想在圈子里面掀起一波非主流风格，结果带来的却是<ahref="https://zh.wiki.marioforever.net/wiki/Mario_Forever_X_Domain">MFXD</a></p><p>发布帖：<a href="https://tieba.baidu.com/p/5559564654"class="uri">https://tieba.baidu.com/p/5559564654</a></p><h2 id="mario-return-to-neverland">Mario Return to Neverland</h2><figure><imgsrc="http://yanxuan.nosdn.127.net/1b30ac14dbc8e36dc61c3e565eaf9f12.png"alt="2-1" /><figcaption aria-hidden="true">2-1</figcaption></figure><p>与 Super Mario Milky Way Wishes有异曲同工之妙，都是画风精巧但是难度崩坏，做了三个世界就放弃了。后来 <ahref="https://space.bilibili.com/32717471">s小s飞s侠s</a>出了个精神续作，令人感动；只可惜 xfx后来退坑了，作品也随之删除，所以这里也不过多介绍了。</p><p>发布帖：<a href="https://tieba.baidu.com/p/4315917912"class="uri">https://tieba.baidu.com/p/4315917912</a></p><h2 id="hazy-maze-cavern">Hazy Maze Cavern</h2><figure><imgsrc="http://yanxuan.nosdn.127.net/e4266cd28af0121691a6504015b317f1.png"alt="其实是玩马里奥 64 玩的" /><figcaption aria-hidden="true">其实是玩马里奥 64 玩的</figcaption></figure><p>庆贺元旦的单关作，质量还不错，只是当年还是个小学生，左上角的机翻实在是忍俊不禁。</p><p>发布帖：<a href="https://tieba.baidu.com/p/3501434215"class="uri">https://tieba.baidu.com/p/3501434215</a></p><h2 id="kirby-world">Kirby World</h2><figure><imgsrc="http://yanxuan.nosdn.127.net/ab32613b03fcc9f5f886b068c1665748.png"alt="岩浆遮不住地面怎么办？" /><figcaption aria-hidden="true">岩浆遮不住地面怎么办？</figcaption></figure><p>一天做一个世界的含金量，做关不带脑子的典型；我本人对此已经无法直视了，真的会有人对这种东西感兴趣么？</p><p>发布帖：<a href="https://tieba.baidu.com/p/3234728020"class="uri">https://tieba.baidu.com/p/3234728020</a></p><h2 id="mario-forever-fantasy-romance">Mario Forever FantasyRomance</h2><figure><imgsrc="http://yanxuan.nosdn.127.net/22519642858c755e3bcecd18d34c835b.png"alt="然而这是 MW 作品" /><figcaption aria-hidden="true">然而这是 MW 作品</figcaption></figure><p>梦开始的地方。</p><p>发布帖：<a href="https://tieba.baidu.com/p/3138548076"class="uri">https://tieba.baidu.com/p/3138548076</a>（别看，我求你了）</p><h1 id="ultra-team-作">Ultra Team 作</h1><h2 id="mario-forever-season-collab">Mario Forever Season Collab</h2><figure><imgsrc="https://zh.wiki.marioforever.net/w/images/images_wikidb_mf_zh/thumb/e/e1/Season.png/450px-Season.png"alt="完整版标题界面" /><figcaption aria-hidden="true">完整版标题界面</figcaption></figure><p>23 年 MF 社区的一场狂欢，亦是 Mario Forever Horizon的起源。这里边我的一些关卡，自认为可以代表我所有 MF/MW创作的最高设计水平。</p><figure><img src="https://s1.ax1x.com/2023/04/05/pp56d0J.png"alt="Demotivation" /><figcaption aria-hidden="true">Demotivation</figcaption></figure><h3 id="相关链接-2">相关链接</h3><ul><li>发布帖：<a href="https://www.marioforever.net/thread-2579-3-1.html"class="uri">https://www.marioforever.net/thread-2579-3-1.html</a></li><li>Wiki: <ahref="https://zh.wiki.marioforever.net/wiki/Mario_Forever_Season_Collab"class="uri">https://zh.wiki.marioforever.net/wiki/Mario_Forever_Season_Collab</a></li><li>个人花絮：<ahref="https://www.marioforever.net/thread-3064-1-3.html"class="uri">https://www.marioforever.net/thread-3064-1-3.html</a></li></ul><h2 id="传统节日系列">传统节日系列</h2><h3 id="mario-forever-violent-romance">Mario Forever ViolentRomance</h3><figure><imgsrc="https://www.marioforever.net/data/attachment/forum/202108/14/155956zovrk66oe6k4eo2b.jpg"alt="标题界面" /><figcaption aria-hidden="true">标题界面</figcaption></figure><p>那天，四个人一时兴起，一天便成就了这部作品。</p><h3 id="mario-forever-lunatic-plenilune">Mario Forever LunaticPlenilune</h3><figure><img src="/img/loading.gif" class="lazyload" data-src="https://z3.ax1x.com/2021/09/19/43yx4f.png"  alt="Level 1" /><figcaption aria-hidden="true">Level 1</figcaption></figure><p>于是，「传统」就此延续，只是刚开始的时候，事情并不算顺利。</p><h3 id="mario-forever-brand-new-start">Mario Forever Brand NewStart</h3><figure><img src="https://s4.ax1x.com/2021/12/31/T5SpUU.md.png"alt="Level by 116" /><figcaption aria-hidden="true">Level by 116</figcaption></figure><p>所以，我决定将合作彻底放开。</p><h3 id="mario-forever-enchanted-memory">Mario Forever EnchantedMemory</h3><figure><img src="https://s1.ax1x.com/2022/04/05/qLq3TO.md.png"alt="xfx&#39;s 飞升天堂" /><figcaption aria-hidden="true">xfx's 飞升天堂</figcaption></figure><p>甚至我自己都想摆烂了，结果大伙硬是两天凑出整整六关，顺便还玩了场Domino。</p><h3 id="mario-forever-ambivalence-overflow">Mario Forever AmbivalenceOverflow</h3><figure><img src="https://s41.ax1x.com/2026/01/06/pZd6g54.png"alt="zqh&#39;s Final Goodbye" /><figcaption aria-hidden="true">zqh's Final Goodbye</figcaption></figure><p>这是一系列难忘的回忆。</p><h3 id="相关链接-3">相关链接</h3><ul><li>七夕：<a href="https://www.marioforever.net/thread-1414-1-1.html"class="uri">https://www.marioforever.net/thread-1414-1-1.html</a></li><li>中秋：<a href="https://www.marioforever.net/thread-1569-1-1.html"class="uri">https://www.marioforever.net/thread-1569-1-1.html</a></li><li>元旦：<a href="https://www.marioforever.net/thread-1860-1-1.html"class="uri">https://www.marioforever.net/thread-1860-1-1.html</a></li><li>清明：<a href="https://www.marioforever.net/thread-2016-1-1.html"class="uri">https://www.marioforever.net/thread-2016-1-1.html</a></li><li>端午：<a href="https://www.marioforever.net/thread-2086-1-1.html"class="uri">https://www.marioforever.net/thread-2086-1-1.html</a></li></ul><h2 id="mario-forever-conventional-world">Mario Forever ConventionalWorld</h2><figure><img src="/img/loading.gif" class="lazyload" data-src="https://s1.ax1x.com/2022/03/27/q0n1mR.md.png"  alt="1-1" /><figcaption aria-hidden="true">1-1</figcaption></figure><p>xfx 帮我完成了 Mario Return to Neverland 的续作，我则将 xfx 的经典 MW作品复刻到了 MF 平台上，这是曾经的一个承诺，更是一场有目共睹的双赢。</p><p>发布帖：<a href="https://www.marioforever.net/thread-2004-1-1.html"class="uri">https://www.marioforever.net/thread-2004-1-1.html</a></p><h2 id="mario-forever-euphoria">Mario Forever Euphoria</h2><figure><img src="/img/loading.gif" class="lazyload" data-src="https://s3.ax1x.com/2021/02/11/yBCwwj.md.png"  alt="Rapture" /><figcaption aria-hidden="true">Rapture</figcaption></figure><p>硬核平台跳跃作品，Ultra Team 首秀，也是 Ultra Edition 的开山之作。<ahref="https://space.bilibili.com/162885400">zqh</a>在设计方面总是比我走得更远，十分推荐各位尝试本作中由他负责的关卡。至于我本人，大概还是那个随性设计的家伙吧。</p><h3 id="相关链接-4">相关链接</h3><ul><li>宣传片：<a href="https://www.bilibili.com/video/BV1H54y1t7b6"class="uri">https://www.bilibili.com/video/BV1H54y1t7b6</a></li><li>发布帖：<a href="https://www.marioforever.net/thread-922-1-1.html"class="uri">https://www.marioforever.net/thread-922-1-1.html</a></li></ul><h1 id="参与作">参与作</h1><p>我曾参与过的作品实属纷杂，有胎死腹中的，有已被删除的，还有至今仍未问世的。所以，这里就不太按时间顺序来整理了。</p><h2 id="legend-world-remake">Legend World Remake</h2><figure><imgsrc="https://www.marioforever.net/data/attachment/forum/202509/04/212857wl0hhhh7mzunluel.webp"alt="标题界面" /><figcaption aria-hidden="true">标题界面</figcaption></figure><p>nmnmoooh 经典 MW作品的复刻，我曾参与部分关卡的复刻，做过一些技术支持和美术优化，也曾负责少部分关卡和Boss 的设计。</p><p>发布帖（2.0）：<ahref="https://www.marioforever.net/thread-3700-1-1.html"class="uri">https://www.marioforever.net/thread-3700-1-1.html</a></p><h2 id="super-mario-forever-2021">Super Mario Forever 2021</h2><figure><imgsrc="https://www.marioforever.net/data/attachment/forum/202112/01/221603exvhs3ihhff2sz2m.png"alt="标题界面" /><figcaption aria-hidden="true">标题界面</figcaption></figure><p>xfx 的经典 MF 结构作品，我提供了少量技术支持，并设计了标题字体。</p><p>发布帖：<a href="https://www.marioforever.net/thread-1792-1-1.html"class="uri">https://www.marioforever.net/thread-1792-1-1.html</a></p><h2 id="mysterious-island-1-2">Mysterious Island 1 &amp; 2</h2><figure><img src="https://ftp.bmp.ovh/imgs/2021/07/3e7411004194a776.png"alt="Chapter 5" /><figcaption aria-hidden="true">Chapter 5</figcaption></figure><p>w1194600239 的代表作品系列，我作为主要技术支持参与了制作，并负责了 C5的主要设计。</p><h3 id="相关链接-5">相关链接</h3><ul><li>一代发布帖：<a href="https://tieba.baidu.com/p/3947941940"class="uri">https://tieba.baidu.com/p/3947941940</a></li><li>二代发布帖（1.5）：<a href="https://tieba.baidu.com/p/4960539746"class="uri">https://tieba.baidu.com/p/4960539746</a></li><li>C5 发布帖：<ahref="https://www.marioforever.net/thread-1323-1-1.html"class="uri">https://www.marioforever.net/thread-1323-1-1.html</a></li></ul><h2 id="mario-in-the-forest">Mario In the FOREST</h2><figure><imgsrc="https://www.marioforever.net/data/attachment/forum/202112/30/195506n0633py70p6pzf0f.png"alt="标题界面" /><figcaption aria-hidden="true">标题界面</figcaption></figure><p>116 的代表作之一，我提供了引擎、大地图、部分 Boss 的技术支持。</p><p>发布帖：<a href="https://www.marioforever.net/thread-1303-1-1.html"class="uri">https://www.marioforever.net/thread-1303-1-1.html</a></p><h2 id="mario-forever-odyssey">Mario Forever Odyssey</h2><figure><imgsrc="https://www.marioforever.net/data/attachment/forum/202105/28/231140ep6dkyspkd02yytg.png"alt="标题界面" /><figcaption aria-hidden="true">标题界面</figcaption></figure><p>大爷风格独特的作品，我提供了存档、地图等方面的技术支持。</p><p>发布帖：<a href="https://www.marioforever.net/thread-1180-1-1.html"class="uri">https://www.marioforever.net/thread-1180-1-1.html</a></p><h2 id="象牙塔">象牙塔</h2><figure><imgsrc="https://www.marioforever.net/data/attachment/forum/202007/25/225327a3vv3h128f12dw3p.png"alt="标题界面" /><figcaption aria-hidden="true">标题界面</figcaption></figure><p>DET 关卡工房发起的合作，我负责了部分关卡设计。</p><p>发布帖：<a href="https://www.marioforever.net/thread-308-1-1.html"class="uri">https://www.marioforever.net/thread-308-1-1.html</a></p><h2 id="mario-forever-save-zqh">Mario Forever Save Zqh</h2><figure><imgsrc="https://www.marioforever.net/data/attachment/forum/201912/07/211434saecqyoqobtzteje.png"alt="找不到配图了" /><figcaption aria-hidden="true">找不到配图了</figcaption></figure><p>zqh 的经典作品之一，我负责了部分关卡设计。</p><p>发布帖：<a href="https://www.marioforever.net/thread-250-1-1.html"class="uri">https://www.marioforever.net/thread-250-1-1.html</a></p><h2 id="mario-forever-irrational-travel">Mario Forever IrrationalTravel</h2><figure><imgsrc="https://archive.marioforever.net/images/mfbarimage_0x54c5cb392efb42576eaa3e5cc4bab1280e82ab46.jpg"alt="标题界面" /><figcaption aria-hidden="true">标题界面</figcaption></figure><p>DET关卡工房发起的合作，我负责了全部的程序整合测试和大地图制作，并参与了部分关卡和Boss 设计。</p><p>发布帖：<ahref="https://archive.marioforever.net/post/5859606213.html"class="uri">https://archive.marioforever.net/post/5859606213.html</a></p><h2 id="mario-forever-xfxs-world">Mario Forever xfx's World</h2><figure><imgsrc="https://zh.wiki.marioforever.net/w/images/images_wikidb_mf_zh/thumb/4/4a/1.png/450px-1.png"alt="标题界面" /><figcaption aria-hidden="true">标题界面</figcaption></figure><p>xfx发起的合作作品，我负责了部分关卡的美术和设计修改，并提供了一定的技术支持。</p><p>发布帖：<a href="https://tieba.baidu.com/p/5809690908"class="uri">https://tieba.baidu.com/p/5809690908</a></p><h2 id="mario-forever-magic-land">Mario Forever Magic Land</h2><figure><imgsrc="https://zh.wiki.marioforever.net/w/images/images_wikidb_mf_zh/thumb/4/45/MFML.png/450px-MFML.png"alt="标题界面" /><figcaption aria-hidden="true">标题界面</figcaption></figure><p>大爷的传统 MF 作品，我负责了最终 Boss设计，并提供了部分技术支持。</p><p>发布帖：<a href="https://tieba.baidu.com/p/5249533815"class="uri">https://tieba.baidu.com/p/5249533815</a></p><h2 id="永吧十周年">永吧十周年</h2><figure><imgsrc="https://imgsa.baidu.com/forum/w%3D580%3Bcp%3Dtieba%2C10%2C403%3Bap%3D%3F%2C90%2C411/sign=de2381d01ece36d3a20483380ac859f7/28493d381f30e9243d0fe13b47086e061c95f7d6.jpg"alt="标题界面" /><figcaption aria-hidden="true">标题界面</figcaption></figure><p>快8 的搞笑风格作品，我负责了部分关卡设计，并提供了部分技术支持。</p><p>发布帖：<a href="https://tieba.baidu.com/p/5349451961"class="uri">https://tieba.baidu.com/p/5349451961</a></p><h2 id="happy-mario-world">Happy Mario World</h2><figure><imgsrc="https://archive.marioforever.net/images/mfbarimage_0x1c2fda95c4834b636e5e6084d13adc7fba0755bf.jpg"alt="没错我提供了这关的神秘手感" /><figcaption aria-hidden="true">没错我提供了这关的神秘手感</figcaption></figure><p>快8 在没有键盘的情况下做出来的作品，我提供了部分技术支持。</p><p>发布帖：<ahref="https://archive.marioforever.net/post/3988303427.html"class="uri">https://archive.marioforever.net/post/3988303427.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;个人作&quot;&gt;个人作&lt;/h1&gt;
&lt;h2 id=&quot;mario-forever-horizon&quot;&gt;Mario Forever Horizon&lt;/h2&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/loading.gif&quot; class=&quot;lazyload&quot; dat
      
    
    </summary>
    
    
      <category term="创作" scheme="http://dasasdhba.github.io/categories/%E5%88%9B%E4%BD%9C/"/>
    
    
      <category term="创作" scheme="http://dasasdhba.github.io/tags/%E5%88%9B%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>重启</title>
    <link href="http://dasasdhba.github.io/restart/"/>
    <id>http://dasasdhba.github.io/restart/</id>
    <published>2026-01-06T04:00:00.000Z</published>
    <updated>2026-01-06T14:12:09.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重启">重启</h1><p>这个博客荒废了快三年了，近期正在考虑重启，后面可能会不定期更新一些文章。想当初，这个博客还是一个几乎不懂技术的少年，在网上随便找教程一步步搭出来的；现在，我再用VSCode 打开当初部署的文件夹，可以说是五味陈杂。</p><p>博客的样式就不换了，尊重年少时自己的审美吧，反正看着也不差。不过，出于版面的考虑，部分老“文章”现在被统一放到合订本里边了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重启&quot;&gt;重启&lt;/h1&gt;
&lt;p&gt;这个博客荒废了快三年了，近期正在考虑重启，后面可能会不定期更新一些文章。想当初，这个博客还是一个几乎不懂技术的少年，在网上随便找教程一步步搭出来的；现在，我再用
VSCode 打开当初部署的文件夹，可以说是五味陈杂。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="记录" scheme="http://dasasdhba.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数值分析复习笔记</title>
    <link href="http://dasasdhba.github.io/math/numeric-analysis/"/>
    <id>http://dasasdhba.github.io/math/numeric-analysis/</id>
    <published>2023-04-24T06:10:28.000Z</published>
    <updated>2026-01-06T13:48:34.088Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为应付考试而整理的复习笔记，因而只是整理我个人认为考前需要速通的点，因而不一定全面以及完备。</p><h1 id="误差分析">误差分析</h1><h2 id="两类基本误差">两类基本误差</h2><ul><li><p>绝对误差：<spanclass="math inline">\(e_{\bar{x}}=x-\bar{x}\)</span></p></li><li><p>相对误差：<spanclass="math inline">\(r_{\bar{x}}=\frac{e_{\bar{x}}}x\)</span></p><p>由于 <span class="math inline">\(x\)</span> 往往未知，在 <spanclass="math inline">\(r_{\bar{x}}\)</span> 很小的时候，可以用 <spanclass="math inline">\(r^*_{\bar{x}}=\frac{e_{\bar{x}}}{\bar{x}}\)</span>近似</p></li></ul><h2 id="舍入误差与有效数字">舍入误差与有效数字</h2><p>记十进制数 <span class="math inline">\(a\)</span> 某个数码 <spanclass="math inline">\(a_s\)</span> 的位数为 <spanclass="math inline">\(k(a_s)\)</span>，当 <spanclass="math inline">\(a_s\)</span> 在个位时取 0，十位时取1，小数点后第一位时取 -1，以此类推</p><ul><li><p>舍入误差：将 a 四舍五入至 <span class="math inline">\(k\)</span>位小数，那么 <spanclass="math inline">\(|e_{\bar{a}}|\leq\frac12\times10^{-k}\)</span></p></li><li><p>有效数字：设 <span class="math inline">\(\bar{a}\)</span> 为<span class="math inline">\(a\)</span> 的近似值，从 <spanclass="math inline">\(\bar{a}\)</span> 中首位不为零的数码起，称数码<span class="math inline">\(a_s\)</span> 为有效数字，若满足： <spanclass="math display">\[|e_{\bar{a}}|\leq\frac12\times10^{k(a_s)}\]</span>（因而对于四舍五入得到的近似值，从首位不为零的数码起，所有数码都是有效数字）</p></li></ul><p>利用有效数字，我们有如下<strong>相对误差估计</strong>：</p><p>设 <span class="math inline">\(\bar{a}\)</span> 有 <spanclass="math inline">\(k\)</span> 位有效数字，其中第一位有效数字为 <spanclass="math inline">\(a_s\)</span>，那么： <span class="math display">\[|r^*_{\bar{a}}|\leq\frac1{2a_s}\times10^{-(k-1)}\]</span> 反之，若有上述不等式成立，则 <spanclass="math inline">\(\bar{a}\)</span> 至少有 <spanclass="math inline">\(k\)</span> 位有效数字</p><p>（这说明有效数字越多，相对误差越小）</p><h2 id="运算中的误差传播">运算中的误差传播</h2><p>考察二元函数 <span class="math inline">\(z=f(x,y)\)</span>产生的误差：<spanclass="math inline">\(e_{\bar{z}}=f(x,y)-f(\bar{x},\bar{y})\)</span></p><p>当 <span class="math inline">\(|e_{\bar{x}}|,|e_{\bar{y}}|\)</span>很小，且 <span class="math inline">\(f\)</span> 可微时，有近似公式：<span class="math display">\[e_{\bar{z}}\approx \frac{\partial f}{\partialx}(\bar{x},\bar{y})\:e_{\bar{x}}+\frac{\partial f}{\partialy}(\bar{x},\bar{y})\:e_{\bar{y}}\\r_{\bar{z}}\approx \frac{\bar{x}}{\bar{z}}\frac{\partial f}{\partialx}(\bar{x},\bar{y})\:r_{\bar{x}}+\frac{\bar{y}}{\bar{z}}\frac{\partialf}{\partial y}(\bar{x},\bar{y})\:r_{\bar{y}}\]</span> （对于 <span class="math inline">\(r^*\)</span>亦有类似的近似）</p><p>由此导出：</p><ol type="1"><li><p><span class="math inline">\(f(x,y)=x\pm y\)</span> <spanclass="math display">\[e_{\bar{x}\pm \bar{y}}=e_{\bar{x}}\pm e_{\bar{y}}\\r_{\bar{x}\pm \bar{y}}=\frac{\bar{x}}{\bar{x}\pm\bar{y}}r_{\bar{x}}\pm\frac{\bar{y}}{\bar{x}\pm \bar{y}}r_{\bar{y}}\]</span> 可见 <span class="math inline">\(x\approx y\)</span>时作减法会产生较大的相对误差，这被称为<strong>相减相消</strong>，应尽量避免</p></li><li><p><span class="math inline">\(f(x,y)=xy\)</span> <spanclass="math display">\[e_{\bar{x}\bar{y}}=\bar{y}e_{\bar{x}}+\bar{x}e_{\bar{y}}\\r_{\bar{x}\bar{y}}=r_{\bar{x}}+r_{\bar{y}}\]</span></p></li><li><p><span class="math inline">\(f(x,y)=x/y\)</span> <spanclass="math display">\[e_{\bar{x}/\bar{y}}=\frac{\bar{y}e_{\bar{x}}-\bar{x}e_{\bar{y}}}{\bar{y}^2}\\r_{\bar{x}/\bar{y}}=r_{\bar{x}}-r_{\bar{y}}\]</span> 可见 <span class="math inline">\(y\to0\)</span>时会产生较大的绝对误差，应尽量避免</p></li></ol><h2 id="计算机浮点系统">计算机浮点系统</h2><p>称 <span class="math inline">\(F(p,t,L,U)\)</span>为一个计算机浮点系统，其中：</p><ul><li><span class="math inline">\(p\)</span>：基数（进制）</li><li><span class="math inline">\(t\)</span>：精度（最大小数位数）</li><li><span class="math inline">\(L,U\)</span>：指数的取值范围 <spanclass="math inline">\([-L,U]\)</span>（整数）</li></ul><p>属于浮点系统 <span class="math inline">\(F\)</span> 的数 <spanclass="math inline">\(x\)</span> 具有如下形式： <spanclass="math display">\[x=\pm p^J\sum_{k=1}^td_kp^{-k}=\pm (0.d_1d_2...d_t)_p\times p^J\\J\in \mathbb{Z}\cap[-L,U],\:d_k\in\{0,1,2,...,p-1\}\]</span> 称 <span class="math inline">\((0.d_1d_2...d_t)_p\)</span> 为<span class="math inline">\(x\)</span> 的尾数，<spanclass="math inline">\(J\)</span> 为 <spanclass="math inline">\(x\)</span> 的指数（阶）</p><p>称 <span class="math inline">\(x\)</span>为<strong>规格化浮点数</strong>，若 <spanclass="math inline">\(d_1\neq0\)</span></p><h3 id="ufl-与-ofl">UFL 与 OFL</h3><ul><li>称 <span class="math inline">\(F\)</span> 中的最小正数为 <spanclass="math inline">\(UFL=p^{-t}\times p^{-L}=p^{-(L+t)}\)</span></li><li>称 <span class="math inline">\(F\)</span> 中的最大正数为 <spanclass="math inline">\(OFL=(1-p^{-t})\times p^U\)</span></li></ul><h3 id="机器精度">机器精度</h3><p><span class="math inline">\(F\)</span> 自然不能表示任意实数，称 <spanclass="math inline">\(F\)</span> 中用于表示一个在 <strong>UFL</strong>以及 <strong>OFL</strong> 范围内的实数 <spanclass="math inline">\(x\)</span> 的最大的相对误差为机器精度 <spanclass="math inline">\(\varepsilon_{mach}\)</span></p><ul><li>若采取<strong>截断法</strong>：<spanclass="math inline">\(\varepsilon_{mach}=p^{1-t}\)</span></li><li>若采取<strong>最近舍入法</strong>（四舍六入五取双）：<spanclass="math inline">\(\varepsilon_{mach}=\frac12p^{1-t}\)</span></li></ul><p>一般地：<spanclass="math inline">\(0&lt;UFL&lt;\varepsilon_{mach}&lt;OFL\)</span></p><h3 id="机器算术运算">机器算术运算</h3><p>以 <span class="math inline">\(\oplus\:\ominus\:\otimes\)</span>等符号代表机器算术运算符号， 可以假定机器运算的定义为： <spanclass="math display">\[x\odot y=fl(fl(x)\cdot fl(y))\]</span> 其中 <span class="math inline">\(\cdot\)</span>泛指上述符号，<span class="math inline">\(fl(x)\)</span> 为 <spanclass="math inline">\(F\)</span> 中最接近 <spanclass="math inline">\(x\)</span> 的数，也就是 <spanclass="math inline">\(x\)</span> 在 <spanclass="math inline">\(F\)</span> 中的表示</p><p>乘除运算是直接进行的，只需要分别处理底数部分和指数部分即可；</p><p>而对于加减运算，则需要<strong>对阶</strong>操作，即首先将阶数较小的数调整为与阶数较大的数同阶数（相应地，底数修改小数点位置），这个过程中若底数超出了精度<spanclass="math inline">\(t\)</span>，则需要截断或最近舍入；完成加减运算之后，仍然需要作截断或最近舍入</p><p>特别地，对于减法，我们有<strong>精度丢失定理</strong>：设 <spanclass="math inline">\(x&gt;y\)</span> 均为正的规格化二进制浮点数，且<span class="math inline">\(2^{-q}\leq1-\frac yx\leq2^{-p}\)</span> 则<span class="math inline">\(x\ominus y\)</span> 丢失至多 <spanclass="math inline">\(q\)</span> 个，至少 <spanclass="math inline">\(p\)</span> 个有效二进制位</p><h2 id="数值稳定与病态问题">数值稳定与病态问题</h2><ul><li><p>称一个算法是<strong>数值稳定</strong>的，若在计算过程中，<strong>误差</strong>不会增长，否则称为<strong>数值不稳定</strong>的</p><p>例：在计算递推式时，式中出现了形如 <spanclass="math inline">\(x_{n+1}=ax_n,\:a&gt;1\)</span>的情况，那么误差就会被 <span class="math inline">\(a\)</span>不断放大，导致数值不稳定</p></li><li><p>称一个问题是<strong>病态</strong>的，若输入的<strong>微小变化</strong>能够导致输出的<strong>巨大误差</strong></p><p>例：求解线性方程组时系数矩阵接近奇异，如 <spanclass="math inline">\(Hilbert\)</span> 矩阵</p></li></ul><h1 id="插值法">插值法</h1><p>插值问题是指给定一组离散数据 <spanclass="math inline">\(\{x_k,y_k\},k=0,1,...,n\)</span>，我们试图寻求一函数形如：<span class="math display">\[\varphi(x)=a_0\varphi_0(x)+a_1\varphi_1(x)+...+a_n\varphi_n(x)\]</span> 使得 <span class="math inline">\(\varphi(x_k)=y_k,\forallk=0,1,...,n\)</span></p><h2 id="lagrange-插值"><span class="math inline">\(Lagrange\)</span>插值</h2><p>记 <span class="math inline">\(l_i(x)=\prod_{j=0,j\neqi}^n\frac{x-x_j}{x_i-x_j}\)</span>，则 <spanclass="math inline">\(l_i(x_j)=\delta_{ij}\)</span>，称为 <spanclass="math inline">\(Lagrange\)</span> 基本多项式</p><p>则 <span class="math inline">\(Lagrange\)</span> 插值多项式为：<spanclass="math inline">\(L_n(x)=\sum_{i=0}^nf(x_i)l_i(x)\)</span>，容易证明这是存在唯一的</p><p>方便起见，若记 <spanclass="math inline">\(\omega_{n+1}(x)=\prod_{i=0}^n(x-x_i)\)</span>，那么<span class="math inline">\(\omega_{n+1}&#39;(x_i)=\prod_{j=0,j\neqi}^n(x_i-x_j)\)</span></p><p>于是 <spanclass="math inline">\(l_i(x)=\frac{\omega_{n+1}(x)}{(x-x_i)\omega_{n+1}&#39;(x_i)}\)</span></p><h3 id="余项">余项</h3><p>设离散数据 <spanclass="math inline">\(\{x_k,y_k\},k=0,1,...,n\)</span> 是由函数 <spanclass="math inline">\(f\)</span> 给出，也就是 <spanclass="math inline">\(y_i=f(x_i)\)</span>，称： <spanclass="math display">\[r_n(x)=f(x)-L_n(x)\]</span> 为 <span class="math inline">\(Lagrange\)</span>插值多项式的<strong>余项</strong></p><p>假设 <span class="math inline">\(f\)</span> 在包含 <spanclass="math inline">\(\{x_n\}\)</span> 的区间 <spanclass="math inline">\([a,b]\)</span> 上具有 <spanclass="math inline">\(n\)</span> 阶连续导数，且在 <spanclass="math inline">\((a,b)\)</span> 内存在 <spanclass="math inline">\(n+1\)</span> 阶有界导数， <br>那么 <spanclass="math inline">\(\forall x \in [a,b],\:\exists \xi\in(a,b)\)</span>使得： <span class="math display">\[r_n(x)=\frac{f^{n+1}(\xi)}{(n+1)!}\omega_{n+1}(x)\]</span> 其证明需要简单了解，大致如下： <br>因为 <spanclass="math inline">\(x_0,x_1,...,x_n\)</span> 都是 <spanclass="math inline">\(r_n(x)\)</span> 的一重零点，故可以设 <spanclass="math inline">\(r_n(x)=\omega_{n+1}(x)K(x)\)</span>，为确定 <spanclass="math inline">\(K(x)\)</span>，引入辅助函数： <spanclass="math display">\[F(t)=f(t)-L_n(t)-K(x)\omega_{n+1}(t)\]</span> 则 <span class="math inline">\(t = x_0,x_1,...,x_n,x\)</span>时均有 <span class="math inline">\(F(t)=0\)</span>，反复应用 <spanclass="math inline">\(Rolle\)</span> 定理就有 <spanclass="math inline">\(0=F^{(n+1)}(\xi)=f^{(n+1)}(\xi)-K(x)(n+1)!\)</span><br>从而不难解出 <span class="math inline">\(K(x)\)</span> （这说明<span class="math inline">\(\xi\)</span> 与 <spanclass="math inline">\(x_0,x_1,...,x_n,x\)</span> 有关）</p><p>通过考察余项，我们可以估计误差，特别地，对于线性插值，有： <spanclass="math display">\[|r_1(x)|\leq\frac{(b-a)^2}{8}|f&#39;&#39;(\xi)|\]</span> 对于二次插值，有： <span class="math display">\[|r_2(x)|\leq \frac{\sqrt3}{27}(b-a)^3|f&#39;&#39;&#39;(\xi)|\]</span></p><h3 id="runge-现象"><span class="math inline">\(Runge\)</span> 现象</h3><p>一般而言，<span class="math inline">\(n\)</span> 越大，<spanclass="math inline">\(L_n(x)\)</span> 在端点附近的抖动也越大，这被称为<span class="math inline">\(Runge\)</span>现象，因而高次插值法一般不能用于外插</p><h2 id="newton-插值"><span class="math inline">\(Newton\)</span>插值</h2><h3 id="均差">均差</h3><p>称 <spanclass="math inline">\(f[x_i,x_j]=\frac{f(x_j)-f(x_i)}{x_j-x_i}\)</span>为 <span class="math inline">\(f\)</span> 关于基点 <spanclass="math inline">\(x_i,x_j\)</span> 的一阶均差<br> 称 <spanclass="math inline">\(f[x_i,x_j,x_k]=\frac{f[x_j,x_k]-f[x_i,x_j]}{x_k-x_i}\)</span>为 <span class="math inline">\(f\)</span> 关于基点 <spanclass="math inline">\(x_i,x_j,x_k\)</span> 的二阶均差<br> 一般地，<spanclass="math inline">\(f[x_0,x_1,...,x_n]=\frac{f[x_1,x_2,...,x_n]-f[x_0,x_1,...,x_{n-1}]}{x_n-x_0}\)</span><br>方便起见，不妨规定 <spanclass="math inline">\(f[x_i]=f(x_i)\)</span></p><p>用归纳法可以证明： <span class="math display">\[f[x_0,x_1,...,x_n]=\sum_{i=0}^n\frac{f(x_i)}{\prod_{j=0,j\neqi}^n(x_i-x_j)}\]</span></p><h4 id="差商表">差商表</h4><p>常用差商表来计算各个均差：</p><p><span class="math display">\[\left[\begin{array}{}x_0 &amp; f(x_0)\\x_1 &amp; f(x_1)  &amp; f[x_0,x_1]\\x_2 &amp; f(x_2) &amp; f[x_1,x_2] &amp; f[x_0,x_1,x_2]\\... &amp; ... &amp; ... &amp; ...  &amp; ...\\x_n &amp; f(x_n) &amp; f[x_{n-1},x_n] &amp; f[x_{n-2},x_{n-1},x_n]&amp;  ... &amp; f[x_0,...,x_n]\\\end{array}\right]\]</span></p><h3 id="newton-插值多项式"><span class="math inline">\(Newton\)</span>插值多项式</h3><p><span class="math inline">\(Lagrange\)</span>插值的缺陷是每新增一个样本点都要全部重新算一遍，<spanclass="math inline">\(Newton\)</span>插值优化了这一点，其关键是将多项式考虑为如下形式： <spanclass="math display">\[N_n(x)=a_0+a_1(x-x_0)+a_2(x-x_0)(x-x_1)+...+a_n(x-x_0)(x-x_1)...(x-x_{n-1})\]</span> 从而不难看出 <spanclass="math inline">\(a_k=f[x_0,x_1,...,x_k]\)</span></p><p>若新增一插值基点 <span class="math inline">\(\bar{x}\)</span>，那么<spanclass="math inline">\(f(\bar{x})-N_n(\bar{x})=N_{n+1}(\bar{x})-N_n(\bar{x})=f[x_0,x_1,...,x_n,\bar{x}]\omega_{n+1}(\bar{x})\)</span><br>据插值多项式的唯一性，比较上一节中的余项就有： <spanclass="math display">\[f[x_0,x_1,...,x_n,x]=\frac{f^{(n+1)}(\xi)}{(n+1)!}\]</span></p><h3 id="有限差">有限差</h3><p>下面我们考虑样本点满足 <spanclass="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span>的简单情形，方便起见，引入有限差的概念，分别称： <spanclass="math display">\[\Delta f(x)=f(x+h)-f(x)\\\nabla f(x)=f(x)-f(x-h)\\\delta f(x)=f(x+\frac h2)-f(x-\frac h2)\]</span> 为函数 <span class="math inline">\(f(x)\)</span> 在点 <spanclass="math inline">\(x\)</span>的一阶向前差分，一阶向后差分以及一阶中心差分，易见它们都是线性算子<br>下面以向前差分为例定义高阶情形： <span class="math display">\[\Delta^2f(x)=\Delta(\Delta f(x))=\Delta f(x+h)-\Delta f(x)\\\Delta^nf(x)=\Delta(\Delta^{n-1} f(x))=\Delta^{n-1} f(x+h)-\Delta^{n-1}f(x)\\\]</span> 类似地，方便起见我们规定 <spanclass="math inline">\(\Delta^0f(x)=f(x)\)</span>，用归纳法可以证明：<span class="math display">\[\Delta^n f(x)=\sum_{i=0}^n(-1)^iC_n^if(x+(n-i)h)\\\nabla^n f(x)=\sum_{i=0}^n(-1)^iC_n^if(x-ih)\\\delta^n f(x)=\sum_{i=0}^n(-1)^iC_n^if(x+(\frac n2-i)h)\]</span> 反过来，我们也有： <span class="math display">\[f(x+nh)=\sum_{i=0}C_n^i\Delta^if(x)\\f(x-nh)=\sum_{i=0}^n(-1)^iC_n^i\nabla^if(x)\\f(x+nh)=\sum_{i=0}^nC_n^i\delta^if(x+\frac i2h)\]</span> 最后，对于满足 <spanclass="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span>的样本点，我们有： <span class="math display">\[f[x_0,x_1,...,x_n]=\frac{\Delta^nf(x_0)}{n!h^n}=\frac{\nabla^nf(x_n)}{n!h^n}\]</span> 对于中心差分则需要分样本点的奇偶个数作讨论，原理类似</p><h4 id="差分表">差分表</h4><p>可以用差商表类似的方法构造差分表以计算差分，以向前差分为例：</p><p><span class="math display">\[\left[\begin{array}{}x_i=x_0+ih &amp; \Delta &amp; \Delta^2 &amp; \Delta^3 &amp; ...  &amp;\Delta^{n-1} &amp; \Delta^n\\x_0 &amp; \Delta f(x_0) &amp; \Delta^2 f(x_0) &amp; \Delta^3 f(x_0)&amp;  ... &amp;\Delta^{n-1} f(x_0)&amp; \Delta^n f(x_0)\\x_1 &amp; \Delta f(x_1) &amp; \Delta^2 f(x_1) &amp; \Delta^3 f(x_1)&amp;  ... &amp;\Delta^{n-1} f(x_1)&amp;\\x_2 &amp; \Delta f(x_2) &amp; \Delta^2 f(x_2) &amp; \Delta^3 f(x_2)&amp;  ...\\... &amp; ... &amp; ... &amp; ... &amp; ... \\x_{n-1} &amp; \Delta f(x_{n-1}) &amp; \Delta^2 f(x_{n-1}) \\x_n &amp; \Delta f(x_n)\end{array}\right]\]</span></p><h3 id="newton-前插和后插公式"><spanclass="math inline">\(Newton\)</span> 前插和后插公式</h3><p>考虑样本点满足 <span class="math inline">\(x_k-x_{k-1}=h,\forallk=1,2,..,n\)</span> 的情形，利用均差和向前差分的关系，作变换：<spanclass="math inline">\(x=x_0+sh\)</span> <br>从而 <spanclass="math inline">\(Newton\)</span> 插值公式可以整理为： <spanclass="math display">\[N_n(x)=N_n(x_0+sh)=\sum_{k=0}^n\left(\begin{array}{}s\\k\end{array}\right)\Delta^kf(x_0)\\\left(\begin{array}{}s\\k\end{array}\right)=\frac{s(s-1)...(s-k+1)}{k!}\]</span> 即 <span class="math inline">\(Newton\)</span>前插公式；利用向后差分，作变换：<spanclass="math inline">\(x=x_n+th\)</span>，同理有： <spanclass="math display">\[N_n(x)=N_n(x_n+th)=\sum_{k=0}^n\left(\begin{array}{}-t\\k\end{array}\right)(-1)^k\nabla^kf(x_n)\\\left(\begin{array}{}-t\\k\end{array}\right)(-1)^k=\frac{t(t+1)...(t+k-1)))}{k!}\]</span> 即 <span class="math inline">\(Newton\)</span> 后插公式</p><h2 id="hermite-插值">Hermite 插值</h2><p>在 <span class="math inline">\(Hermite\)</span>插值中我们不仅已知样本点的值，还知道样本点的前 <spanclass="math inline">\(n\)</span>阶导数值，因而我们希望寻求一插值多项式使得其导数值也与我们的已知数据符合，下面讨论<span class="math inline">\(n=1\)</span> 的简单情形：</p><p>设已知 <span class="math inline">\(f(x)\)</span> 在插值基点 <spanclass="math inline">\(x_0,x_1,...,x_n\)</span> 处的函数值分别为 <spanclass="math inline">\(y_0,y_1,...,y_n\)</span> 以及一阶导数值分别为<span class="math inline">\(y&#39;_0,y&#39;_1,...,y&#39;_n\)</span><br>我们试求一多项式 <span class="math inline">\(H_{2n+1}\inR[x]_{2n+2}\)</span> 使得： <span class="math display">\[\left\{ \begin{aligned}H_{2n+1}(x_i)=y_i\\H&#39;_{2n+1}(x_i)=y&#39;_i\end{aligned}\right.\]</span> 不妨设： <span class="math display">\[H_{2n+1}=\sum_{i=0}^ny_iA_i(x)+\sum_{i=0}^ny&#39;_iB_i(x)\\A_i(x_j)=\delta_{ij},\:A&#39;_i(x_j)=0\\B_i(x_j)=0,\:B&#39;_i(x_j)=\delta_{ij}\]</span> 可以通过分析 <span class="math inline">\(A_i,\:B_i\)</span>各自零点的重数设出其形式进而求解，最后可以得到： <spanclass="math display">\[B_i(x)=(x-x_i)l_i^2(x)\\A_i(x)=\left(1-2(x-x_i)\sum_{j=0,j\neqi}^n\frac1{x_i-x_j}\right)l_i^2(x)\]</span> 与 <span class="math inline">\(Lagrange\)</span>插值类似，可以证明 <span class="math inline">\(Hermite\)</span>插值的唯一性，以及其余项可表示为： <span class="math display">\[r(x)=\frac{f^{(2n+2)}(\xi)}{(2n+2)!}\omega_{n+1}^2(x)\]</span></p><h2 id="分段插值">分段插值</h2><p>为了解决高次多项式插值带来的 <spanclass="math inline">\(Runge\)</span>现象，可以使用分段插值，也就是将插值区间细分为若干子区间，并在这些子区间内使用较低次数的多项式进行插值的办法，其中最简单的分段插值就是<strong>分段线性插值</strong></p><h3 id="分段插值误差界">分段插值误差界</h3><p>直观上，采用分段插值时，子区间分的越细，那么分段插值的误差界应该越小<br>下面我们考虑将插值区间分为等距基点 <spanclass="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span>的情形，由之前对余项的讨论，有：</p><ul><li><p>分段线性插值： <span class="math display">\[|e_{f_1(x)}|\leq\frac{1}8Mh^2\\M=\mathop{max}\limits_{x\in[a,b]}|f&#39;&#39;(x)|\]</span></p></li><li><p>分段抛物线插值（即每一个区间含三个基点采用二次多项式插值）：<span class="math display">\[|e_{f_2(x)}|\leq\frac{\sqrt{3}}{27} M h^3\\M=\mathop{max}\limits_{x\in[a,b]}|f&#39;&#39;&#39;(x)|\]</span></p></li></ul><h3 id="三次样条插值">三次样条插值</h3><p>直接作分段插值的一个严重的问题是得到的结果往往不光滑，因而我们可以考虑在每一区间<span class="math inline">\([x_i,x_{i+1}]\)</span>上采用三次多项式插值，并要求每一段的拼接点的导数以及二阶导数相等，这种插值办法被称为三次样条插值</p><p>直观上，我们需要求解 <span class="math inline">\(4n\)</span>个待定系数，然而假设的条件只能给出 <spanclass="math inline">\(4n-2\)</span>个方程，因而我们需要附加两个条件，常采用边界条件：</p><ul><li>自然边界条件：取插值函数在 <span class="math inline">\(x_0,x_n\)</span> 处的二阶导数为 <spanclass="math inline">\(0\)</span>，这样得到的插值称为<strong>自然三次样条插值</strong></li><li>完备边界条件：假设我们已知待插值函数 <spanclass="math inline">\(f\)</span> 在端点处的导数值，取插值函数在 <spanclass="math inline">\(x_0, x_n\)</span>处的导数与之相等即可，这样得到的插值称为<strong>完备三次样条插值</strong></li></ul><p>下面简要讨论具体的计算，给定 <spanclass="math inline">\([a,b]\)</span> 的一组基点： <spanclass="math display">\[a=x_1&lt;x_2&lt;...&lt;x_{n+1}=b\]</span> 记 <span class="math inline">\([x_i,x_i+1]\)</span>上的三次插值多项式为 <spanclass="math inline">\(S_i(x),\:i=1,2,...,n\)</span>，已知条件为： <spanclass="math display">\[S_{i-1}(x_i)=S_i(x_i)=f(x_i),\:i=2,...,n\\S&#39;_{i-1}(x_i)=S&#39;_i(x_i),\:i=2,...,n\\S&#39;&#39;_{i-1}(x_i)=S&#39;&#39;_i(x_i),\:i=2,...,n\\S_1(x_1)=f(x_1),\:S_n(x_{n+1})=f(x_{n+1})\]</span> 记 <spanclass="math inline">\(S&#39;&#39;_i(x_i)=m_i,\:h_i=x_{i+1}-x_i\)</span>，因为<span class="math inline">\(deg\:S&#39;&#39;_i=1\)</span>，结合 <spanclass="math inline">\(S&#39;&#39;_{i-1}(x_i)=S&#39;&#39;_i(x_i)\)</span>就知道其必形如： <span class="math display">\[S&#39;&#39;_i(x)=m_i\frac{x_{i+1}-x}{h_i}+m_{i+1}\frac{x-x_i}{h_i}\]</span> 对其积分得： <span class="math display">\[S&#39;_i(x)=-m_i\frac{(x_{i+1}-x)^2}{2h_i}+m_{i+1}\frac{(x-x_i)^2}{2h_i}+A_i\\S_i(x)=m_i\frac{(x_{i+1}-x)^3}{6h_i}+m_{i+1}\frac{(x-x_i)^3}{6h_i}+A_i(x-x_i)+B_i\]</span> 结合 <spanclass="math inline">\(S_i(x_i)=f(x_i),\:S_i(x_{i+1})=f(x_{i+1})\)</span>可以解得： <span class="math display">\[B_i=f(x_i)-m_i\frac{h_i^2}6\\A_i=f[x_i,x_{i+1}]-\frac{h_i}6(m_{i+1}-m_i)\]</span> 再由 <spanclass="math inline">\(S&#39;_{i-1}(x_i)=S&#39;_i(x_i)\)</span> 就得到：<span class="math display">\[h_{i-1}m_{i-1}+2(h_{i-1}+h_i)m_i+h_im_{i+1}=6(f[x_i,x_{i+1}]-f[x_{i-1},x_i])\]</span> 也就是： <span class="math display">\[\left(\begin{array}{}h_1 &amp;2(h_1+h_2) &amp; h_2 &amp; 0 &amp; ... &amp; 0 \\0 &amp; h_2 &amp;2(h_2+h_3) &amp; h_3 &amp; ... &amp; 0 \\... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... \\0 &amp; ... &amp; h_{n-2} &amp;2(h_{n-2}+h_{n-1}) &amp; h_{n-1} &amp;0\\0 &amp; 0 &amp; ... &amp; h_{n-1} &amp;2(h_{n-1}+h_{n}) &amp; h_{n}\end{array}\right)\left(\begin{array}{}m_1\\m_2\\...\\m_n\\m_{n+1}\end{array}\right)=6\left(\begin{array}{}d_2\\d_3\\...\\d_{n-1}\\d_n\end{array}\right)\\\\d_i=f[x_i,x_{i+1}]-f[x_{i-1},x_i]\]</span> 前已述该方程没有唯一解，需要补上一定的边界条件，即：</p><ul><li><p>自然边界条件：<spanclass="math inline">\(m_1=m_{n+1}=0\)</span></p></li><li><p>完备边界条件：<spanclass="math inline">\(S&#39;_1(a)=f&#39;(a),\:S&#39;_n(b)=f&#39;(b)\)</span>，进而：<span class="math display">\[2h_1m_1+h_1m_2=6(f[x_1,x_2]-f&#39;(a))\\h_nm_n+2h_nm_{n+1}=6(f&#39;(b)-f[x_n,x_{n+1}])\]</span></p></li></ul><p>补上这些边界条件即有唯一解</p><h3 id="基样条插值">基样条插值</h3><p>注意到 <span class="math inline">\(Lagrange\)</span>插值多项式总可以写成 <span class="math inline">\(Lagrange\)</span>基本多项式 <span class="math inline">\(l_i(x)\)</span>的线性组合，亦可寻找一<strong>基三次样条系</strong>来表示三次样条插值函数</p><p>常见的办法是构造一在区间 <span class="math inline">\([-2,2]\)</span>上的分段三次多项式 <spanclass="math inline">\(\varphi(x)\)</span>，使得其在 <spanclass="math inline">\(x=-1,0,1\)</span>上面的取值以及导数值，二阶导数值较好，以及在 <spanclass="math inline">\(x=-2,2\)</span> 上的函数值，导数值，二阶导数值均为<spanclass="math inline">\(0\)</span>，从而可以通过将其根据实际的基点位置作平移和伸缩变换得到一系列基函数</p><h1 id="函数逼近">函数逼近</h1><h2 id="正交函数系">正交函数系</h2><p>称 <span class="math inline">\(W(x)\)</span> 为 <spanclass="math inline">\([a,b]\)</span> 上的权函数，若满足：</p><ul><li>在 <span class="math inline">\((a,b)\)</span> 中，<spanclass="math inline">\(W(x)\geq 0\)</span>，且只有有限个零点</li><li><span class="math inline">\(\int_a^bx^iW(x)dx,i=1,2,...\)</span>存在且有限</li></ul><p>则对于非负连续函数 <span class="math inline">\(f\)</span>，若 <spanclass="math inline">\(\int_a^bf(x)W(x)dx=0\)</span>，则在 <spanclass="math inline">\([a,b]\)</span> 上有 <spanclass="math inline">\(f(x)\equiv 0\)</span></p><p>给定 <span class="math inline">\(f,g\in C[a,b]\)</span>，称 <spanclass="math inline">\((f,g)=\int_a^bW(x)f(x)g(x)dx\)</span> 为函数 <spanclass="math inline">\(f,g\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 上关于权 <spanclass="math inline">\(W(x)\)</span> 的内积<br>（满足内积的各种性质，亦可以由此定义范数）</p><p>我们常用下面三类范数： <span class="math display">\[\Vert f\Vert_\infty=\mathop{max}_\limits{x\in[a,b]}|f(x)W(x)|\\\Vert f\Vert_1=\int_a^b|f(x)W(x)|dx\\\Vert f\Vert_2=\sqrt{(f,f)}\]</span></p><p>称函数系 <span class="math inline">\(\{f_n(x)\}\)</span> 为 <spanclass="math inline">\([a,b]\)</span> 上关于权函数 <spanclass="math inline">\(W(x)\)</span> 的正交函数系，若 <spanclass="math inline">\((f_i,f_j)=A_i\delta_{ij}\)</span></p><h3 id="线性无关">线性无关</h3><p>可以与线性代数理论类似考虑一族函数的线性无关性，称函数系 <spanclass="math inline">\(\{f_n(x)\}\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 上线性无关，若： <spanclass="math display">\[\sum_{i=0}^na_if_i=0 \Rightarrow a_i=0,\forall i=0,1,...,n\]</span> 可以证明这等价于： <span class="math display">\[\left|\begin{array}{}(f_0,f_0) &amp; (f_0,f_1) &amp;... &amp;(f_0,f_n)\\(f_1,f_0) &amp; (f_1,f_1) &amp;... &amp;(f_1,f_n)\\... &amp; ... &amp; ... &amp; ... \\(f_n,f_0) &amp; (f_n,f_1) &amp;... &amp;(f_n,f_n)\end{array}\right|\neq0\]</span> 该行列式被称为 <span class="math inline">\(Gram\)</span>行列式</p><p>可以用 <span class="math inline">\(Schmidt\)</span>正交化将一族线性无关函数化为正交函数系，即： <spanclass="math display">\[\varphi_0=f_0\\\varphi_n=f_n-\sum_{i=0}^{n-1}\frac{(f_n,\varphi_i)}{(\varphi_i,\varphi_i)}\varphi_i\]</span></p><h2 id="直交多项式">直交多项式</h2><p>取线性无关的多项式序列 <spanclass="math inline">\(\{1,x,...,x^n\}\)</span>，称由此通过 <spanclass="math inline">\(Schmidt\)</span>正交化得到的正交函数系为直交多项式 <spanclass="math inline">\(\{p_n(x)\}\)</span> <br>可以证明有递推关系： <spanclass="math display">\[\begin{aligned}&amp;p_{k+1}(x)=(x-\alpha_k)p_k(x)-\beta_kp_{k-1}(x)\\&amp;p_0=1,\:p_{-1}=0\\&amp;其中:\\&amp;\alpha_k=\frac{(xp_k(x),p_k(x))}{(p_k(x),p_k(x))}\\&amp;\beta_k=\left\{\begin{align}&amp;\frac{(p_k(x),p_k(x))}{(p_{k-1}(x),p_{k-1}(x))},k\geq1\\&amp;0,k=0\end{align}\right.\\\end{aligned}\]</span></p><h3 id="chebyshev-多项式"><span class="math inline">\(Chebyshev\)</span>多项式</h3><p>取权函数 <spanclass="math inline">\(W(x)=\frac1{\sqrt{1-x^2}}\)</span>，区间 <spanclass="math inline">\([a,b]=[-1,1]\)</span>，由此得到 <spanclass="math inline">\(Chebyshev\)</span> 多项式，可表示为： <spanclass="math display">\[T_n(x)=cos(n\:arccos\:x)\]</span> 显然，取 <spanclass="math inline">\(x=cos\theta\)</span>，据三角公式就有： <spanclass="math display">\[T_{n\pm1}(x)=cos(n\pm1)\theta=cos(n\theta)cos\theta\mpsin(n\theta)sin\theta\]</span> 两式相加就能得到递推关系： <span class="math display">\[T_{n+1}(x)+T_{n-1}(x)=2xT_n(x)\]</span> 利用 <span class="math inline">\(Euler\)</span>公式，有：<spanclass="math inline">\(cos\:n\theta=\frac{e^{in\theta}+e^{-in\theta}}2\)</span>，由此亦可直接证明：<span class="math display">\[T_n(x)=\frac12\left((x+\sqrt{x^2-1})^n+(x-\sqrt{x^2-1})^n\right)\]</span></p><h4 id="近似最佳一致逼近">近似最佳一致逼近</h4><p>固定 <span class="math inline">\(z&gt;1\)</span>，记 <spanclass="math inline">\(\theta_n \subseteq R[x]_{n+1}\)</span> 为满足条件<span class="math inline">\(\forall p_n \in \theta_n\)</span> ，都有<span class="math inline">\(p_n(z)=1\)</span> 的集合，那么： <spanclass="math display">\[\left\Vert\frac{T_n(x)}{T_n(z)}\right\Vert_\infty=\mathop{inf}_\limits{p_n\in\theta_n}\Vert p_n \Vert_\infty\]</span> 类似地，记 <span class="math inline">\(\bar{T}_n(x)\)</span>为 <span class="math inline">\(T_n(x)\)</span>的首一化多项式，也就是：<spanclass="math inline">\(\bar{T}_n(x)=\frac1{2^{n-1}}T_n(x)\)</span>，那么任给<span class="math inline">\(n\)</span> 次首一多项式 <spanclass="math inline">\(p_n(x)\)</span>，都有： <spanclass="math display">\[\Vertp_n\Vert_\infty\geq\Vert\bar{T}_n\Vert_\infty=\frac1{2^{n-1}}\:\:\:\:(W(x)=1)\]</span> 当且仅当 <span class="math inline">\(p_n=\bar{T}_n\)</span>时取等，这说明要想使得对定义在 <spanclass="math inline">\([-1,1]\)</span> 上的函数 <spanclass="math inline">\(f\)</span> 作 <spanclass="math inline">\(n\)</span>次多项式插值得到的余项较小，可以将插值基点选取为 <spanclass="math inline">\(T_{n+1}(x)\)</span> 的零点，即： <spanclass="math display">\[x_i=cos\frac{(2i+1)\pi}{2(n+1)},i=0,1,...,n\]</span> 对于一般的定义在 <span class="math inline">\([a,b]\)</span>上的函数 <spanclass="math inline">\(f\)</span>，作平移和伸缩变换再类似处理即可，也就是：<span class="math display">\[[a,b]\to[-1,1]:x\to\frac2{b-a}(x-\frac{b-a}2)\\\frac2{b-a}(x_i-\frac{b-a}2)=cos\frac{(2i+1)\pi}{2(n+1)},i=0,1,...,n\]</span></p><p>由此可以得到一个近似的最佳一致逼近多项式，关于最佳一致逼近的具体讨论在后续部分</p><h4 id="第二类-chebyshev-多项式">第二类 <spanclass="math inline">\(Chebyshev\)</span> 多项式</h4><p>与第一类的唯一差别是权函数取为 <spanclass="math inline">\(W(x)=\sqrt{1-x^2}\)</span>，将其记为 <spanclass="math inline">\(\{U_n(x)\}\)</span>，可以表示为： <spanclass="math display">\[U_n(x)=\frac{sin\left((n+1)arccos\:x\right)}{\sqrt{1-x^2}}\]</span> 其与第一类有关系式： <span class="math display">\[T_{n+1}&#39;(x)=(n+1)U_n(x)\]</span></p><h3 id="legendre-多项式"><span class="math inline">\(Legendre\)</span>多项式</h3><p>取最简单的权函数 <span class="math inline">\(W(x)=1\)</span>，区间<span class="math inline">\([a,b]=[-1,1]\)</span>，得 <spanclass="math inline">\(Legendre\)</span> 多项式，可以表示为： <spanclass="math display">\[p_n(x)=\frac1{2^nn!}\frac{d^n}{dx^n}(x^2-1)^n\]</span>其用处在这门课主要体现在<strong>高斯型求积公式</strong>中，此处暂且不谈</p><h2 id="最佳一致逼近">最佳一致逼近</h2><p>取 <span class="math inline">\(W(x)=1\)</span>，设 <spanclass="math inline">\(f\in C[a,b]\)</span>，若有一列函数 <spanclass="math inline">\(\{f_n\}\)</span> 使得： <spanclass="math display">\[\lim_{n\to\infty}\Vert f-f_n\Vert_\infty=0\]</span> 称 <span class="math inline">\(\{f_n\}\)</span> 为 <spanclass="math inline">\(f\)</span> 的一致逼近函数，不难看出也就是在 <spanclass="math inline">\([a,b]\)</span> 上一致收敛于 <spanclass="math inline">\(f\)</span></p><p>我们在数学分析的课程上已经知道 <spanclass="math inline">\(Weierstrass\)</span>给出的关于多项式一致逼近的相关结果，即 <spanclass="math inline">\(\forall \varepsilon&gt;0,\exists p_n(x)\)</span>使得： <span class="math display">\[\Vert f-p_n\Vert_\infty&lt;\varepsilon\]</span> 然而我们知道多项式拟合的次数太高并不好，下面我们固定 <spanclass="math inline">\(n\)</span>，考虑在次数不超过 <spanclass="math inline">\(n\)</span> 的多项式集合 <spanclass="math inline">\(H_n\)</span> 中寻求 <spanclass="math inline">\(p_n\)</span> 使得： <span class="math display">\[\Vert f-p_n\Vert_\infty=\mathop{inf}_\limits{q_n\in H_n}\Vertf-q_n\Vert_\infty\]</span>这就是<strong>最佳一致逼近多项式</strong>问题，关于这个问题，<spanclass="math inline">\(Chebyshev\)</span> 给出了以下结果：</p><ol type="1"><li><p>设 <span class="math inline">\(a\leq x_1&lt;x_2&lt;...&lt;x_n\leqb\)</span>，称 <span class="math inline">\(\{x_1,x_2,...,x_n\}\)</span>为 <span class="math inline">\(f\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 上的交错点组，若满足： <spanclass="math display">\[|f(x_i)|=\mathop{max}_\limits{x\in[a,b]}|f(x)|,\forall i=1,2,...,n\\f(x_i)=-f(x_{i+1}),\forall i=1,2,...,n-1\]</span></p></li><li><p>（<span class="math inline">\(Chebyshev\)</span> 定理）设 <spanclass="math inline">\(p\in H_n\)</span>，则 <spanclass="math inline">\(p\)</span> 是 <spanclass="math inline">\(f\)</span> 的最佳一致逼近多项式当且仅当 <spanclass="math inline">\(f(x)-p(x)\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 上存在 <spanclass="math inline">\(n+2\)</span> 个点组成的交错点组</p></li><li><p>上述 <span class="math inline">\(p(x)\)</span> 在 <spanclass="math inline">\(H_n\)</span> 中是唯一的</p></li><li><p>若 <span class="math inline">\(f^{(n+1)}(x)\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 中不变号，则 <spanclass="math inline">\(a,b\)</span> 属于交错点组</p></li></ol><h2 id="最佳平方逼近">最佳平方逼近</h2><p>与最佳一致逼近类似，只是考虑的范数由 <spanclass="math inline">\(\infty\)</span> 范数改为了 <spanclass="math inline">\(2\)</span> 范数，我们考察一般情形：</p><p>设 <span class="math inline">\(f\in C[a,b],\:\{\varphi_n\}\)</span>为 <span class="math inline">\([a,b]\)</span>上的线性无关函数族，我们希望寻求 <spanclass="math inline">\(a_0,a_1,...,a_n\)</span> 使得： <spanclass="math display">\[\Vert f-\sum_{k=0}^na_k\varphi_k\Vert_2\]</span>达到极小；考察其平方不影响结果，从而可以使用多元函数求极值的办法给出结论：<span class="math display">\[F(a_0,a_1,...,a_n)=\int_a^b\left(f(x)-\sum_{k=0}^na_k\varphi_k(x)\right)^2W(x)dx\\\frac{\partial F}{\partiala_j}=2\int_a^b\left(f(x)-\sum_{k=0}^na_k\varphi_k(x)\right)(-\varphi_j(x))W(x)dx=0\]</span> 也就是： <span class="math display">\[\left(\begin{array}{}(\varphi_0,\varphi_0) &amp; (\varphi_0,\varphi_1) &amp;...&amp;(\varphi_0,\varphi_n)\\(\varphi_1,\varphi_0) &amp; (\varphi_1,\varphi_1) &amp;...&amp;(\varphi_1,\varphi_n)\\... &amp; ... &amp; ... &amp; ... \\(\varphi_n,\varphi_0) &amp; (\varphi_n,\varphi_1) &amp;...&amp;(\varphi_n,\varphi_n)\end{array}\right)\left(\begin{array}{}a_0\\a_1\\...\\a_n\end{array}\right)=\left(\begin{array}{}(f,\varphi_0)\\(f,\varphi_1)\\...\\(f,\varphi_n)\end{array}\right)\]</span> 这被称为<strong>法方程</strong>，据 <spanclass="math inline">\(\{\varphi_n\}\)</span>线性无关知其系数矩阵行列式不为 <spanclass="math inline">\(0\)</span>，从而存在唯一解</p><p>特别地，若 <span class="math inline">\(\{\varphi_n\}\)</span>为正交函数系，则系数矩阵为对角矩阵，进而直接有： <spanclass="math display">\[a_k=\frac{(f,\varphi_k)}{(\varphi_k,\varphi_k)}\]</span> 进一步，如果让 <spanclass="math inline">\(n\to\infty\)</span>，这就给出了 <spanclass="math inline">\(f\)</span> 的广义 <spanclass="math inline">\(Fourier\)</span> 级数</p><p>若正交函数系取为 <span class="math inline">\(Chebyshev\)</span>多项式 <span class="math inline">\(\{T_n(x)\}\)</span>，由此就得到 <spanclass="math inline">\(f\)</span> 在 <spanclass="math inline">\([-1,1]\)</span> 上的 <spanclass="math inline">\(Chebyshev\)</span> 级数： <spanclass="math display">\[f(x)=\frac12a_0+\sum_{n=1}^\infty a_nT_n(x)\\a_k=\frac{(T_k,f)}{(T_k,T_k)}=\frac2\pi\int_{-1}^1T_k(x)f(x)\frac{dx}{\sqrt{1-x^2}}\]</span></p><h3 id="离散情形">离散情形</h3><p>与连续情形类似，若已知 <span class="math inline">\(f\)</span>在给定点集 <span class="math inline">\(\{x_1,x_2,...,x_m\}\)</span>上的值，记： <span class="math display">\[r_i=\sum_{j=0}^na_j\varphi_j(x_i)-f(x_i)\]</span> 为<strong>残量</strong>，亦可寻求 <spanclass="math inline">\(a_0,a_1,...,a_n\)</span> 使得： <spanclass="math display">\[\sum_{i=0}^mr_i^2\]</span>达到极小，这样的问题被称为<strong>离散的最佳平方逼近问题</strong>，也就是<strong>线性最小二乘拟合问题</strong>，在后续部分讨论</p><p>在等距点集情形，我们有著名的 <strong>DFT</strong> 以及<strong>FFT</strong>，此前已作过其浅析，详见：<ahref="https://dasasdhba.github.io/study-FFT/"class="uri">https://dasasdhba.github.io/study-FFT/</a></p><h1 id="数据拟合">数据拟合</h1><p>数据拟合问题是指寻求一函数 <span class="math inline">\(f(x)\)</span>来拟合一组离散数据 <spanclass="math inline">\(\{(x_i,y_i)\}_{i=1}^m\)</span>，与插值法不同，我们采用<strong>均方误差</strong>（mean-squareerror MSE）来衡量拟合的好坏，也就是考虑： <span class="math display">\[\mathcal{L}(f)=\frac1m\sum_{i=1}^m(f(x_i)-y_i)^2\]</span> 一般地，给定函数族 <spanclass="math inline">\(\mathcal{F}\)</span>，我们试图求解 <spanclass="math inline">\(f\in\mathcal{F}\)</span> 使得： <spanclass="math display">\[\mathcal{L}(f)=\mathop{inf}_\limits{g\in\mathcal{F}}\mathcal{L}(g)\]</span></p><h2 id="线性拟合">线性拟合</h2><p>下面介绍线性拟合的<strong>最小二乘法</strong>，这与最佳平方逼近是类似的</p><p>设 <span class="math inline">\(f\in C[a,b],\:\{\varphi_n\}\)</span>为 <span class="math inline">\([a,b]\)</span>上的线性无关函数族，我们希望寻求 <spanclass="math inline">\(a_0,a_1,...,a_n\)</span> 使得： <spanclass="math display">\[\varphi(x)=\sum_{j=0}^na_j\varphi_j\\\mathcal{L}(\varphi)=\frac1m\sum_{i=1}^m(\varphi(x_i)-y_i)^2\]</span> 达到极小；类似地，可以使用多元微积分求极值的理论： <spanclass="math display">\[F(a_0,...,a_n)=\sum_{i=1}^m(\sum_{j=0}^na_j\varphi_j(x_i)-y_i)^2\\\frac{\partial F}{\partiala_k}=2\sum_{i=1}^m\varphi_k(x_i)(\sum_{j=0}^na_j\varphi_j(x_i)-y_i)=0\]</span> 记 <spanclass="math inline">\(Y=(y_1,...,y_m)^T,\:\Phi_i=(\varphi_i(x_1),...,\varphi_i(x_m))^T\)</span>，取<span class="math inline">\(\mathbb{R}^m\)</span> 这个 <spanclass="math inline">\(Euclid\)</span> 空间的通常内积 <spanclass="math inline">\((X,Y)=X^TY\)</span>，则上述方程可以改写为： <spanclass="math display">\[\left(\begin{array}{}(\Phi_0,\Phi_0) &amp; (\Phi_0,\Phi_1) &amp;... &amp;(\Phi_0,\Phi_n)\\(\Phi_1,\Phi_0) &amp; (\Phi_1,\Phi_1) &amp;... &amp;(\Phi_1,\Phi_n)\\... &amp; ... &amp; ... &amp; ... \\(\Phi_n,\Phi_0) &amp; (\Phi_n,\Phi_1) &amp;... &amp;(\Phi_n,\Phi_n)\end{array}\right)\left(\begin{array}{}a_0\\a_1\\...\\a_n\end{array}\right)=\left(\begin{array}{}(Y,\Phi_0)\\(Y,\Phi_1)\\...\\(Y,\Phi_n)\end{array}\right)\]</span> 由此即可解出 <spanclass="math inline">\(a_0,...,a_n\)</span>；特别地，若取 <spanclass="math inline">\(n=1,\varphi_0(x)=1,\varphi_1(x)=x\)</span>，得到： <spanclass="math display">\[\begin{aligned}&amp;\left\{\begin{align}&amp;a_1=\frac{(\Phi_1,Y)-m\bar{x}\bar{y}}{(\Phi_1,\Phi_1)-m\bar{x}\bar{y}}=\frac{\sum_{i=1}^m(x_i-\bar{x})(y_i-\bar{y})}{\sum_{i=1}^m(x_i-\bar{x})^2}\\&amp;a_0=\bar{y}-a_1\bar{x}\\\end{align}\right.\\&amp;其中:\\&amp;\bar{x}=\sum_{i=1}^mx_i,\:\bar{y}=\sum_{i=1}^my_i\end{aligned}\]</span> 即中学阶段已经介绍过的最小二乘法求解回归直线方程</p><h3 id="过拟合现象">过拟合现象</h3><p>若取 <spanclass="math inline">\(\{\varphi_n\}=\{x^n\}\)</span>，直观上 <spanclass="math inline">\(n\)</span> 越大误差越小，然而与 <spanclass="math inline">\(Runge\)</span>现象类似，过高的拟合次数会产生<strong>过拟合现象</strong></p><h2 id="非线性拟合">非线性拟合</h2><p>非线性拟合是考虑用不能被一族函数的线性组合所表出的函数作拟合，如：<span class="math display">\[f(x)=\frac a{1+be^{cx}}\]</span> 我们的目标是寻求待定系数 <spanclass="math inline">\(a,b,c\)</span> 使得 <spanclass="math inline">\(\mathcal{L}(f)\)</span> 达到极小</p><h3 id="线性化求近似解">线性化求近似解</h3><p>若有一向量值函数 <span class="math inline">\(F:\mathbb{R}^2 \to\mathbb{R}^2\)</span> 使得 <spanclass="math inline">\(\{F(x_i,y_i)\}_{i=1}^m\)</span>可以用一族函数的线性组合来拟合，则可以使用线性拟合的办法求近似解<br>（化曲为直）</p><p>举例，若离散数据符合非线性函数： <span class="math display">\[y=\frac1{1+ae^{bx}}\]</span> 这可以改写为： <span class="math display">\[ln\left(\frac 1y-1\right)=bx+ln\:a\]</span> 这就把问题转换为了线性拟合，注意到由此得到的是： <spanclass="math display">\[\bar{\mathcal{L}}(a,b)=\frac1m\sum_{i=0}^m\left|bx_i+lna-ln\left(\frac1y_i-1\right)\right|^2\]</span> 达到极小，故这是原非线性拟合问题的一个近似解</p><h3 id="梯度下降法">梯度下降法</h3><p>考虑使用非线性函数 <spanclass="math inline">\(f(x;a_1,...,a_n)\)</span> 作非线性拟合，其中 <spanclass="math inline">\(a_1,...,a_n\)</span>为待定系数，我们试图寻求待定系数使得： <span class="math display">\[F(a_1,...,a_n)=\mathcal{L}(f(x;a_1,...,a_n))\]</span> 达到极小；据多元微积分理论，<spanclass="math inline">\(\forall a \in \mathbb{R}^n\)</span>，<spanclass="math inline">\(F\)</span> 在 <spanclass="math inline">\(a\)</span> 处沿着梯度方向变化最快，其中梯度是指：<span class="math display">\[\nabla F(a)=\left(\frac{\partial F}{\partial a_1},...,\frac{\partialF}{\partial a_n}\right)(a)\]</span> （方便起见，这里没有加上转置符号）</p><p>因而可以通过从某一初值 <span class="math inline">\(a\)</span>开始，沿着梯度方向不断迭代的办法近似求解 <spanclass="math inline">\(F\)</span>的极小值点，这被称为<strong>梯度下降法</strong>，算法如下： <spanclass="math display">\[\begin{aligned}&amp;a=(b_1,...,b_n)\:为初值\\&amp;\eta=10^{-4}\:为步长，又称学习率\\&amp;\varepsilon=10^{-8}\:为终止条件\\\\&amp;while\;\Vert\nabla F(a)\Vert_2 \geq \varepsilon:\\&amp;\;\;\;\;a=a-\eta\:\nabla F(a)\end{aligned}\]</span> 其中 <span class="math inline">\(\eta\)</span>的选取至关重要，太大没法收敛，太小收敛太慢；另一方面，这种算法显然只能得到局部极小值，不能保证其为全局极小值点，因而适当的选取初值也较为重要，可以通过线性化先求解一近似解作为初值</p><h1 id="数值微积分">数值微积分</h1><p>假设需要处理的函数十分复杂，又或者我们只知道一些离散点 <spanclass="math inline">\(\{x_n,y_n\}\)</span>的数据，此时需要考察求解微分以及积分的近似值的方法。</p><h2 id="数值微分">数值微分</h2><p>数值微分比较容易，因为只需要近似求解一个极限，下面记需要考察的函数为<span class="math inline">\(f\)</span></p><h3 id="差商法">差商法</h3><p>据定义，可直接取 <spanclass="math inline">\(\frac{f(x+h)-f(x)}h\)</span>作为近似值，即向前差商法；同理还有向后差商法和中心差商法。</p><p>以向前差商法为例考察误差，据 <spanclass="math inline">\(Taylor\)</span> 展开，有： <spanclass="math display">\[f(x+h)=f(x)+hf&#39;(x)+\frac{h^2}{2!}f&#39;&#39;(\xi)\]</span> 由此不难看出误差为 <spanclass="math inline">\(O(h)\)</span></p><h3 id="插值法-1">插值法</h3><p>取插值函数 <span class="math inline">\(L(x)\simeqf(x)\)</span>，并以插值函数的导数作为近似的方法<br>之前已讨论过插值函数的误差，从而不难估计此法的误差</p><h2 id="数值积分">数值积分</h2><p>假设我们只知道离散点 <spanclass="math inline">\(\{x_n,f(x_n)\}\)</span> 的数据，我们尝试考察 <spanclass="math inline">\(f\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 上关于权函数 <spanclass="math inline">\(W(x)\)</span> 的积分： <spanclass="math display">\[I(f)=\int_a^bf(x)W(x)dx\]</span> 称基于这些数据给出的公式： <span class="math display">\[I_n(f)=\sum_{i=0}^na_if(x_i)\]</span> 为<strong>数值积分公式</strong>，其中 <spanclass="math inline">\(a_i\)</span> 为待定系数。为衡量公式的精确度，称<span class="math inline">\(I_n(f)\)</span> 有 <strong>k阶代数精度</strong>，若： <span class="math display">\[I_n(x^i)=I(x_i),i=0,1,...,k,\:I_n(x^{k+1})\neq I(x^{k+1})\]</span></p><h3 id="插值法-2">插值法</h3><p>与数值微分不同，若想直接使用积分定义作近似，作 <spanclass="math inline">\(Riemann\)</span> 和难以估计误差，而以 <spanclass="math inline">\(Lebesgue\)</span>积分的观点来考察简单函数的逼近则更加困难，因而数值积分基本上只有插值法。以<span class="math inline">\(Lagrange\)</span> 插值为例： <spanclass="math display">\[I_n(f)=\int_a^bL_n(x)W(x)dx=\sum_{i=0}^n\left(\int_a^bl_i(x)W(x)dx\right)f(x_i)\]</span> 据 <span class="math inline">\(Lagrange\)</span>插值的性质，不难看出此法的代数精度至少为 <spanclass="math inline">\(n\)</span>，误差由插值函数的误差作积分给出</p><h2 id="函数的数值积分">函数的数值积分</h2><p>与之前讨论的仅知道离散点数据的情形不同，以下假设我们需要考察的被积函数<span class="math inline">\(f\)</span> 为已知函数，积分区间为 <spanclass="math inline">\([a,b]\)</span><br>尽管仍然只能采取插值法，然而我们可以自由地选取插值基点，由此可以深入研究各种方法</p><h3 id="newton-cotes-求积公式">Newton-Cotes 求积公式</h3><p>我们考察 <span class="math inline">\(W(x)=1\)</span>，插值基点为<span class="math inline">\(n+1\)</span> 个等距基点（步长 <spanclass="math inline">\(h=\frac{b-a}n\)</span>）的情形，此时有： <spanclass="math display">\[a_i=\int_a^bl_i(x)=\frac {(-1)^{n+1-i}\;h}{(i-1)!(n+1-i)!}\int_0^n\prod_{j=0,j\neq i-1}^n(t-j)dt\]</span> 若 <span class="math inline">\(n\)</span> 为偶数，且 <spanclass="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 上有 <spanclass="math inline">\(n+2\)</span> 阶连续导数，那么误差： <spanclass="math display">\[E_n(f)=\frac{h^{n+3}f^{(n+2)}(\eta)}{(n+2)!}\int_0^nt\prod_{j=0}^n(t-j)dt\]</span> 若 <span class="math inline">\(n\)</span> 为奇数，且 <spanclass="math inline">\(f(x)\)</span> 在 <spanclass="math inline">\([a,b]\)</span> 上有 <spanclass="math inline">\(n+1\)</span> 阶连续导数，那么误差： <spanclass="math display">\[E_n(f)=\frac{h^{n+2}f^{(n+1)}(\eta)}{(n+1)!}\int_0^nt\prod_{j=0}^n(t-j)dt\]</span> 还需要考虑舍入误差可能带来的数值不稳定性，有估计： <spanclass="math inline">\(|I_n(f)-I_n^*(f)|\leq\varepsilon\sum_{i=0}^n|a_i|\)</span>，其中<span class="math inline">\(\varepsilon\)</span> 为最大的舍入误差<br>取<span class="math inline">\(f(x)=1\)</span>，此时若 <spanclass="math inline">\(n\geq8\)</span>，那么存在 <spanclass="math inline">\(a_i&lt;0\)</span>，这会使得数值不稳定</p><p>通常我们只采用 <span class="math inline">\(n=1\)</span> 或 <spanclass="math inline">\(n=2\)</span>的情形（原因见下节），这分别对应<strong>梯形公式</strong>与<strong><span class="math inline">\(Simpson\)</span> 公式</strong></p><ul><li><p>梯形公式：<spanclass="math inline">\(I_1(f)=\frac{b-a}2(f(a)+f(b))\)</span></p><p>直观上，这是以梯形面积作为近似，因而叫梯形公式</p></li><li><p><span class="math inline">\(Simpson\)</span> 公式：<spanclass="math inline">\(I_2(f)=\frac{b-a}6\left(f(a)+4f(\frac{a+b}2)+f(b)\right)\)</span></p><p>直观上，这是以两端以及中点所作抛物线的面积作为近似，因而也叫抛物线公式</p></li></ul><h3 id="复合求积公式">复合求积公式</h3><p>前已述不能考虑通过提高 <spanclass="math inline">\(Newton-Cotes\)</span>求积公式的阶数来减少误差，而另一方面，积分具有区间可加性，这启发我们将<span class="math inline">\([a,b]\)</span>分成若干小段，并对每一段分别使用梯形公式或 <spanclass="math inline">\(Simpson\)</span>公式再求和，这就是复合求积公式。</p><p>下面考虑将 <span class="math inline">\([a,b]\)</span> 分为 <spanclass="math inline">\(n\)</span> 段，进而步长为 <spanclass="math inline">\(h=\frac{b-a}n\)</span>，为了衡量复合求积公式的精确度，称公式<span class="math inline">\(p\)</span> 阶收敛，若： <spanclass="math display">\[\lim_{h\to0}\frac{I(f)-I_n(f)}{h^p}=C&lt;\infty,\:C\neq0\]</span> 下面分别考虑使用梯形公式和 <spanclass="math inline">\(Simpson\)</span> 公式作复合求积：</p><ul><li><p>复合梯形公式：<span class="math inline">\(T_n(f)=\frach2(f(a)+f(b)+2\sum_{i=1}^{n-1}f(a+ih))\)</span></p><p>误差：<spanclass="math inline">\(E_n(f)=-\frac{h^2(b-a)}{12}f&#39;&#39;(\xi)\)</span>，因而是<span class="math inline">\(2\)</span> 阶收敛的</p></li><li><p>复合 <span class="math inline">\(Simpson\)</span> 公式（为统一<span class="math inline">\(h\)</span> 的值，假定 <spanclass="math inline">\(n\)</span> 为偶数，将 <spanclass="math inline">\([a,b]\)</span> 分为 <spanclass="math inline">\(m=\frac n2\)</span> 段）： <spanclass="math display">\[S_n(f)=\frach3\left(f(a)+f(b)+4\sum_{i=1}^mf(a+(2i-1)h)+2\sum_{i=1}^{m-1}f(a+2ih)\right)\]</span> 误差：<spanclass="math inline">\(E_m(f)=-\frac{h^4(b-a)}{180}f^{(4)}(\xi)\)</span>，因而是<span class="math inline">\(4\)</span> 阶收敛的</p></li></ul><p>可见，使用复合求积公式，只要通过控制 <spanclass="math inline">\(h\)</span>，就可以有效地控制误差，因而我们并不需要使用高阶的<span class="math inline">\(Newton-Cotes\)</span> 求积公式<br></p><h3 id="区间逐次分半法">区间逐次分半法</h3><p>书接上回，使用复合求积公式时，若想控制误差界为给定的 <spanclass="math inline">\(\varepsilon\)</span>，由其误差估计式，往往需要考察<span class="math inline">\(f\)</span> 的高阶导数，这会带来麻烦。</p><p>为此，常使用一种被称为<strong>区间逐次分半</strong>的办法——不断将区间二分，直到达到精度要求</p><p>由于我们不希望直接考察误差估计式，常常采用以下办法近似（以复合梯形公式为例）：<br>我们知道：<span class="math display">\[E_n(f)=I(f)-T_n(f)=-\frac{h^2(b-a)^3}{12n^2}f&#39;&#39;(\xi_1)\\E_{2n}(f)=I(f)-T_{2n}(f)=-\frac{h^2(b-a)^3}{12\times4n^2}f&#39;&#39;(\xi_2)\]</span> 如果我们认为：<spanclass="math inline">\(f&#39;&#39;(\xi_1)\simeqf&#39;&#39;(\xi_2)\)</span>，那么 <spanclass="math inline">\(E_n(f)\simeq 4E_{2n}(f)\)</span>，由此可以推出：<span class="math display">\[E_{2n}(f)\simeq \frac13(T_{2n}(f)-T_n(f))\]</span> 这样，我们就回避了直接考察 <spanclass="math inline">\(f&#39;&#39;\)</span></p><p>另一方面，若记 <span class="math inline">\(n=2^{m-1}\)</span> ，即将<span class="math inline">\([a,b]\)</span> 作 <spanclass="math inline">\(2^{m-1}\)</span> 等分，记由此得到的梯形值为 <spanclass="math inline">\(T_{m,1}\)</span>（下标与 <spanclass="math inline">\(T_n\)</span> 作区分，无其他含义），那么： <spanclass="math display">\[T_{m,1}=\frac12\left(T_{m-1,1}+h_{m-1}\sum_{k=1}^{2^{m-2}}f(a+(k-\frac12)h_{m-1})\right)\\h_m=\frac{b-a}{2^{m-1}}\]</span> 即每一次半分时存在递推关系，降低了计算量；事实上，后面会介绍<span class="math inline">\(Romberg\)</span>积分法，想法与此十分相似</p><h3 id="自适应积分法">自适应积分法</h3><p>在区间逐次分半法中，每次我们都将区间的等分数量翻倍，尽管有递推式，但这样做仍然会导致速度较慢。<br>然而事实上，我们可以将需要控制的误差界<span class="math inline">\(\varepsilon\)</span> 在等分的 <spanclass="math inline">\(n\)</span>个区间上分别考虑，<br>只要每个区间上的误差都不超过 <spanclass="math inline">\(\frac\varepsilonn\)</span>，那么也能达到同样的目的</p><p>这样，我们只需要对那些误差超过 <spanclass="math inline">\(\frac\varepsilon n\)</span>的区间应用逐次分半法，这就是<strong>自适应积分法</strong>。<br>不难看出，这种办法很适合递归实现：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">self_adaptive_integral</span><span class="params">(f,a,b,eps)</span></span></span><br><span class="line"><span class="keyword">if</span> numeric_integral_err(f,a,b) &lt; <span class="built_in">eps</span></span><br><span class="line">y = numeric_integral(f,a,b);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">c = (a+b)/<span class="number">2</span>;</span><br><span class="line">y = self_adaptive_integral(f,a,c,<span class="built_in">eps</span>/<span class="number">2</span>) + self_adaptive_integral(f,c,b,<span class="built_in">eps</span>/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中 <code>numeric_integral()</code>是某个数值积分公式，<code>numeric_integral_err()</code>往往类似于区间逐次分半法中的误差估计方法</p><p>需要指出的是，由于分半的过程中，各个区间需要处理的误差界也在减半，因而此法容易陷入无限递归，应当加上递归层数的限制</p><h3 id="euler-maclaurin-公式"><spanclass="math inline">\(Euler-Maclaurin\)</span> 公式</h3><p>后面会稍微用到，但用得不多，故只给出相关结果，证明略</p><p>记 <span class="math inline">\(B_n\)</span> 为 <spanclass="math inline">\(Bernoulli\)</span> 数，这是由：<spanclass="math inline">\(\frac{x}{e^x-1}=\sum_{n=0}^\infty\frac{B_n}{n!}x^n\)</span> 给出的，显式公式为： <spanclass="math display">\[B_n=\sum_{k=0}^n\frac1{k+1}\sum_{r=0}^kC_k^r(-1)^rr^n\]</span> 设 <span class="math inline">\(a,b\in\mathbb{N},\:f\inC^\infty[a,b]\)</span>，那么有 <spanclass="math inline">\(Euler-Maclaurin\)</span> 公式： <spanclass="math display">\[\sum_{n=a}^bf(n)-\int_a^bf(x)dx=\frac12(f(a)+f(b))+\sum_{n=1}^\infty\frac{B_{2n}}{2n!}(f^{(2n-1)}(b)-f^{(2n-1)}(a))\]</span> （简单来说就是利用 <spanclass="math inline">\(Bernoulli\)</span>多项式的性质反复分部积分得到的）</p><p>一般地，若 <span class="math inline">\(f\inC^k[a,b]\)</span>，那么同样有： <span class="math display">\[\sum_{n=a}^bf(n)-\int_a^bf(x)dx=\frac12(f(a)+f(b))+\sum_{n=2}^{k-1}\frac{B_{n}}{n!}(f^{(n-1)}(b)-f^{(n-1)}(a))+R_k(f)\]</span> 为了描述余项，需要引入 <spanclass="math inline">\(Bernoulli\)</span> 多项式，类似地，这由：<spanclass="math inline">\(\frac{te^{tx}}{e^t-1}=\sum_{n=0}^\inftyB_n(x)\frac{t^n}{n!}\)</span> 给出，有显式公式： <spanclass="math display">\[B_n(x)=(B+x)^n\]</span> 其中 <span class="math inline">\(B^k=B_k\)</span> 为 <spanclass="math inline">\(Bernoulli\)</span> 数（只是个方便的记号，<spanclass="math inline">\(B\)</span> 并不是一个数）</p><p>于是，记 <span class="math inline">\(\{x\}=x-[x]\)</span> 为 <spanclass="math inline">\(x\)</span> 的小数部分，那么余项就可以写为： <spanclass="math display">\[R_k(f)=(-1)^{k-1}\int_a^b\frac{B_k(\{x\})}{k!}f^{(k)}(x)dx\]</span> 对于 <span class="math inline">\(a,b\in\mathbb{R}\)</span>的情形，可以固定 <span class="math inline">\(n\in\mathbb{N}\)</span>，由<span class="math inline">\(x\to \frac{b-a}nx+a\)</span> 将 <spanclass="math inline">\([0,n]\to[a,b]\)</span>，再使用上述公式</p><p>如果记 <spanclass="math inline">\(h=\frac{b-a}n\)</span>，整理可以得到： <spanclass="math display">\[\sum_{i=0}^nhf(a+ih)-\int_a^bf(x)dx=\frac h2(f(a)+f(b))+\sum_{m=2}^{k-1}\frac{B_{m}}{m!}h^{m}(f^{(m-1)}(b)-f^{(m-1)}(a))+R_k(f)\\R_k(f)=(-1)^{k-1}h^k\int_a^b\frac{B_k(\{\frac{x-a}h\})}{k!}f^{(k)}(x)dx\]</span></p><p>注意， <span class="math inline">\(\sum_{i=0}^nhf(a+ih)-\frach2(f(a)+f(b))\)</span> 恰为复合梯形公式！<br>故 <spanclass="math inline">\(Euler-Maclaurin\)</span>公式事实上给出了复合梯形公式的一个极为精确的误差估计</p><h3 id="romberg-积分法"><span class="math inline">\(Romberg\)</span>积分法</h3><p>沿用区间逐次分半法的相关记号，将 <spanclass="math inline">\([a,b]\)</span> 作 <spanclass="math inline">\(2^{m-1}\)</span> 等分，记由此得到的梯形值为 <spanclass="math inline">\(T_{m,1}\)</span></p><p><span class="math inline">\(Romberg\)</span> 积分法实质上是利用 <spanclass="math inline">\(Euler-Maclaurin\)</span>公式对此做了改进，从而大大加快了收敛速度<br>事实上，据 <spanclass="math inline">\(Euler-Maclaurin\)</span> 公式，有： <spanclass="math display">\[I(f)-T_{m,1}=a_2h^2+a_4h^4+O(h^6)\]</span> 其中 <span class="math inline">\(a_2,a_4\)</span> 只与 <spanclass="math inline">\(f\)</span> 在 <spanclass="math inline">\(a,b\)</span> 处的相关导数值有关，若进一步考察<span class="math inline">\(T_{m-1,1}\)</span>，有： <spanclass="math display">\[I(f)-T_{m-1,1}=2^2a_2h^2+2^4a_4h^4+O(h^6)\]</span> 由此，我们容易消去误差中的 <spanclass="math inline">\(h^2\)</span> 项，从而直接将误差缩小至 <spanclass="math inline">\(O(h^4)\)</span>！<br>我们记： <spanclass="math display">\[T_{m,2}=\frac{4T_{m,1}-T_{m-1,1}}{3}\]</span> （不难验证，这恰为复合 <spanclass="math inline">\(Simpson\)</span> 公式）</p><p>仿此，可以继续考虑： <span class="math display">\[I(f)-T_{m,2}=b_4h^4+b_6h^6+O(h^8)\\I(f)-T_{m-1,2}=2^4b_4h^4+2^6b_6h^6+O(h^8)\\\Rightarrow T_{m,3}=\frac{16T_{m,2}-T_{m-1,2}}{15}\]</span> 一般地，有： <span class="math display">\[T_{m,j}=\frac{4^{j-1}T_{m,j-1}-T_{m-1,j-1}}{4^{j-1}-1}\]</span> 再结合区间逐次分半法中提到的递推式： <spanclass="math display">\[T_{m,1}=\frac12\left(T_{m-1,1}+h_{m-1}\sum_{k=1}^{2^{m-2}}f(a+(k-\frac12)h_{m-1})\right)\\T_{1,1}=\frac{h_1}2(f(a)+f(b)),\;h_m=\frac{b-a}{2^{m-1}}\]</span> 这就给出了 <span class="math inline">\(Romberg\)</span>积分法，计算顺序呈三角式，也就是： <span class="math display">\[\begin{aligned}&amp;T_{1,1}\\&amp;T_{2,1} &amp;T_{2,2}\\&amp;T_{3,1} &amp;T_{3,2} &amp;&amp;T_{3,3}\\&amp;...\end{aligned}\]</span></p><h3 id="gauss-求积公式"><span class="math inline">\(Gauss\)</span>求积公式</h3><p>到目前为止，我们的讨论大都基于 <spanclass="math inline">\(Newton-Cotes\)</span>求积公式——一个选取等距基点的方法</p><p>一个自然的问题是，若选取一些特殊的基点作插值，是否可以达到更好的效果？这就是<span class="math inline">\(Gauss\)</span> 求积公式要讨论的问题</p><p>之前已经讨论过，<span class="math inline">\(n+1\)</span> 个插值基点<span class="math inline">\(a\leq x_0&lt;x_1&lt;...&lt;x_n\leqb\)</span> 给出的求积公式： <span class="math display">\[I_n(f)=\int_a^bL_n(x)W(x)dx=\sum_{i=0}^n\left(\int_a^bl_i(x)W(x)dx\right)f(x_i)\]</span> 的代数精度至少为 <spanclass="math inline">\(n\)</span>，如果记 <spanclass="math inline">\(\omega_{n+1}(x)=\prod_{i=0}^n(x-x_i)\)</span>，则上式又可以写为：<span class="math display">\[I_n(f)=\sum_{i=0}^n\left(\int_a^b\frac{\omega_{n+1}(x)}{(x-x_i)\omega&#39;_{n+1}(x)}W(x_i)dx\right)f(x_i)\]</span> 可以证明，上述求积公式的代数精度至多是 <spanclass="math inline">\(2n+1\)</span>，且达到 <spanclass="math inline">\(2n+1\)</span> 的充分必要条件为：</p><p><span class="math inline">\(\omega_{n+1}(x)\)</span> 与不高于 <spanclass="math inline">\(n\)</span> 次的任何多项式都关于区间 <spanclass="math inline">\([a,b]\)</span> 上的权函数 <spanclass="math inline">\(W(x)\)</span> 直交</p><p>事实上，如果 <span class="math inline">\(p(x)\)</span> 为一个不高于<span class="math inline">\(2n+1\)</span> 次的多项式，由带余除法： <spanclass="math display">\[p(x)=q(x)\omega_{n+1}(x)+r(x)\]</span> 再结合直交的条件就不难看出结论成立</p><p>一般地，我们称选取了 <span class="math inline">\(n+1\)</span>个插值基点的求积公式为 <span class="math inline">\(Gauss\)</span>型求积公式，若其代数精度为 <span class="math inline">\(2n+1\)</span></p><p>下面我们简单考虑其误差，因为代数精度为 <spanclass="math inline">\(2n+1\)</span>，可选 <spanclass="math inline">\(Hermite\)</span> 插值逼近 <spanclass="math inline">\(f\)</span> 来作误差估计，由此可以证明离散误差为：<span class="math display">\[E_n(f)=Cf^{(2n+2)}(\xi)\\C=\frac{d^2}{(2n+2)!}\int_a^bp^2_{n+1}(x)dx\]</span> 其中，<span class="math inline">\(p_{n+1}(x)\)</span> 为 <spanclass="math inline">\([a,b]\)</span> 上关于权函数 <spanclass="math inline">\(W(x)\)</span> 的 <spanclass="math inline">\(n+1\)</span> 次直交多项式，<spanclass="math inline">\(d\)</span> 为 <spanclass="math inline">\(p_{n+1}(x)\)</span> 首项系数的倒数</p><p>下面我们讨论几个特殊情形：</p><ul><li><p><spanclass="math inline">\([a,b]=[-1,1],\;W(x)=1\)</span>，我们知道此时直交多项式为<span class="math inline">\(Legendre\)</span> 多项式，取 <spanclass="math inline">\(n=1\)</span>，有 <spanclass="math inline">\(P_2(x)=\frac12(3x^2-1)\)</span></p><p>因而只要取 <span class="math inline">\(P_2(x)\)</span> 的两个根 <spanclass="math inline">\(x=\pm\frac1{\sqrt{3}}\)</span>为插值基点，就得到代数精度为 <span class="math inline">\(3\)</span>的插值公式 <span class="math display">\[\int_{-1}^1f(x)dx\simeq f(-\frac1{\sqrt{3}})+f(\frac1{\sqrt{3}})\]</span></p><p>称为 <span class="math inline">\(Gauss-Legendre\)</span>两点公式，离散误差 <spanclass="math inline">\(E_1(f)=\frac1{135}f^{(4)}(\xi)\)</span></p></li><li><p><spanclass="math inline">\([a,b]=[-1,1],\;W(x)=\frac1{\sqrt{1-x^2}}\)</span>，我们知道此时直交多项式为<span class="math inline">\(Chebyshev\)</span> 多项式 <spanclass="math inline">\(T_{n+1}(x)=cos((n+1)arccos\:x)\)</span>因而只要取插值基点为 <spanclass="math inline">\(x_i=cos\left(\frac{2i-1}{2(n+1)}\pi\right),\;i=1,2,...,n+1\)</span>，就得到<span class="math inline">\(Gauss-Chebyshev\)</span> 求积公式</p><p>利用 <span class="math inline">\(Chebyshev\)</span>多项式的相关性质，化简后的最终结果为： <span class="math display">\[\int_{-1}^1f(x)\frac{dx}{\sqrt{1-x^2}}\simeq\frac{\pi}{n+1}\sum_{k=1}^{n+1}f(x_i)\]</span></p></li></ul><p>对于一般的情形，我们可以仿照复合求积公式的想法，首先将 <spanclass="math inline">\([a,b]\)</span>等分为若干小区间，然后在每个小区间上通过积分变换将其变换为 <spanclass="math inline">\([-1,1]\)</span> 上的积分，应用上述公式即可</p><h2 id="重积分与广义积分">重积分与广义积分</h2><p>重积分只要处理为累次积分，就可以导出类似的积分公式（当然，概率论上有一个著名的重积分计算方法，不过此处不作介绍）</p><p>广义积分通常有两种办法处理，一是使用 <spanclass="math inline">\(Gauss\)</span>型求积公式，只需要寻找相关的直交多项式；二是截断法，我们知道广义积分收敛的必要条件是在奇点附近的积分趋于<spanclass="math inline">\(0\)</span>，从求解近似解的角度来讲，直接截去即可</p><h1 id="ode-初值问题数值解">ODE 初值问题数值解</h1><p>给定一个存在唯一解的 ODE 初值问题：</p><p><span class="math display">\[\left\{\begin{aligned}&amp;y&#39;=f(t,y),\;a\leq t \leq b\\&amp;y(a)=\eta\end{aligned}\right.\]</span></p><p>称在一系列离散点 <spanclass="math inline">\(t_0,t_1,...,,t_n\)</span> 处的近似值 <spanclass="math inline">\(y_0,y_1,...,y_n\)</span>为该问题的数值解（称为离散变量法）</p><p>通常采用递推的方法，假定我们已知 <spanclass="math inline">\(y_0,y_1,...,y_{k-1}\)</span>，我们设计算法：<spanclass="math inline">\(y_k\simeq\varphi(y_0,y_1,...,y_k)\)</span><br>注意，算法两边可能同时出现 <spanclass="math inline">\(y_k\)</span>，这种情况我们称方法是隐式的（即需要解方程），否则是显式的</p><p>通常，我们有三种思路：</p><ul><li><p>差商代替倒数，即：<span class="math inline">\(y&#39;(t_k)\simeq\frac{y(t_{k+1})-y(t_k)}{h_k},\:h_k=t_{k+1}-t_k\)</span>，于是： <spanclass="math display">\[y(t_{k+1})\simeq y(t_k)+h_kf(t_k,y(t_k))\]</span> 这被称为 <span class="math inline">\(Euler\)</span>法</p></li><li><p><span class="math inline">\(Taylor\)</span>级数法：取等距离散点，步长 <spanclass="math inline">\(h=t_k-t_{k-1}\)</span>，视 <spanclass="math inline">\(y(t+h)\)</span> 为关于 <spanclass="math inline">\(h\)</span> 的函数，考察 <spanclass="math inline">\(h=0\)</span> 处的 <spanclass="math inline">\(Taylor\)</span> 展开： <spanclass="math display">\[\begin{aligned}&amp;y(t+h)=y(t)+hy&#39;(t)+\frac12h^2y&#39;&#39;(t)+\frac1{3!}h^3y&#39;&#39;&#39;(t)+...+\frac1{p!}h^py^{(p)}(t)+\frac1{(p+1)!}h^{p+1}y^{(p+1)}(\xi)\\&amp;=y(t)+hf(t,y)+\frac12h^2\frac d{dt}f(t,y)+\frac1{3!}h^3\frac{d^2}{dt^2}f(t,y)+...+\frac1{(p+1)!}h^{p+1}\frac{d^{p}}{dt^{p}}f(\xi,y(\xi))\end{aligned}\]</span> 截去余项就得到递推公式，不难看出 <spanclass="math inline">\(p=1\)</span> 时这就是 <spanclass="math inline">\(Euler\)</span> 法</p></li><li><p>数值积分法：<spanclass="math inline">\(y(t_{k+1})-y(t_k)=\int_{t_k}^{t_{k+1}}f(t,y)dt\)</span>，将右边替换为数值积分公式即可</p></li></ul><p>为了研究误差，可以假定 <spanclass="math inline">\(y_0,y_1,...,y_{k-1}\)</span>是精确的，称这种情况下算法 <spanclass="math inline">\(\varphi(y_0,y_1,...,y_k)\)</span>的误差为<strong>局部离散误差</strong><br>记 <spanclass="math inline">\(h_k=t_{k+1}-t_{k}\)</span>，我们称算法为 <spanclass="math inline">\(p\)</span> 阶方法，若 <spanclass="math inline">\(y_{k+1}\)</span> 的局部离散误差为 <spanclass="math inline">\(O^*(h_k^{p+1})\)</span></p><p>从整体上来看，我们称 <span class="math inline">\(y_n\)</span>与其精确解之间的误差为<strong>整体离散误差</strong></p><h2 id="单步法">单步法</h2><p>单步法是说递推算法形如：<span class="math inline">\(y_k\simeq\varphi(y_{k-1},y_k)\)</span>，即每次递推只用到上一步的数据<br></p><p>对于等距、显式的情形，我们通常写为： <span class="math display">\[y_{k+1}\simeq y_k+h\Phi(t_k,y_k,h)\]</span> 我们首先讨论一些具体的方法，然后再从理论上系统研究误差问题</p><h3 id="euler-法及其改进"><span class="math inline">\(Euler\)</span>法及其改进</h3><p>前已述 <span class="math inline">\(Euler\)</span>法的原理，在等距情形，也就是 <spanclass="math inline">\(\Phi(t_k,y_k,h)=f(t_k,y_k)\)</span><br>因为 <spanclass="math inline">\(Euler\)</span> 法可以由 <spanclass="math inline">\(Taylor\)</span> 级数法取 <spanclass="math inline">\(p=1\)</span> 得到，这就不难看出其局部离散误差为<span class="math inline">\(O^*(h^2)\)</span>，因而是一阶方法</p><p>此法精度不高，故需改进，如果我们采用数值积分法中的梯形公式，可以得到一隐式方法：<span class="math display">\[y_{k+1}\simeq y_k+\frac h2(f(t_k,y_k)+f(t_{k+1},y_{k+1}))\]</span>据梯形公式的误差估计，我们知道此法为二阶方法，然而此法作为隐式方法，一般需要通过迭代求近似解<br>迭代求解需要一个初值，我们可以使用<span class="math inline">\(Euler\)</span> 法提供，具体来说，也就是：<span class="math display">\[\begin{aligned}&amp;y_{k+1,0}\simeq y_k+hf(t_k,y_k)\\&amp;y_{k+1,m}\simeq y_k+\frac h2(f(t_k,y_k)+f(t_{k+1},y_{k+1,m-1}))\end{aligned}\]</span> 这个过程也被称作 <strong>PECE</strong>，即<strong>Predict-Evaluate-Correct-Evaluate</strong>，迭代 <spanclass="math inline">\(k\)</span> 次的模式记为 <spanclass="math inline">\(P(EC)^kE\)</span><br>简单来说，就是先用显式方法作<strong>预测</strong>，再将该预测值用于隐式方法作<strong>校正</strong>（并反复迭代）的过程。</p><p>（注：如果对预测值和校正值的离散误差有较好的把握，可以通过 <spanclass="math inline">\(Romberg\)</span>积分法类似的想法去进一步修正误差）</p><p>当 <span class="math inline">\(h\)</span>足够小时，迭代一两次就已经能够得到较好的结果，由此就得到了改进的 <spanclass="math inline">\(Euler\)</span> 方法： <spanclass="math display">\[y_{k+1}\simeq y_k+\frac h2(f(t_k,y_k)+f(t_{k+1},y_k+hf(t_k,y_k)))\]</span></p><h3 id="runge-kutta-方法"><spanclass="math inline">\(Runge-Kutta\)</span> 方法</h3><p>若直接采用 <span class="math inline">\(Taylor\)</span> 法，则有：<span class="math display">\[\Phi(t_k,y_k,h)=f(t_k,y_k)+\frac12h\fracd{dt}f(t_k,y_k)+\frac1{3!}h^2\frac{d^2}{dt^2}f(t_k,y_k)+...+\frac1{p!}h^{p-1}\frac{d^{p-1}}{dt^{p-1}}f(t_k,y_k)\]</span> 此法看似容易，然而计算 <spanclass="math inline">\(\frac{d^p}{dt^p}f(t,y(t))\)</span> 绝非易事，<spanclass="math inline">\(Runge-Kutta\)</span>给出了一个想法，绕过了求解偏导数的麻烦</p><p>以 <span class="math inline">\(p=2\)</span> 为例（称为二阶 <spanclass="math inline">\(Runge-Kutta\)</span> 方法），此时： <spanclass="math display">\[\Phi(t,y,h)=f(t,y(t))+\frac12 h \frac d{dt}f(t,y(t))\]</span> 其中： <span class="math display">\[\frac d{dt}f(t,y(t))=f_t&#39;(t,y)+f_y&#39;(t,y)\cdoty&#39;(t)=f&#39;_t(t,y)+f&#39;_y(t,y)\cdot f(t,y)\]</span> 我们用待定系数法求一 <span class="math inline">\(\Phi\)</span>的近似解，如下： <span class="math display">\[\begin{aligned}&amp;\Psi(t,y,h)=c_1K_1+c_2K_2\\&amp;K_1=f(t,y)\\&amp;K_2=f(t+a_1h,y+a_2hK_1)\end{aligned}\]</span> 用 <span class="math inline">\(Taylor\)</span> 展开 <spanclass="math inline">\(K_2\)</span>（视为 <spanclass="math inline">\(h\)</span> 的函数），得到： <spanclass="math display">\[K_2=f(t,y)+a_1hf_t&#39;(t,y)+a_2hf(t,y)f_y&#39;(t,y)+O(h^2)\]</span> 于是： <span class="math display">\[\Psi(t,y,h)=(c_1+c_2)f(t,y)+c_2h(a_1f_t&#39;(t,y)+a_2f_y&#39;(t,y)f(t,y))+O(h^2)\]</span> 我们知道： <span class="math display">\[y(t+h)=y(t)+h\Phi(t,y,h)+O(h^3)\]</span> 要想使得上式将 <span class="math inline">\(\Phi\)</span>替换为 <span class="math inline">\(\Psi\)</span> 仍然成立，这只要求：<span class="math display">\[(c_1+c_2)f(t,y)+c_2h(a_1f_t&#39;(t,y)+a_2f_y&#39;(t,y)f(t,y))=\Phi(x,y,h)\]</span> 比较各项系数，得方程组： <span class="math display">\[\left\{\begin{aligned}&amp;c_1+c_2=1\\&amp;c_2a_1=c_2a_2=\frac12\\\end{aligned}\right.\]</span> 可自由选取一个变量的值，从而解出该方程，这样就导出了二阶 <spanclass="math inline">\(Runge-Kutta\)</span> 方法<br>特别地，取 <spanclass="math inline">\(a_1=1\)</span>，得到 <spanclass="math inline">\(a_2=1,\;c_1=c_2=\frac12\)</span>，由此恰好得到改进的<span class="math inline">\(Euler\)</span> 方法</p><p>至今最常用的是一个四阶 <spanclass="math inline">\(Runge-Kutta\)</span> 方法： <spanclass="math display">\[\begin{aligned}&amp;y_{k+1}=y_k+\frac h6(K_1+2K_2+2K_3+K_4)\\&amp;K_1=f(t_k,y_k)\\&amp;K_2=f(t_k+\frac12h,y_k+\frac12hK_1)\\&amp;K_3=f(t_k+\frac12h,y_k+\frac12hK_2)\\&amp;K_4=f(t_k+h,y_k+hK_3)\end{aligned}\]</span> 其局部离散误差为 <spanclass="math inline">\(O^*(h^5)\)</span></p><h3 id="理论误差分析">理论误差分析</h3><p>我们从理论角度研究一些一般性的误差问题</p><h4 id="相容性">相容性</h4><p>对于等距情形，我们当然希望近似解关于 <spanclass="math inline">\(h\)</span> 能够收敛到精确解，而这有一个必要条件：<span class="math display">\[\lim_{h\to0}\left(\frac{y(t+h)-y(t)}{h}-\Phi(t,y,h)\right)=0\]</span> 如果 <span class="math inline">\(\Phi\)</span>是连续函数，这个事情实际上是在说：<spanclass="math inline">\(y&#39;(t)=\Phi(t,y,0)\)</span>，这给出如下定义：</p><p>称单步法与初值问题是<strong>相容的</strong>，若：<spanclass="math inline">\(\Phi(t,y,0)=f(t,y)\)</span></p><p>如果只知道一个单步法是相容的，实际上并不能给出太多信息，这只能保证这个方法至少为一阶方法<br></p><h4 id="收敛性">收敛性</h4><p>首先我们给出收敛性的定义：任给 <spanclass="math inline">\(t\in[a,b]\)</span>，固定 <spanclass="math inline">\(t_n=t\)</span>，若有 <spanclass="math inline">\(\lim_{h\to0}y_n=y(t)\)</span>，则称方法是<strong>收敛的</strong><br>对于单步法，我们有如下定理：</p><p>若 <span class="math inline">\(\Phi(t,y,h)\)</span> 对 <spanclass="math inline">\(y\)</span> 满足 <spanclass="math inline">\(Lipschitz\)</span> 条件，<spanclass="math inline">\(\forallt,h\)</span>，则单步法收敛的充分必要条件是相容条件成立<br><spanclass="math inline">\(Lipshitz\)</span> 条件就是说，<spanclass="math inline">\(\forall y_1,y_2\in\mathbb{R}\)</span>，存在 <spanclass="math inline">\(L&gt;0\;s.t.\)</span> <spanclass="math display">\[|\Phi(t,y_1,h)-\Phi(t,y_2,h)|\leq L|y_1-y_2|,\;\forall t,h\]</span> 进一步，这给出了整体离散误差的一个估计，我们记 <spanclass="math inline">\(R(t,h)\)</span> 为局部离散误差，对于 <spanclass="math inline">\(p\)</span> 阶方法来说，应该有： <spanclass="math display">\[|R(t,h)|\leq Mh^{p+1}\]</span> 于是，只要 <span class="math inline">\(Lipschitz\)</span>条件满足，那么整体离散误差 <spanclass="math inline">\(\varepsilon_n=y(t_n)-y_n\)</span> 就满足： <spanclass="math display">\[|\varepsilon_n|\leq e^{L(b-a)}|\varepsilon_0|+h^p\frac ML(e^{L(b-a)}-1)\]</span> 如果有 <spanclass="math inline">\(\varepsilon_0=0\)</span>，那么这个 <spanclass="math inline">\(p\)</span> 阶单步法的整体离散误差就为 <spanclass="math inline">\(O^*(h^p)\)</span></p><h4 id="稳定性">稳定性</h4><p>稳定性是指数值稳定性，在误差分析一章中有提到；<br>在 ODE初值问题中，我们可以通过考察对初值作扰动而产生的变化来考察稳定性，具体来说：</p><p>若存在 <spanclass="math inline">\(h_0,C&gt;0\)</span>，使得对任意的初值 <spanclass="math inline">\(y_0,\bar{y}_0\)</span>，通过步长小于 <spanclass="math inline">\(h_0\)</span> 的单步法得到的相应的解 <spanclass="math inline">\(y_n,\bar{y}_n\)</span>，都满足： <spanclass="math display">\[|y_n-\bar{y}_n|\leq C|y_0-\bar{y}_0|\]</span> 就称单步法是<strong>稳定的</strong>；事实上，只要 <spanclass="math inline">\(\Phi(t,y,h)\)</span> 对 <spanclass="math inline">\(y\)</span> 满足 <spanclass="math inline">\(Lipschitz\)</span> 条件，那么单步法就是稳定的</p><p>而在实际应用中，讨论某个固定的 <span class="math inline">\(h\)</span>的情形更有意义，为此引入<strong>绝对稳定性</strong>：</p><p>称单步法是<strong>绝对稳定的</strong>，若由初值 <spanclass="math inline">\(y_k,\bar{y}_k\)</span> 满足： <spanclass="math inline">\(\bar{y}_k=y_k+\delta\)</span> 分别给出的 <spanclass="math inline">\(y_{k+1},\bar{y}_{k+1}\)</span> 都有：<spanclass="math inline">\(\vert\bar{y}_{k+1}-y_{k+1}\vert&lt;\vert\delta\vert\)</span><br>通常，我们只讨论初值问题<span class="math inline">\(y&#39;=\mu y\)</span> 的绝对稳定性，称 <spanclass="math inline">\((\alpha,\beta)\)</span> 为绝对稳定区间，若任给<span class="math inline">\(\mu h\in(\alpha,\beta)\)</span>单步法都绝对稳定</p><p>举例：考虑 <span class="math inline">\(Euler\)</span>法的绝对稳定区间，这由： <span class="math display">\[|\bar{y}_{k+1}-y_{k+1}|=|1+\mu h||\delta|&lt;|\delta|\]</span> 不难看出 <span class="math inline">\(\muh\in(-2,0)\)</span></p><h2 id="多步法">多步法</h2><p>与单步法相对的，多步法是说递推算法形如：<spanclass="math inline">\(y_k\simeq\varphi(y_{k-},...,y_k),\;m&gt;1\)</span></p><p>我们仍然考虑一些具体方法，然后理论分析误差</p><h3 id="adams-方法"><span class="math inline">\(Adams\)</span> 方法</h3><p>使用数值积分法 <spanclass="math inline">\(y(t_{k+1})-y(t_k)=\int_{t_k}^{t_{k+1}}f(t,y)dt\)</span>的问题在于右边的积分公式一般不能显式地给出<br><spanclass="math inline">\(Adams\)</span> 方法指出，可以用 <spanclass="math inline">\(y_{k-m},...,y_k\)</span> 这些已知点作 <spanclass="math inline">\(f(t,y)\)</span> 的插值多项式 <spanclass="math inline">\(p_m(t)\)</span>，于是就得到近似公式： <spanclass="math display">\[y_{k+1}\simeq y_k+\int_{t_k}^{t_{k+1}}p_m(t)dt\]</span> 可以证明，<span class="math inline">\(m\)</span> 步显式 <spanclass="math inline">\(Adams\)</span> 方法至少为 <spanclass="math inline">\(m\)</span> 阶方法</p><p>亦可以将 <span class="math inline">\(y_{k+1}\)</span>也作为插值点，由此得到方法被称为隐式 <spanclass="math inline">\(Adams\)</span> 方法<br>可以证明 ，<spanclass="math inline">\(m\)</span> 步隐式 <spanclass="math inline">\(Adams\)</span> 方法至少为 <spanclass="math inline">\((m+1)\)</span> 阶方法</p><p>（注：<span class="math inline">\(m=1\)</span> 时，隐式 <spanclass="math inline">\(Adams\)</span> 公式恰为梯形公式）</p><p>由于是隐式方法，通常也需要配合 <strong>PECE</strong>模式使用，这里不详细叙述</p><p>还有一被称为 <span class="math inline">\(Milne\)</span>方法的多步法与 <span class="math inline">\(Adams\)</span>方法类似，只是将考虑的积分区间扩大： <spanclass="math inline">\(y(t_{n+1})-y(t_{n-p})=\int_{t_{n-p}}^{t_{n+1}}f(t,y)dt\)</span><br>然后仍然考虑使用插值多项式代替<span class="math inline">\(f(t,y)\)</span>，故也不详细叙述</p><h3 id="hamming-方法"><span class="math inline">\(Hamming\)</span>方法</h3><p>与 <span class="math inline">\(Runge-Kutta\)</span>方法的想法类似，在等距情形，我们可以使用待定系数结合 <spanclass="math inline">\(Taylor\)</span> 展开的方法来构造多步法，令： <spanclass="math display">\[L(y(t),h)=\sum_{j=0}^k(\alpha_jy(t+jh)-h\beta_jy&#39;(t+jh))\]</span> 视为 <span class="math inline">\(h\)</span> 的函数，考虑 <spanclass="math inline">\(h=0\)</span> 处的 <spanclass="math inline">\(Taylor\)</span> 展开，我们知道其必然形如： <spanclass="math display">\[L(y(t),h)=c_0y(t)+c_1hy&#39;(t)+...+c_ph^py^{(p)}(t)+...\]</span> 其中 <span class="math inline">\(c_j\)</span> 与 <spanclass="math inline">\(y(t)\)</span> 无关，故我们分别令 <spanclass="math inline">\(y(t)=1,t,t^2,...\)</span> 并取 <spanclass="math inline">\(t=0\)</span>，就不难得到 <spanclass="math inline">\(c_j\)</span> 的值： <span class="math display">\[\begin{aligned}&amp;c_0=\alpha_0+\alpha_1+...+\alpha_k\\&amp;c_1=\alpha_1+2\alpha_2+...+k\alpha_k-(\beta_0+\beta_1+...+\beta_k)\\&amp;...\\&amp;c_p=\frac1{p!}(\alpha_1+2^p\alpha_2+...+k^p\alpha_k)-\frac1{(p-1)!}(\beta_1+2^{p-1}\beta_2+...+k^{p-1}\beta_k)\\&amp;...\end{aligned}\]</span> 要想使得 <span class="math inline">\(L(y(t),h)\)</span>导出一个至少 <span class="math inline">\(p\)</span>阶的线性多步法，这就要求：<spanclass="math inline">\(c_0=c_1=...=c_p=0\)</span><br>解出 <spanclass="math inline">\(\alpha_j,\beta_j\)</span> 即可</p><p>注：<span class="math inline">\(Hamming\)</span> 方法似乎只是 <spanclass="math inline">\(k=3,\;p=4,\;\alpha_k=1,\;\alpha_{k-1}=\beta_0=0\)</span>时导出的特例</p><h3 id="理论误差分析-1">理论误差分析</h3><p>与单步法对应小节类似，我们考察形如： <span class="math display">\[\sum_{j=0}^ka_jy_{m+j}=h \sum_{j=0}^k\beta_j f(t_{m+j},y_{m+j})\]</span> 这样的线性 <span class="math inline">\(k\)</span>步法，我们记： <span class="math display">\[\rho(\lambda)=\alpha_k\lambda^k+\alpha_{k-1}\lambda^{k-1}+...+\alpha_1\lambda+\alpha_0\\\sigma(\lambda)=\beta_k\lambda^k+\beta_{k-1}\lambda^{k-1}+...+\beta_1\lambda+\beta_0\\\]</span> 显然，这两个多项式与线性 <spanclass="math inline">\(k\)</span> 步法一一对应，称 <spanclass="math inline">\(\rho(\lambda)\)</span> 为线性 <spanclass="math inline">\(k\)</span> 步法的特征多项式</p><p>仿照单步法的讨论，有如下结果：</p><ul><li><p>相容性：称线性 <span class="math inline">\(k\)</span>步法是<strong>相容的</strong>，若它至少是一阶方法</p><p>可以证明，这等价于：<spanclass="math inline">\(\rho(1)=0,\;\rho&#39;(1)=\sigma(1)\)</span></p></li><li><p>收敛性：称线性 <span class="math inline">\(k\)</span>步法是<strong>收敛的</strong>，若任给 <spanclass="math inline">\(t\in[a,b]\)</span>，固定 <spanclass="math inline">\(t_n=t\)</span>，都有 <spanclass="math inline">\(\lim_{h\to0}y_n=y(t)\)</span></p><p>对于线性 <span class="math inline">\(k\)</span>步法而言，难以考察收敛性，但是有等价关系：收敛 <spanclass="math inline">\(\Leftrightarrow\)</span> 相容且稳定</p></li><li><p>稳定性：称线性 <span class="math inline">\(k\)</span>步法是<strong>稳定的</strong>，若存在 <spanclass="math inline">\(h_0,C&gt;0\)</span>，使得对任意的初值 <spanclass="math inline">\(y_0,\bar{y}_0\)</span><br>通过步长小于 <spanclass="math inline">\(h_0\)</span> 的线性 <spanclass="math inline">\(k\)</span> 步法得到的相应的解 <spanclass="math inline">\(y_n,\bar{y}_n\)</span>，都满足： <spanclass="math display">\[|y_n-\bar{y}_n|\leq C\mathop{max}_\limits{0\leq j \leqk-1}|y_j-\bar{y}_j|\]</span></p><p>可以证明，这等价于 <span class="math inline">\(\rho(\lambda)\)</span>满足一个所谓的<strong>特征根条件</strong>，即：</p><p><span class="math inline">\(\rho(\lambda)\)</span>的所有根都在单位圆中，且在单位圆上的根只能是单重根</p></li><li><p>强稳定性：上述稳定性一般又称弱稳定性（误差可能会震荡），特征根条件称为弱根条件，若进一步满足：</p><p><span class="math inline">\(\rho(\lambda)\)</span> 的全部根除了 <spanclass="math inline">\(\lambda =1\)</span>外均在单位圆内（强根条件），则称满足<strong>强稳定性</strong></p></li><li><p>绝对稳定性：仍然只讨论 <span class="math inline">\(y&#39;=\muy\)</span>，此时线性 <span class="math inline">\(k\)</span> 步法可以看成<span class="math inline">\(k\)</span> 阶常系数递推数列，有特征方程：<span class="math display">\[\rho(\lambda)-\mu h\sigma(\lambda) = 0\]</span> 我们称线性 <span class="math inline">\(k\)</span>步法是<strong>绝对稳定的</strong>，若上述方程的根 <spanclass="math inline">\(\lambda_r\)</span> 都满足 <spanclass="math inline">\(|\lambda_r|&lt;1\)</span><br>称 <spanclass="math inline">\((\alpha,\beta)\)</span> 为绝对稳定区间，若任给<span class="math inline">\(\mu h\in(\alpha,\beta)\)</span>多步法都绝对稳定</p><p>可以证明，当 <span class="math inline">\(h\)</span> 接近 <spanclass="math inline">\(0\)</span> 时，想要达成绝对稳定必须要有 <spanclass="math inline">\(\mu h&lt;0\)</span></p></li></ul><h2 id="高阶-ode-和-ode-方程组">高阶 ODE 和 ODE 方程组</h2><p>对于一阶 ODE 方程组，只要简单地记 <spanclass="math inline">\(Y=(y_1,...,y_m),\;F=(f_1,...,f_m),\;\eta=(\eta_1,...,\eta_m)\)</span>，那么初值问题就形如：<span class="math display">\[\left\{\begin{aligned}&amp;Y&#39;=F(t,Y),\;a\leq t \leq b\\&amp;Y(a)=\eta\end{aligned}\right.\]</span> 之前讨论的方法对此是完全适用的，而对于高阶 ODE： <spanclass="math display">\[\left\{\begin{aligned}&amp;y^{(m)}=f(t,y,y&#39;,...,y^{(m-1)}),\;a\leq t \leq b\\&amp;y(a)=\eta_1,\;y&#39;(a)=\eta_2,...,y^{(m-1)}(a)=\eta_m\end{aligned}\right.\]</span> 只要令：<spanclass="math inline">\(y_1=y,\;y_2=y&#39;,...,y_m=y^{(m-1)}\)</span>，就化为了方程组：<span class="math display">\[\left\{\begin{aligned}&amp;y_1&#39;=y_2,\;y_1(a)=\eta_1\\&amp;y_2&#39;=y_3,\;y_2(a)=\eta_2\\&amp;...\\&amp;y_m&#39;=f(t,y_1,y_2,...,y_m),\;y_m(a)=\eta_m\\\end{aligned}\right.\]</span> 故无需多言</p><h1 id="后记">后记</h1><ol type="1"><li>这门课其实还讲了点 <strong>M-P神经网络</strong>，然而感觉讲的太快太浅，偏科普性质（问就是感觉自己学了个寂寞），故没有整理至此。</li><li>没有整理<strong>差分方程</strong>一节，个人认为本质上跟 <spanclass="math inline">\(k\)</span>阶递推数列相关理论没什么区别，反正都是线代的活。</li><li>封面是我有一次把梯度下降方向搞反了搞成了“梯度上升”的图像捏，挺壮观的是不是（（（</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇为应付考试而整理的复习笔记，因而只是整理我个人认为考前需要速通的点，因而不一定全面以及完备。&lt;/p&gt;
&lt;h1 id=&quot;误差分析&quot;&gt;误差分析&lt;/h1&gt;
&lt;h2 id=&quot;两类基本误差&quot;&gt;两类基本误差&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;绝对误差：&lt;span
clas
      
    
    </summary>
    
    
      <category term="数学" scheme="http://dasasdhba.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://dasasdhba.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>「数值分析」浅析快速傅里叶变换 FFT</title>
    <link href="http://dasasdhba.github.io/math/FFT/"/>
    <id>http://dasasdhba.github.io/math/FFT/</id>
    <published>2023-03-29T11:57:26.000Z</published>
    <updated>2026-01-06T13:56:57.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近学数值分析这门课的时候碰到了 <strong>DFT</strong> 与<strong>FFT</strong>，然而我们学校 <strong>PPT</strong> 上给出的<strong>FFT</strong> 看起来实在是令人费解，教材更是直接摆烂不写了。</p><p>于是我想在网上找找教程看看，又发现网上的教程跟我们教材的思路又不完全相同，其看起来似乎是一个更加易懂的改进，所以我想在此简单记录一下。仅解析原理，不提供具体算法实现。</p><h1 id="解析">解析</h1><p>我们考虑 <span class="math inline">\(f\)</span> 在等距点集 <spanclass="math inline">\(\left\{x_j=\frac{2\pij}N|j=0,1,...,N-1\right\}\)</span> 上用正交函数族 <spanclass="math inline">\(1,e^{ix},...,e^{i(N-1)x}\)</span>得到的最佳平方逼近： <span class="math display">\[S(x)=\sum_{k=0}^{N-1}c_ke^{ikx}\]</span> 其中 <span class="math display">\[c_k=\frac1N \sum_{j=0}^{N-1}f(x_j)e^{-ik\frac{2\pi j}N}\;(k=0,1,...,N-1)\]</span> 被称为 <strong>DFT</strong>，要想得到所有 <spanclass="math inline">\(c_k\)</span> 共需要计算 <spanclass="math inline">\(N^2\)</span> 次乘法和加法，<strong>FFT</strong>给出了该计算的快速实现。</p><h2 id="思路">思路</h2><p>方便起见，记 <spanclass="math inline">\(f_j=f(x_j),\:\omega_N=e^{-i\frac{2\pi}N}\)</span>，那么<span class="math inline">\(c_k=\frac1N\sum_{j=0}^{N-1}f_j\omega_N^{kj}\)</span></p><p>注意到，<span class="math inline">\(\omega_N^{kj}\)</span> 事实上只有<span class="math inline">\(1,\omega_N,...,\omega_N^{N-1}\)</span> 这<span class="math inline">\(N\)</span> 个值，这实际上是复平面上单位圆的<span class="math inline">\(N\)</span> 等分点</p><p>因而不难发现，若 <span class="math inline">\(N\)</span>为偶数，由对称性就有 <spanclass="math inline">\(\omega_N^k+\omega_N^{\frac N2+k}=0\)</span></p><p>一个自然的想法是合并公因子，所以我们可以将 <spanclass="math inline">\(c_k\)</span> 改写为： <spanclass="math display">\[c_k=\frac1N\left(\sum_{j=0}^{\fracN2-1}f_j\omega_N^{kj}+\sum_{j=0}^{\frac N2-1}f_{\fracN2+j}\omega_N^{k(\frac N2+j)}\right)=\frac1N\left(\sum_{j=0}^{\fracN2-1}f_j\omega_N^{kj}+\sum_{j=0}^{\frac N2-1}(-1)^kf_{\fracN2+j}\omega_N^{kj}\right)=\frac1N\sum_{j=0}^{\fracN2-1}(f_j+(-1)^kf_{\frac N2+j})\omega_N^{kj}\]</span> 具体考虑 <span class="math inline">\(k\)</span>为奇数或者偶数的情况，有： <span class="math display">\[c_{2k}=\frac1N\sum_{j=0}^{\frac N2-1}(f_j+f_{\frac N2+j})\omega_{\fracN2}^{kj}\\c_{2k+1}=\frac1N\sum_{j=0}^{\frac N2-1}(f_j-f_{\fracN2+j})\omega_N^{j}\omega_{\frac N2}^{kj}\]</span> 从而如果 <span class="math inline">\(\frac N2\)</span>仍为偶数，我们就可以对 <span class="math inline">\(c_{2k}\)</span> 与<span class="math inline">\(c_{2k+1}\)</span> 重复上述过程</p><p>特别地，若 <spanclass="math inline">\(N=2^p\)</span>，则该过程可以一直重复下去</p><h2 id="改进">改进</h2><p>一个简单的改进是直接考察 <span class="math inline">\(c_k\)</span>中的奇数项和 <span class="math inline">\(S_k\)</span> 与偶数项和 <spanclass="math inline">\(T_k\)</span>： <span class="math display">\[c_k=\frac1N \sum_{j=0}^{N-1}f_j\omega_N^{kj}=S_k+T_k\\S_k=\frac1N \sum_{j=0}^{\frac N2-1}f_{2j+1}\omega_N^k\omega_{\fracN2}^{kj}\\T_k=\frac1N \sum_{j=0}^{\frac N2-1}f_{2j}\omega_{\frac N2}^{kj}\]</span> 那么由于 <span class="math inline">\(\frac N2\)</span>仍为偶数，可以对 <span class="math inline">\(S_k\)</span> 与 <spanclass="math inline">\(T_k\)</span>反复作相同操作，而这个改进的关键在于： <span class="math display">\[c_{k+\frac N2}=\frac1N \sum_{j=0}^{N-1}f_j\omega_N^{(k+\fracN2)j}=\frac1N \sum_{j=0}^{N-1}(-1)^jf_j\omega_N^{kj}=T_k-S_k\]</span> 由此我们事实上只需要计算 <spanclass="math inline">\(c_0,c_1,...,c_{\frac N2-1}\)</span>，对于 <spanclass="math inline">\(S_k\)</span> 与 <spanclass="math inline">\(T_k\)</span> 亦然</p><h1 id="参考文献">参考文献</h1><ul><li>[1] 李庆扬, 王能超, 易大义. 数值分析第 5 版 [M]. 清华大学出版社,2009. P87</li><li>[2] 快速理解 FFT 算法. 2022. <ahref="https://zhuanlan.zhihu.com/p/407885496"class="uri">https://zhuanlan.zhihu.com/p/407885496</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近学数值分析这门课的时候碰到了 &lt;strong&gt;DFT&lt;/strong&gt; 与
&lt;strong&gt;FFT&lt;/strong&gt;，然而我们学校 &lt;strong&gt;PPT&lt;/strong&gt; 上给出的
&lt;strong&gt;FFT&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="数学" scheme="http://dasasdhba.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://dasasdhba.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Godot 自学指南</title>
    <link href="http://dasasdhba.github.io/tech/godot-tutorial-self/"/>
    <id>http://dasasdhba.github.io/tech/godot-tutorial-self/</id>
    <published>2022-11-17T05:35:00.000Z</published>
    <updated>2026-01-06T13:42:13.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>（本文使用版本为 <strong><em>Godot 3.5.x</em></strong>）</p><p>首先说一个观点，我们自学 <strong><em>Godot</em></strong>主要是看自己的需求（想学的一般是想做独立游戏的吧，想吃饭的我建议你还是去学<strong><em>Unity</em></strong>），不能说是这个引擎能干的事情我们都去学（除非你的目标是成为什么<em>Godot 砖家</em>）。</p><p>基于这样的观点，本文并不是传统意义的什么<strong><em>Godot</em></strong> 教程（比如什么<strong>如何用 Godot 制作xxx</strong>，这样的教程我相信太多了），而是如何自学<strong><em>Godot</em></strong>的教程。换句话说，本文仅仅是给你自学指个路，毕竟这软件门槛确实有那么一点高。</p><h2 id="官方文档最好的参考资料">官方文档——最好的参考资料</h2><p><strong>温馨提示</strong>：接下来我会贴很多链接，但你没有必要每读到一个链接就去把这个链接的内容看完（可以先收藏），除非你看到了新的<strong>温馨提示</strong>，那里我会建议你先回来看看这些链接。</p><p>首先在此附上官方文档链接：<ahref="https://docs.godotengine.org/en/stable/"class="uri">https://docs.godotengine.org/en/stable/</a></p><p>我这里贴的是英文版，<strong>有能力阅读英文的尽量直接看英文版</strong>，因为别的语言都是基于英文版翻译而来的，至少中文版确实存在错误和漏翻的现象。</p><p>实在看不动英文也不要勉强，中文也不是不行，左下角就可以切换语言。</p><h2 id="入门级教程">入门级教程</h2><p>从官方文档的 <em>Getting Start</em>部分开始可以帮助你快速熟悉软件界面，我建议阅读前两节，后面那两个<em>Your First 2D/3D Game</em> 不算特别需要，直接跳过也无妨。</p><h2 id="编程语言基础教程">编程语言基础教程</h2><p>直接附上链接：<ahref="https://docs.godotengine.org/en/stable/tutorials/scripting/index.html#programming-languages"class="uri">https://docs.godotengine.org/en/stable/tutorials/scripting/index.html#programming-languages</a></p><p>一般来说只看 <strong><em>GDScript</em></strong>就可以，这门语言特别简单（特别像<strong><em>Python</em></strong>），你但凡稍微有点基础就能够快速入手。</p><p>这里的基础指的是程序设计基础，一般来说大学的<strong><em>C/C++/Python</em></strong>通识课程够用（前提是你好好学了而不是水过去的），中学的<strong><em>VB/Python</em></strong> 课程因地区而异，我不好说。</p><p>如果你没啥基础的话，那我也不能保证你看这个够不够用，大概率是不够用的，毕竟程序设计的基本思想不是一个讲语法的教程能够教会的。对于这种情况，我建议你还是直接先去学我上面提到的课程再说（上面提到了<strong><em>GDScript</em></strong> 特别像<strong><em>Python</em></strong>，所以你直接去学习<strong><em>Python</em></strong>程序设计基础就可以）。当然，你也可以先不管，说不定你的需求特别简单，不需要太多基础也能做；你也可以选择多看看<strong><em>Godot</em></strong>自带示例项目以及别的开源项目，学习别人的写法，如果真没基础的话这样会比较难，但相对比较快。</p><p>顺带一提，官网也推荐了一个零基础教程：<ahref="https://gdquest.github.io/learn-gdscript/?ref=godot-docs"class="uri">https://gdquest.github.io/learn-gdscript/?ref=godot-docs</a></p><p>不过没有中文版，我也不知道效果好不好，感兴趣可以试试。</p><p>以及，即使你是 <em>C#</em> 用户，我也还是建议你简单学学<strong><em>GDScript</em></strong>，因为在<strong><em>Godot</em></strong>里很多事情用后者处理会方便得多；如果你确实是 <em>C#</em>老用户，只要稍微看一眼 <strong><em>GDScript</em></strong>的教程，以后你完全就可以把核心和东西交给 C# 做，然后那些繁琐的 glue代码拿 <strong><em>GDScript</em></strong> 写，这样还是很舒服的。</p><h2 id="程序设计进阶教程">程序设计进阶教程</h2><p>（没基础的话可以先跳过）</p><p>首先是<strong>最佳实践</strong>：<ahref="https://docs.godotengine.org/en/stable/tutorials/best_practices/index.html"class="uri">https://docs.godotengine.org/en/stable/tutorials/best_practices/index.html</a></p><p>这里面讲了一些比较基本的面向对象思想，并且对于如何组织项目等问题都给出了建议，非常值得参考。</p><p>其次是<strong>优化</strong>：<ahref="https://docs.godotengine.org/en/stable/tutorials/performance/index.html"class="uri">https://docs.godotengine.org/en/stable/tutorials/performance/index.html</a></p><p>这里面给出了如何进行调试分析以及优化的基本建议，推荐有一定开发经验的人员阅读，还算是比较实用；没什么开发经验的话就不建议看得太深入，比如假设你根本不知道什么时候该用线程，就别想着用线程优化，因为你很有可能搞成负优化。</p><h2 id="功能实现类教程">功能实现类教程</h2><p>官方文档的 <em>Tutorials</em>部分主要是关于引擎对于特定功能（往往都是基础功能）如何实现的具体说明，这个就看自己的需求去阅读了。</p><p>比如假设我想做一个 <strong>2D Platform</strong>，那么我就需要去看<em>2D</em> 以及 <em>Physics</em> 部分。</p><h2 id="api-文档">API 文档</h2><p>这部分内容与在引擎内使用 <code>F1</code>的效果完全相同，而且引擎内的版本一方面是离线版（网页版加载有时候会很慢），另一方面也有非常方便的检索机制，因此我推荐在引擎内阅读这一部分，而将网页端作为一个备选项。</p><p>如果你不知道 <strong>API</strong>是啥，你可以先大致理解为这部分内容是对引擎里面的各种东西具体能做什么的一个说明。总之，<strong>API文档</strong>放在任何一个游戏引擎都是非常重要的内容，但从学习的角度来说我们对于这部分内容一般都是即查即用（然后你会自然地记住特别常用的内容），之后对于特别常用的内容我会贴链接以及作部分讲解说明。</p><h2 id="官方-qa-平台">官方 Q&amp;A 平台</h2><p>还是直接附上链接：<a href="https://godotengine.org/qa/"class="uri">https://godotengine.org/qa/</a></p><p>遇到问题可以首先在这里搜索（需要使用英文），很多时候你遇到的问题都是别人遇到过的。</p><p>此外，官方论坛的性质也类似：<a href="https://godotforums.org/"class="uri">https://godotforums.org/</a></p><p>不过论坛上肯定不是纯粹的<strong>Q&amp;A</strong>，也有很多其他有用的资源，自己探索吧。</p><h2 id="使用搜索引擎">使用搜索引擎</h2><p>使用 <strong><em>Google/Bing</em></strong>等搜索引擎直接搜索问题一般也能找到一些资料。（最好用英文）</p><p>当然你很有可能搜到的就是刚才提到的 <strong>Q&amp;A</strong>平台上的问题，不过这也无妨。</p><h2 id="其他资源">其他资源</h2><ul><li><p>官方资源网站：<ahref="https://godotengine.org/asset-library/asset"class="uri">https://godotengine.org/asset-library/asset</a></p><p>这里面资源不少，还能找到很多实用的插件（<strong><em>Addon</em></strong>），需要的功能引擎不直接提供的话可以来翻翻看。</p></li><li><p><strong>Shader</strong> 资源网站：<ahref="https://godotshaders.com/"class="uri">https://godotshaders.com/</a></p><p>里面有很多开源的 <strong>Shader</strong>可以直接使用和学习。</p></li><li><p>一个相对火的教程网站：<a href="https://godottutorials.com/"class="uri">https://godottutorials.com/</a></p><p>这个并不是官方教程，我自己也没看过，不过既然比较火还是在这里贴一下，可以参考。</p></li></ul><p>至于别的非官方教程资源我就更没有看过了，自己取舍吧，说不定能找到适合你的。</p><h1 id="尾声2026-update">尾声（2026 Update）</h1><p>现在已经是 AI 时代了，搭配一个 GitHub Copilot 或者 Fitten Code 之类的AI Agent 应该也是不错的学习方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;（本文使用版本为 &lt;strong&gt;&lt;em&gt;Godot 3.5.x&lt;/em&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;首先说一个观点，我们自学 &lt;strong&gt;&lt;em&gt;Godot&lt;/em&gt;&lt;/strong&gt;
主要是看自己的需求（想学的一
      
    
    </summary>
    
    
      <category term="开发" scheme="http://dasasdhba.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="开发" scheme="http://dasasdhba.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>dasasdhba 的个人博客上线啦！！！</title>
    <link href="http://dasasdhba.github.io/first/"/>
    <id>http://dasasdhba.github.io/first/</id>
    <published>2020-04-16T16:03:49.653Z</published>
    <updated>2026-01-06T13:21:25.436Z</updated>
    
    <content type="html"><![CDATA[<p>搞了半天总算是把这个博客架好了，以后有啥东西就往这里放啦~<br>不过还是有很多东西需要不断学习不断调整，嗯，继续努力！<br>域名啥的等我上大学再考虑，先就用这个（<br><ahref="https://dasasdhba.github.io"class="uri">https://dasasdhba.github.io</a></p><p>嗯，欢迎评论哦~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;搞了半天总算是把这个博客架好了，以后有啥东西就往这里放啦~&lt;br&gt;不过还是有很多东西需要不断学习不断调整，嗯，继续努力！&lt;br&gt;域名啥的等我上大学再考虑，先就用这个（&lt;br&gt;&lt;a
href=&quot;https://dasasdhba.github.io&quot;
class=&quot;uri
      
    
    </summary>
    
    
      <category term="记录" scheme="http://dasasdhba.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
</feed>
