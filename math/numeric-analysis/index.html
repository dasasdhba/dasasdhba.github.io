<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数值分析复习笔记 | das's Blog</title><meta name="description" content="本篇为应付考试而整理的复习笔记，因而只是整理我个人认为考前需要速通的点，因而不一定全面以及完备。 误差分析 两类基本误差  绝对误差：\(e_{\bar{x}}=x-\bar{x}\) 相对误差：\(r_{\bar{x}}=\frac{e_{\bar{x}}}x\) 由于 \(x\) 往往未知，在 \(r_{\bar{x}}\) 很小的时候，可以用 \(r^*_{\bar{x}}=\f"><meta name="keywords" content="数学，数值计算"><meta name="author" content="dasasdhba"><meta name="copyright" content="dasasdhba"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/icon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数值分析复习笔记"><meta name="twitter:description" content="本篇为应付考试而整理的复习笔记，因而只是整理我个人认为考前需要速通的点，因而不一定全面以及完备。 误差分析 两类基本误差  绝对误差：\(e_{\bar{x}}=x-\bar{x}\) 相对误差：\(r_{\bar{x}}=\frac{e_{\bar{x}}}x\) 由于 \(x\) 往往未知，在 \(r_{\bar{x}}\) 很小的时候，可以用 \(r^*_{\bar{x}}=\f"><meta name="twitter:image" content="https://s1.ax1x.com/2023/04/24/p9mR80O.jpg"><meta property="og:type" content="article"><meta property="og:title" content="数值分析复习笔记"><meta property="og:url" content="http://dasasdhba.github.io/math/numeric-analysis/"><meta property="og:site_name" content="das's Blog"><meta property="og:description" content="本篇为应付考试而整理的复习笔记，因而只是整理我个人认为考前需要速通的点，因而不一定全面以及完备。 误差分析 两类基本误差  绝对误差：\(e_{\bar{x}}=x-\bar{x}\) 相对误差：\(r_{\bar{x}}=\frac{e_{\bar{x}}}x\) 由于 \(x\) 往往未知，在 \(r_{\bar{x}}\) 很小的时候，可以用 \(r^*_{\bar{x}}=\f"><meta property="og:image" content="https://s1.ax1x.com/2023/04/24/p9mR80O.jpg"><meta property="article:published_time" content="2023-04-24T06:10:28.000Z"><meta property="article:modified_time" content="2026-02-25T08:00:43.059Z"><script src="https://gcore.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://dasasdhba.github.io/math/numeric-analysis/"><link rel="prev" title="重启" href="http://dasasdhba.github.io/restart/"><link rel="next" title="「数值分析」浅析快速傅里叶变换 FFT" href="http://dasasdhba.github.io/math/FFT/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://dasasdhba.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="das's Blog" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">4</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#误差分析"><span class="toc-number">1.</span> <span class="toc-text">误差分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#两类基本误差"><span class="toc-number">1.1.</span> <span class="toc-text">两类基本误差</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#舍入误差与有效数字"><span class="toc-number">1.2.</span> <span class="toc-text">舍入误差与有效数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算中的误差传播"><span class="toc-number">1.3.</span> <span class="toc-text">运算中的误差传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机浮点系统"><span class="toc-number">1.4.</span> <span class="toc-text">计算机浮点系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ufl-与-ofl"><span class="toc-number">1.4.1.</span> <span class="toc-text">UFL 与 OFL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#机器精度"><span class="toc-number">1.4.2.</span> <span class="toc-text">机器精度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#机器算术运算"><span class="toc-number">1.4.3.</span> <span class="toc-text">机器算术运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数值稳定与病态问题"><span class="toc-number">1.5.</span> <span class="toc-text">数值稳定与病态问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#插值法"><span class="toc-number">2.</span> <span class="toc-text">插值法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lagrange-插值"><span class="toc-number">2.1.</span> <span class="toc-text">\(Lagrange\)
插值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#余项"><span class="toc-number">2.1.1.</span> <span class="toc-text">余项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runge-现象"><span class="toc-number">2.1.2.</span> <span class="toc-text">\(Runge\) 现象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newton-插值"><span class="toc-number">2.2.</span> <span class="toc-text">\(Newton\)
插值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#均差"><span class="toc-number">2.2.1.</span> <span class="toc-text">均差</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#差商表"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">差商表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newton-插值多项式"><span class="toc-number">2.2.2.</span> <span class="toc-text">\(Newton\)
插值多项式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有限差"><span class="toc-number">2.2.3.</span> <span class="toc-text">有限差</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#差分表"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">差分表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newton-前插和后插公式"><span class="toc-number">2.2.4.</span> <span class="toc-text">\(Newton\) 前插和后插公式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hermite-插值"><span class="toc-number">2.3.</span> <span class="toc-text">Hermite 插值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分段插值"><span class="toc-number">2.4.</span> <span class="toc-text">分段插值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分段插值误差界"><span class="toc-number">2.4.1.</span> <span class="toc-text">分段插值误差界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三次样条插值"><span class="toc-number">2.4.2.</span> <span class="toc-text">三次样条插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基样条插值"><span class="toc-number">2.4.3.</span> <span class="toc-text">基样条插值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数逼近"><span class="toc-number">3.</span> <span class="toc-text">函数逼近</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#正交函数系"><span class="toc-number">3.1.</span> <span class="toc-text">正交函数系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线性无关"><span class="toc-number">3.1.1.</span> <span class="toc-text">线性无关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直交多项式"><span class="toc-number">3.2.</span> <span class="toc-text">直交多项式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#chebyshev-多项式"><span class="toc-number">3.2.1.</span> <span class="toc-text">\(Chebyshev\)
多项式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#近似最佳一致逼近"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">近似最佳一致逼近</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二类-chebyshev-多项式"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">第二类 \(Chebyshev\) 多项式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#legendre-多项式"><span class="toc-number">3.2.2.</span> <span class="toc-text">\(Legendre\)
多项式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最佳一致逼近"><span class="toc-number">3.3.</span> <span class="toc-text">最佳一致逼近</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最佳平方逼近"><span class="toc-number">3.4.</span> <span class="toc-text">最佳平方逼近</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#离散情形"><span class="toc-number">3.4.1.</span> <span class="toc-text">离散情形</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据拟合"><span class="toc-number">4.</span> <span class="toc-text">数据拟合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线性拟合"><span class="toc-number">4.1.</span> <span class="toc-text">线性拟合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#过拟合现象"><span class="toc-number">4.1.1.</span> <span class="toc-text">过拟合现象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非线性拟合"><span class="toc-number">4.2.</span> <span class="toc-text">非线性拟合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线性化求近似解"><span class="toc-number">4.2.1.</span> <span class="toc-text">线性化求近似解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#梯度下降法"><span class="toc-number">4.2.2.</span> <span class="toc-text">梯度下降法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数值微积分"><span class="toc-number">5.</span> <span class="toc-text">数值微积分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数值微分"><span class="toc-number">5.1.</span> <span class="toc-text">数值微分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#差商法"><span class="toc-number">5.1.1.</span> <span class="toc-text">差商法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插值法-1"><span class="toc-number">5.1.2.</span> <span class="toc-text">插值法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数值积分"><span class="toc-number">5.2.</span> <span class="toc-text">数值积分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#插值法-2"><span class="toc-number">5.2.1.</span> <span class="toc-text">插值法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的数值积分"><span class="toc-number">5.3.</span> <span class="toc-text">函数的数值积分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newton-cotes-求积公式"><span class="toc-number">5.3.1.</span> <span class="toc-text">Newton-Cotes 求积公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复合求积公式"><span class="toc-number">5.3.2.</span> <span class="toc-text">复合求积公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区间逐次分半法"><span class="toc-number">5.3.3.</span> <span class="toc-text">区间逐次分半法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自适应积分法"><span class="toc-number">5.3.4.</span> <span class="toc-text">自适应积分法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#euler-maclaurin-公式"><span class="toc-number">5.3.5.</span> <span class="toc-text">\(Euler-Maclaurin\) 公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#romberg-积分法"><span class="toc-number">5.3.6.</span> <span class="toc-text">\(Romberg\)
积分法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gauss-求积公式"><span class="toc-number">5.3.7.</span> <span class="toc-text">\(Gauss\)
求积公式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重积分与广义积分"><span class="toc-number">5.4.</span> <span class="toc-text">重积分与广义积分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ode-初值问题数值解"><span class="toc-number">6.</span> <span class="toc-text">ODE 初值问题数值解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#单步法"><span class="toc-number">6.1.</span> <span class="toc-text">单步法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#euler-法及其改进"><span class="toc-number">6.1.1.</span> <span class="toc-text">\(Euler\)
法及其改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runge-kutta-方法"><span class="toc-number">6.1.2.</span> <span class="toc-text">\(Runge-Kutta\) 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理论误差分析"><span class="toc-number">6.1.3.</span> <span class="toc-text">理论误差分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#相容性"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">相容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#收敛性"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">收敛性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#稳定性"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">稳定性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多步法"><span class="toc-number">6.2.</span> <span class="toc-text">多步法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#adams-方法"><span class="toc-number">6.2.1.</span> <span class="toc-text">\(Adams\) 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hamming-方法"><span class="toc-number">6.2.2.</span> <span class="toc-text">\(Hamming\)
方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#理论误差分析-1"><span class="toc-number">6.2.3.</span> <span class="toc-text">理论误差分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高阶-ode-和-ode-方程组"><span class="toc-number">6.3.</span> <span class="toc-text">高阶 ODE 和 ODE 方程组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#后记"><span class="toc-number">7.</span> <span class="toc-text">后记</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://s1.ax1x.com/2023/04/24/p9mR80O.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">das's Blog</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">数值分析复习笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2023-04-24 14:10:28"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2023-04-24</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2026-02-25 16:00:43"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2026-02-25</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/math/numeric-analysis/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/math/numeric-analysis/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>本篇为应付考试而整理的复习笔记，因而只是整理我个人认为考前需要速通的点，因而不一定全面以及完备。</p>
<h1 id="误差分析">误差分析</h1>
<h2 id="两类基本误差">两类基本误差</h2>
<ul>
<li><p>绝对误差：<span
class="math inline">\(e_{\bar{x}}=x-\bar{x}\)</span></p></li>
<li><p>相对误差：<span
class="math inline">\(r_{\bar{x}}=\frac{e_{\bar{x}}}x\)</span></p>
<p>由于 <span class="math inline">\(x\)</span> 往往未知，在 <span
class="math inline">\(r_{\bar{x}}\)</span> 很小的时候，可以用 <span
class="math inline">\(r^*_{\bar{x}}=\frac{e_{\bar{x}}}{\bar{x}}\)</span>
近似</p></li>
</ul>
<h2 id="舍入误差与有效数字">舍入误差与有效数字</h2>
<p>记十进制数 <span class="math inline">\(a\)</span> 某个数码 <span
class="math inline">\(a_s\)</span> 的位数为 <span
class="math inline">\(k(a_s)\)</span>，当 <span
class="math inline">\(a_s\)</span> 在个位时取 0，十位时取
1，小数点后第一位时取 -1，以此类推</p>
<ul>
<li><p>舍入误差：将 a 四舍五入至 <span class="math inline">\(k\)</span>
位小数，那么 <span
class="math inline">\(|e_{\bar{a}}|\leq\frac12\times10^{-k}\)</span></p></li>
<li><p>有效数字：设 <span class="math inline">\(\bar{a}\)</span> 为
<span class="math inline">\(a\)</span> 的近似值，从 <span
class="math inline">\(\bar{a}\)</span> 中首位不为零的数码起，称数码
<span class="math inline">\(a_s\)</span> 为有效数字，若满足： <span
class="math display">\[
|e_{\bar{a}}|\leq\frac12\times10^{k(a_s)}
\]</span>
（因而对于四舍五入得到的近似值，从首位不为零的数码起，所有数码都是有效数字）</p></li>
</ul>
<p>利用有效数字，我们有如下<strong>相对误差估计</strong>：</p>
<p>设 <span class="math inline">\(\bar{a}\)</span> 有 <span
class="math inline">\(k\)</span> 位有效数字，其中第一位有效数字为 <span
class="math inline">\(a_s\)</span>，那么： <span class="math display">\[
|r^*_{\bar{a}}|\leq\frac1{2a_s}\times10^{-(k-1)}
\]</span> 反之，若有上述不等式成立，则 <span
class="math inline">\(\bar{a}\)</span> 至少有 <span
class="math inline">\(k\)</span> 位有效数字</p>
<p>（这说明有效数字越多，相对误差越小）</p>
<h2 id="运算中的误差传播">运算中的误差传播</h2>
<p>考察二元函数 <span class="math inline">\(z=f(x,y)\)</span>
产生的误差：<span
class="math inline">\(e_{\bar{z}}=f(x,y)-f(\bar{x},\bar{y})\)</span></p>
<p>当 <span class="math inline">\(|e_{\bar{x}}|,|e_{\bar{y}}|\)</span>
很小，且 <span class="math inline">\(f\)</span> 可微时，有近似公式：
<span class="math display">\[
e_{\bar{z}}\approx \frac{\partial f}{\partial
x}(\bar{x},\bar{y})\:e_{\bar{x}}+\frac{\partial f}{\partial
y}(\bar{x},\bar{y})\:e_{\bar{y}}\\
r_{\bar{z}}\approx \frac{\bar{x}}{\bar{z}}\frac{\partial f}{\partial
x}(\bar{x},\bar{y})\:r_{\bar{x}}+\frac{\bar{y}}{\bar{z}}\frac{\partial
f}{\partial y}(\bar{x},\bar{y})\:r_{\bar{y}}
\]</span> （对于 <span class="math inline">\(r^*\)</span>
亦有类似的近似）</p>
<p>由此导出：</p>
<ol type="1">
<li><p><span class="math inline">\(f(x,y)=x\pm y\)</span> <span
class="math display">\[
e_{\bar{x}\pm \bar{y}}=e_{\bar{x}}\pm e_{\bar{y}}\\
r_{\bar{x}\pm \bar{y}}=\frac{\bar{x}}{\bar{x}\pm
\bar{y}}r_{\bar{x}}\pm\frac{\bar{y}}{\bar{x}\pm \bar{y}}r_{\bar{y}}
\]</span> 可见 <span class="math inline">\(x\approx y\)</span>
时作减法会产生较大的相对误差，这被称为<strong>相减相消</strong>，应尽量避免</p></li>
<li><p><span class="math inline">\(f(x,y)=xy\)</span> <span
class="math display">\[
e_{\bar{x}\bar{y}}=\bar{y}e_{\bar{x}}+\bar{x}e_{\bar{y}}\\
r_{\bar{x}\bar{y}}=r_{\bar{x}}+r_{\bar{y}}
\]</span></p></li>
<li><p><span class="math inline">\(f(x,y)=x/y\)</span> <span
class="math display">\[
e_{\bar{x}/\bar{y}}=\frac{\bar{y}e_{\bar{x}}-\bar{x}e_{\bar{y}}}{\bar{y}^2}\\
r_{\bar{x}/\bar{y}}=r_{\bar{x}}-r_{\bar{y}}
\]</span> 可见 <span class="math inline">\(y\to0\)</span>
时会产生较大的绝对误差，应尽量避免</p></li>
</ol>
<h2 id="计算机浮点系统">计算机浮点系统</h2>
<p>称 <span class="math inline">\(F(p,t,L,U)\)</span>
为一个计算机浮点系统，其中：</p>
<ul>
<li><span class="math inline">\(p\)</span>：基数（进制）</li>
<li><span class="math inline">\(t\)</span>：精度（最大小数位数）</li>
<li><span class="math inline">\(L,U\)</span>：指数的取值范围 <span
class="math inline">\([-L,U]\)</span>（整数）</li>
</ul>
<p>属于浮点系统 <span class="math inline">\(F\)</span> 的数 <span
class="math inline">\(x\)</span> 具有如下形式： <span
class="math display">\[
x=\pm p^J\sum_{k=1}^td_kp^{-k}=\pm (0.d_1d_2...d_t)_p\times p^J\\
J\in \mathbb{Z}\cap[-L,U],\:d_k\in\{0,1,2,...,p-1\}
\]</span> 称 <span class="math inline">\((0.d_1d_2...d_t)_p\)</span> 为
<span class="math inline">\(x\)</span> 的尾数，<span
class="math inline">\(J\)</span> 为 <span
class="math inline">\(x\)</span> 的指数（阶）</p>
<p>称 <span class="math inline">\(x\)</span>
为<strong>规格化浮点数</strong>，若 <span
class="math inline">\(d_1\neq0\)</span></p>
<h3 id="ufl-与-ofl">UFL 与 OFL</h3>
<ul>
<li>称 <span class="math inline">\(F\)</span> 中的最小正数为 <span
class="math inline">\(UFL=p^{-t}\times p^{-L}=p^{-(L+t)}\)</span></li>
<li>称 <span class="math inline">\(F\)</span> 中的最大正数为 <span
class="math inline">\(OFL=(1-p^{-t})\times p^U\)</span></li>
</ul>
<h3 id="机器精度">机器精度</h3>
<p><span class="math inline">\(F\)</span> 自然不能表示任意实数，称 <span
class="math inline">\(F\)</span> 中用于表示一个在 <strong>UFL</strong>
以及 <strong>OFL</strong> 范围内的实数 <span
class="math inline">\(x\)</span> 的最大的相对误差为机器精度 <span
class="math inline">\(\varepsilon_{mach}\)</span></p>
<ul>
<li>若采取<strong>截断法</strong>：<span
class="math inline">\(\varepsilon_{mach}=p^{1-t}\)</span></li>
<li>若采取<strong>最近舍入法</strong>（四舍六入五取双）：<span
class="math inline">\(\varepsilon_{mach}=\frac12p^{1-t}\)</span></li>
</ul>
<p>一般地：<span
class="math inline">\(0&lt;UFL&lt;\varepsilon_{mach}&lt;OFL\)</span></p>
<h3 id="机器算术运算">机器算术运算</h3>
<p>以 <span class="math inline">\(\oplus\:\ominus\:\otimes\)</span>
等符号代表机器算术运算符号， 可以假定机器运算的定义为： <span
class="math display">\[
x\odot y=fl(fl(x)\cdot fl(y))
\]</span> 其中 <span class="math inline">\(\cdot\)</span>
泛指上述符号，<span class="math inline">\(fl(x)\)</span> 为 <span
class="math inline">\(F\)</span> 中最接近 <span
class="math inline">\(x\)</span> 的数，也就是 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(F\)</span> 中的表示</p>
<p>乘除运算是直接进行的，只需要分别处理底数部分和指数部分即可；</p>
<p>而对于加减运算，则需要<strong>对阶</strong>操作，即首先将阶数较小的数调整为与阶数较大的数同阶数（相应地，底数修改小数点位置），这个过程中若底数超出了精度
<span
class="math inline">\(t\)</span>，则需要截断或最近舍入；完成加减运算之后，仍然需要作截断或最近舍入</p>
<p>特别地，对于减法，我们有<strong>精度丢失定理</strong>：设 <span
class="math inline">\(x&gt;y\)</span> 均为正的规格化二进制浮点数，且
<span class="math inline">\(2^{-q}\leq1-\frac yx\leq2^{-p}\)</span> 则
<span class="math inline">\(x\ominus y\)</span> 丢失至多 <span
class="math inline">\(q\)</span> 个，至少 <span
class="math inline">\(p\)</span> 个有效二进制位</p>
<h2 id="数值稳定与病态问题">数值稳定与病态问题</h2>
<ul>
<li><p>称一个算法是<strong>数值稳定</strong>的，若在计算过程中，<strong>误差</strong>不会增长，否则称为<strong>数值不稳定</strong>的</p>
<p>例：在计算递推式时，式中出现了形如 <span
class="math inline">\(x_{n+1}=ax_n,\:a&gt;1\)</span>
的情况，那么误差就会被 <span class="math inline">\(a\)</span>
不断放大，导致数值不稳定</p></li>
<li><p>称一个问题是<strong>病态</strong>的，若输入的<strong>微小变化</strong>能够导致输出的<strong>巨大误差</strong></p>
<p>例：求解线性方程组时系数矩阵接近奇异，如 <span
class="math inline">\(Hilbert\)</span> 矩阵</p></li>
</ul>
<h1 id="插值法">插值法</h1>
<p>插值问题是指给定一组离散数据 <span
class="math inline">\(\{x_k,y_k\},k=0,1,...,n\)</span>，我们试图寻求一函数形如：
<span class="math display">\[
\varphi(x)=a_0\varphi_0(x)+a_1\varphi_1(x)+...+a_n\varphi_n(x)
\]</span> 使得 <span class="math inline">\(\varphi(x_k)=y_k,\forall
k=0,1,...,n\)</span></p>
<h2 id="lagrange-插值"><span class="math inline">\(Lagrange\)</span>
插值</h2>
<p>记 <span class="math inline">\(l_i(x)=\prod_{j=0,j\neq
i}^n\frac{x-x_j}{x_i-x_j}\)</span>，则 <span
class="math inline">\(l_i(x_j)=\delta_{ij}\)</span>，称为 <span
class="math inline">\(Lagrange\)</span> 基本多项式</p>
<p>则 <span class="math inline">\(Lagrange\)</span> 插值多项式为：<span
class="math inline">\(L_n(x)=\sum_{i=0}^nf(x_i)l_i(x)\)</span>，容易证明这是存在唯一的</p>
<p>方便起见，若记 <span
class="math inline">\(\omega_{n+1}(x)=\prod_{i=0}^n(x-x_i)\)</span>，那么
<span class="math inline">\(\omega_{n+1}&#39;(x_i)=\prod_{j=0,j\neq
i}^n(x_i-x_j)\)</span></p>
<p>于是 <span
class="math inline">\(l_i(x)=\frac{\omega_{n+1}(x)}{(x-x_i)\omega_{n+1}&#39;(x_i)}\)</span></p>
<h3 id="余项">余项</h3>
<p>设离散数据 <span
class="math inline">\(\{x_k,y_k\},k=0,1,...,n\)</span> 是由函数 <span
class="math inline">\(f\)</span> 给出，也就是 <span
class="math inline">\(y_i=f(x_i)\)</span>，称： <span
class="math display">\[
r_n(x)=f(x)-L_n(x)
\]</span> 为 <span class="math inline">\(Lagrange\)</span>
插值多项式的<strong>余项</strong></p>
<p>假设 <span class="math inline">\(f\)</span> 在包含 <span
class="math inline">\(\{x_n\}\)</span> 的区间 <span
class="math inline">\([a,b]\)</span> 上具有 <span
class="math inline">\(n\)</span> 阶连续导数，且在 <span
class="math inline">\((a,b)\)</span> 内存在 <span
class="math inline">\(n+1\)</span> 阶有界导数， <br>那么 <span
class="math inline">\(\forall x \in [a,b],\:\exists \xi\in(a,b)\)</span>
使得： <span class="math display">\[
r_n(x)=\frac{f^{n+1}(\xi)}{(n+1)!}\omega_{n+1}(x)
\]</span> 其证明需要简单了解，大致如下： <br>因为 <span
class="math inline">\(x_0,x_1,...,x_n\)</span> 都是 <span
class="math inline">\(r_n(x)\)</span> 的一重零点，故可以设 <span
class="math inline">\(r_n(x)=\omega_{n+1}(x)K(x)\)</span>，为确定 <span
class="math inline">\(K(x)\)</span>，引入辅助函数： <span
class="math display">\[
F(t)=f(t)-L_n(t)-K(x)\omega_{n+1}(t)
\]</span> 则 <span class="math inline">\(t = x_0,x_1,...,x_n,x\)</span>
时均有 <span class="math inline">\(F(t)=0\)</span>，反复应用 <span
class="math inline">\(Rolle\)</span> 定理就有 <span
class="math inline">\(0=F^{(n+1)}(\xi)=f^{(n+1)}(\xi)-K(x)(n+1)!\)</span>
<br>从而不难解出 <span class="math inline">\(K(x)\)</span> （这说明
<span class="math inline">\(\xi\)</span> 与 <span
class="math inline">\(x_0,x_1,...,x_n,x\)</span> 有关）</p>
<p>通过考察余项，我们可以估计误差，特别地，对于线性插值，有： <span
class="math display">\[
|r_1(x)|\leq\frac{(b-a)^2}{8}|f&#39;&#39;(\xi)|
\]</span> 对于二次插值，有： <span class="math display">\[
|r_2(x)|\leq \frac{\sqrt3}{27}(b-a)^3|f&#39;&#39;&#39;(\xi)|
\]</span></p>
<h3 id="runge-现象"><span class="math inline">\(Runge\)</span> 现象</h3>
<p>一般而言，<span class="math inline">\(n\)</span> 越大，<span
class="math inline">\(L_n(x)\)</span> 在端点附近的抖动也越大，这被称为
<span class="math inline">\(Runge\)</span>
现象，因而高次插值法一般不能用于外插</p>
<h2 id="newton-插值"><span class="math inline">\(Newton\)</span>
插值</h2>
<h3 id="均差">均差</h3>
<p>称 <span
class="math inline">\(f[x_i,x_j]=\frac{f(x_j)-f(x_i)}{x_j-x_i}\)</span>
为 <span class="math inline">\(f\)</span> 关于基点 <span
class="math inline">\(x_i,x_j\)</span> 的一阶均差<br> 称 <span
class="math inline">\(f[x_i,x_j,x_k]=\frac{f[x_j,x_k]-f[x_i,x_j]}{x_k-x_i}\)</span>
为 <span class="math inline">\(f\)</span> 关于基点 <span
class="math inline">\(x_i,x_j,x_k\)</span> 的二阶均差<br> 一般地，<span
class="math inline">\(f[x_0,x_1,...,x_n]=\frac{f[x_1,x_2,...,x_n]-f[x_0,x_1,...,x_{n-1}]}{x_n-x_0}\)</span>
<br>方便起见，不妨规定 <span
class="math inline">\(f[x_i]=f(x_i)\)</span></p>
<p>用归纳法可以证明： <span class="math display">\[
f[x_0,x_1,...,x_n]=\sum_{i=0}^n\frac{f(x_i)}{\prod_{j=0,j\neq
i}^n(x_i-x_j)}
\]</span></p>
<h4 id="差商表">差商表</h4>
<p>常用差商表来计算各个均差：</p>
<p><span class="math display">\[
\left[
\begin{array}{}
x_0 &amp; f(x_0)\\
x_1 &amp; f(x_1)  &amp; f[x_0,x_1]\\
x_2 &amp; f(x_2) &amp; f[x_1,x_2] &amp; f[x_0,x_1,x_2]\\
... &amp; ... &amp; ... &amp; ...  &amp; ...\\
x_n &amp; f(x_n) &amp; f[x_{n-1},x_n] &amp; f[x_{n-2},x_{n-1},x_n]
&amp;  ... &amp; f[x_0,...,x_n]\\
\end{array}
\right]
\]</span></p>
<h3 id="newton-插值多项式"><span class="math inline">\(Newton\)</span>
插值多项式</h3>
<p><span class="math inline">\(Lagrange\)</span>
插值的缺陷是每新增一个样本点都要全部重新算一遍，<span
class="math inline">\(Newton\)</span>
插值优化了这一点，其关键是将多项式考虑为如下形式： <span
class="math display">\[
N_n(x)=a_0+a_1(x-x_0)+a_2(x-x_0)(x-x_1)+...+a_n(x-x_0)(x-x_1)...(x-x_{n-1})
\]</span> 从而不难看出 <span
class="math inline">\(a_k=f[x_0,x_1,...,x_k]\)</span></p>
<p>若新增一插值基点 <span class="math inline">\(\bar{x}\)</span>，那么
<span
class="math inline">\(f(\bar{x})-N_n(\bar{x})=N_{n+1}(\bar{x})-N_n(\bar{x})=f[x_0,x_1,...,x_n,\bar{x}]\omega_{n+1}(\bar{x})\)</span>
<br>据插值多项式的唯一性，比较上一节中的余项就有： <span
class="math display">\[
f[x_0,x_1,...,x_n,x]=\frac{f^{(n+1)}(\xi)}{(n+1)!}
\]</span></p>
<h3 id="有限差">有限差</h3>
<p>下面我们考虑样本点满足 <span
class="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span>
的简单情形，方便起见，引入有限差的概念，分别称： <span
class="math display">\[
\Delta f(x)=f(x+h)-f(x)\\
\nabla f(x)=f(x)-f(x-h)\\
\delta f(x)=f(x+\frac h2)-f(x-\frac h2)
\]</span> 为函数 <span class="math inline">\(f(x)\)</span> 在点 <span
class="math inline">\(x\)</span>
的一阶向前差分，一阶向后差分以及一阶中心差分，易见它们都是线性算子
<br>下面以向前差分为例定义高阶情形： <span class="math display">\[
\Delta^2f(x)=\Delta(\Delta f(x))=\Delta f(x+h)-\Delta f(x)\\
\Delta^nf(x)=\Delta(\Delta^{n-1} f(x))=\Delta^{n-1} f(x+h)-\Delta^{n-1}
f(x)\\
\]</span> 类似地，方便起见我们规定 <span
class="math inline">\(\Delta^0f(x)=f(x)\)</span>，用归纳法可以证明：
<span class="math display">\[
\Delta^n f(x)=\sum_{i=0}^n(-1)^iC_n^if(x+(n-i)h)\\
\nabla^n f(x)=\sum_{i=0}^n(-1)^iC_n^if(x-ih)\\
\delta^n f(x)=\sum_{i=0}^n(-1)^iC_n^if(x+(\frac n2-i)h)
\]</span> 反过来，我们也有： <span class="math display">\[
f(x+nh)=\sum_{i=0}C_n^i\Delta^if(x)\\
f(x-nh)=\sum_{i=0}^n(-1)^iC_n^i\nabla^if(x)\\
f(x+nh)=\sum_{i=0}^nC_n^i\delta^if(x+\frac i2h)
\]</span> 最后，对于满足 <span
class="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span>
的样本点，我们有： <span class="math display">\[
f[x_0,x_1,...,x_n]=\frac{\Delta^nf(x_0)}{n!h^n}=\frac{\nabla^nf(x_n)}{n!h^n}
\]</span> 对于中心差分则需要分样本点的奇偶个数作讨论，原理类似</p>
<h4 id="差分表">差分表</h4>
<p>可以用差商表类似的方法构造差分表以计算差分，以向前差分为例：</p>
<p><span class="math display">\[
\left[
\begin{array}{}
x_i=x_0+ih &amp; \Delta &amp; \Delta^2 &amp; \Delta^3 &amp; ...  &amp;
\Delta^{n-1} &amp; \Delta^n\\
x_0 &amp; \Delta f(x_0) &amp; \Delta^2 f(x_0) &amp; \Delta^3 f(x_0)
&amp;  ... &amp;\Delta^{n-1} f(x_0)&amp; \Delta^n f(x_0)\\
x_1 &amp; \Delta f(x_1) &amp; \Delta^2 f(x_1) &amp; \Delta^3 f(x_1)
&amp;  ... &amp;\Delta^{n-1} f(x_1)&amp;\\
x_2 &amp; \Delta f(x_2) &amp; \Delta^2 f(x_2) &amp; \Delta^3 f(x_2)
&amp;  ...\\
... &amp; ... &amp; ... &amp; ... &amp; ... \\
x_{n-1} &amp; \Delta f(x_{n-1}) &amp; \Delta^2 f(x_{n-1}) \\
x_n &amp; \Delta f(x_n)
\end{array}
\right]
\]</span></p>
<h3 id="newton-前插和后插公式"><span
class="math inline">\(Newton\)</span> 前插和后插公式</h3>
<p>考虑样本点满足 <span class="math inline">\(x_k-x_{k-1}=h,\forall
k=1,2,..,n\)</span> 的情形，利用均差和向前差分的关系，作变换：<span
class="math inline">\(x=x_0+sh\)</span> <br>从而 <span
class="math inline">\(Newton\)</span> 插值公式可以整理为： <span
class="math display">\[
N_n(x)=N_n(x_0+sh)=\sum_{k=0}^n\left(\begin{array}{}s\\k\end{array}\right)\Delta^kf(x_0)\\
\left(\begin{array}{}s\\k\end{array}\right)=\frac{s(s-1)...(s-k+1)}{k!}
\]</span> 即 <span class="math inline">\(Newton\)</span>
前插公式；利用向后差分，作变换：<span
class="math inline">\(x=x_n+th\)</span>，同理有： <span
class="math display">\[
N_n(x)=N_n(x_n+th)=\sum_{k=0}^n\left(\begin{array}{}-t\\k\end{array}\right)(-1)^k\nabla^kf(x_n)\\
\left(\begin{array}{}-t\\k\end{array}\right)(-1)^k=\frac{t(t+1)...(t+k-1)))}{k!}
\]</span> 即 <span class="math inline">\(Newton\)</span> 后插公式</p>
<h2 id="hermite-插值">Hermite 插值</h2>
<p>在 <span class="math inline">\(Hermite\)</span>
插值中我们不仅已知样本点的值，还知道样本点的前 <span
class="math inline">\(n\)</span>
阶导数值，因而我们希望寻求一插值多项式使得其导数值也与我们的已知数据符合，下面讨论
<span class="math inline">\(n=1\)</span> 的简单情形：</p>
<p>设已知 <span class="math inline">\(f(x)\)</span> 在插值基点 <span
class="math inline">\(x_0,x_1,...,x_n\)</span> 处的函数值分别为 <span
class="math inline">\(y_0,y_1,...,y_n\)</span> 以及一阶导数值分别为
<span class="math inline">\(y&#39;_0,y&#39;_1,...,y&#39;_n\)</span>
<br>我们试求一多项式 <span class="math inline">\(H_{2n+1}\in
R[x]_{2n+2}\)</span> 使得： <span class="math display">\[
\left\{ \begin{aligned}
H_{2n+1}(x_i)=y_i\\
H&#39;_{2n+1}(x_i)=y&#39;_i
\end{aligned}\right.
\]</span> 不妨设： <span class="math display">\[
H_{2n+1}=\sum_{i=0}^ny_iA_i(x)+\sum_{i=0}^ny&#39;_iB_i(x)\\
A_i(x_j)=\delta_{ij},\:A&#39;_i(x_j)=0\\
B_i(x_j)=0,\:B&#39;_i(x_j)=\delta_{ij}
\]</span> 可以通过分析 <span class="math inline">\(A_i,\:B_i\)</span>
各自零点的重数设出其形式进而求解，最后可以得到： <span
class="math display">\[
B_i(x)=(x-x_i)l_i^2(x)\\
A_i(x)=\left(1-2(x-x_i)\sum_{j=0,j\neq
i}^n\frac1{x_i-x_j}\right)l_i^2(x)
\]</span> 与 <span class="math inline">\(Lagrange\)</span>
插值类似，可以证明 <span class="math inline">\(Hermite\)</span>
插值的唯一性，以及其余项可表示为： <span class="math display">\[
r(x)=\frac{f^{(2n+2)}(\xi)}{(2n+2)!}\omega_{n+1}^2(x)
\]</span></p>
<h2 id="分段插值">分段插值</h2>
<p>为了解决高次多项式插值带来的 <span
class="math inline">\(Runge\)</span>
现象，可以使用分段插值，也就是将插值区间细分为若干子区间，并在这些子区间内使用较低次数的多项式进行插值的办法，其中最简单的分段插值就是<strong>分段线性插值</strong></p>
<h3 id="分段插值误差界">分段插值误差界</h3>
<p>直观上，采用分段插值时，子区间分的越细，那么分段插值的误差界应该越小
<br>下面我们考虑将插值区间分为等距基点 <span
class="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span>
的情形，由之前对余项的讨论，有：</p>
<ul>
<li><p>分段线性插值： <span class="math display">\[
|e_{f_1(x)}|\leq\frac{1}8Mh^2\\
M=\mathop{max}\limits_{x\in[a,b]}|f&#39;&#39;(x)|
\]</span></p></li>
<li><p>分段抛物线插值（即每一个区间含三个基点采用二次多项式插值）：
<span class="math display">\[
|e_{f_2(x)}|\leq\frac{\sqrt{3}}{27} M h^3\\
M=\mathop{max}\limits_{x\in[a,b]}|f&#39;&#39;&#39;(x)|
\]</span></p></li>
</ul>
<h3 id="三次样条插值">三次样条插值</h3>
<p>直接作分段插值的一个严重的问题是得到的结果往往不光滑，因而我们可以考虑在每一区间
<span class="math inline">\([x_i,x_{i+1}]\)</span>
上采用三次多项式插值，并要求每一段的拼接点的导数以及二阶导数相等，这种插值办法被称为三次样条插值</p>
<p>直观上，我们需要求解 <span class="math inline">\(4n\)</span>
个待定系数，然而假设的条件只能给出 <span
class="math inline">\(4n-2\)</span>
个方程，因而我们需要附加两个条件，常采用边界条件：</p>
<ul>
<li>自然边界条件：取插值函数在 <span class="math inline">\(x_0,
x_n\)</span> 处的二阶导数为 <span
class="math inline">\(0\)</span>，这样得到的插值称为<strong>自然三次样条插值</strong></li>
<li>完备边界条件：假设我们已知待插值函数 <span
class="math inline">\(f\)</span> 在端点处的导数值，取插值函数在 <span
class="math inline">\(x_0, x_n\)</span>
处的导数与之相等即可，这样得到的插值称为<strong>完备三次样条插值</strong></li>
</ul>
<p>下面简要讨论具体的计算，给定 <span
class="math inline">\([a,b]\)</span> 的一组基点： <span
class="math display">\[
a=x_1&lt;x_2&lt;...&lt;x_{n+1}=b
\]</span> 记 <span class="math inline">\([x_i,x_i+1]\)</span>
上的三次插值多项式为 <span
class="math inline">\(S_i(x),\:i=1,2,...,n\)</span>，已知条件为： <span
class="math display">\[
S_{i-1}(x_i)=S_i(x_i)=f(x_i),\:i=2,...,n\\
S&#39;_{i-1}(x_i)=S&#39;_i(x_i),\:i=2,...,n\\
S&#39;&#39;_{i-1}(x_i)=S&#39;&#39;_i(x_i),\:i=2,...,n\\
S_1(x_1)=f(x_1),\:S_n(x_{n+1})=f(x_{n+1})
\]</span> 记 <span
class="math inline">\(S&#39;&#39;_i(x_i)=m_i,\:h_i=x_{i+1}-x_i\)</span>，因为
<span class="math inline">\(deg\:S&#39;&#39;_i=1\)</span>，结合 <span
class="math inline">\(S&#39;&#39;_{i-1}(x_i)=S&#39;&#39;_i(x_i)\)</span>
就知道其必形如： <span class="math display">\[
S&#39;&#39;_i(x)=m_i\frac{x_{i+1}-x}{h_i}+m_{i+1}\frac{x-x_i}{h_i}
\]</span> 对其积分得： <span class="math display">\[
S&#39;_i(x)=-m_i\frac{(x_{i+1}-x)^2}{2h_i}+m_{i+1}\frac{(x-x_i)^2}{2h_i}+A_i\\
S_i(x)=m_i\frac{(x_{i+1}-x)^3}{6h_i}+m_{i+1}\frac{(x-x_i)^3}{6h_i}+A_i(x-x_i)+B_i
\]</span> 结合 <span
class="math inline">\(S_i(x_i)=f(x_i),\:S_i(x_{i+1})=f(x_{i+1})\)</span>
可以解得： <span class="math display">\[
B_i=f(x_i)-m_i\frac{h_i^2}6\\
A_i=f[x_i,x_{i+1}]-\frac{h_i}6(m_{i+1}-m_i)
\]</span> 再由 <span
class="math inline">\(S&#39;_{i-1}(x_i)=S&#39;_i(x_i)\)</span> 就得到：
<span class="math display">\[
h_{i-1}m_{i-1}+2(h_{i-1}+h_i)m_i+h_im_{i+1}=6(f[x_i,x_{i+1}]-f[x_{i-1},x_i])
\]</span> 也就是： <span class="math display">\[
\left(\begin{array}{}
h_1 &amp;2(h_1+h_2) &amp; h_2 &amp; 0 &amp; ... &amp; 0 \\
0 &amp; h_2 &amp;2(h_2+h_3) &amp; h_3 &amp; ... &amp; 0 \\
... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... \\
0 &amp; ... &amp; h_{n-2} &amp;2(h_{n-2}+h_{n-1}) &amp; h_{n-1} &amp;
0\\
0 &amp; 0 &amp; ... &amp; h_{n-1} &amp;2(h_{n-1}+h_{n}) &amp; h_{n}
\end{array}\right)
\left(\begin{array}{}
m_1\\
m_2\\
...\\
m_n\\
m_{n+1}
\end{array}\right)=6
\left(\begin{array}{}
d_2\\
d_3\\
...\\
d_{n-1}\\
d_n
\end{array}\right)\\\\
d_i=f[x_i,x_{i+1}]-f[x_{i-1},x_i]
\]</span> 前已述该方程没有唯一解，需要补上一定的边界条件，即：</p>
<ul>
<li><p>自然边界条件：<span
class="math inline">\(m_1=m_{n+1}=0\)</span></p></li>
<li><p>完备边界条件：<span
class="math inline">\(S&#39;_1(a)=f&#39;(a),\:S&#39;_n(b)=f&#39;(b)\)</span>，进而：
<span class="math display">\[
2h_1m_1+h_1m_2=6(f[x_1,x_2]-f&#39;(a))\\
h_nm_n+2h_nm_{n+1}=6(f&#39;(b)-f[x_n,x_{n+1}])
\]</span></p></li>
</ul>
<p>补上这些边界条件即有唯一解</p>
<h3 id="基样条插值">基样条插值</h3>
<p>注意到 <span class="math inline">\(Lagrange\)</span>
插值多项式总可以写成 <span class="math inline">\(Lagrange\)</span>
基本多项式 <span class="math inline">\(l_i(x)\)</span>
的线性组合，亦可寻找一<strong>基三次样条系</strong>来表示三次样条插值函数</p>
<p>常见的办法是构造一在区间 <span class="math inline">\([-2,2]\)</span>
上的分段三次多项式 <span
class="math inline">\(\varphi(x)\)</span>，使得其在 <span
class="math inline">\(x=-1,0,1\)</span>
上面的取值以及导数值，二阶导数值较好，以及在 <span
class="math inline">\(x=-2,2\)</span> 上的函数值，导数值，二阶导数值均为
<span
class="math inline">\(0\)</span>，从而可以通过将其根据实际的基点位置作平移和伸缩变换得到一系列基函数</p>
<h1 id="函数逼近">函数逼近</h1>
<h2 id="正交函数系">正交函数系</h2>
<p>称 <span class="math inline">\(W(x)\)</span> 为 <span
class="math inline">\([a,b]\)</span> 上的权函数，若满足：</p>
<ul>
<li>在 <span class="math inline">\((a,b)\)</span> 中，<span
class="math inline">\(W(x)\geq 0\)</span>，且只有有限个零点</li>
<li><span class="math inline">\(\int_a^bx^iW(x)dx,i=1,2,...\)</span>
存在且有限</li>
</ul>
<p>则对于非负连续函数 <span class="math inline">\(f\)</span>，若 <span
class="math inline">\(\int_a^bf(x)W(x)dx=0\)</span>，则在 <span
class="math inline">\([a,b]\)</span> 上有 <span
class="math inline">\(f(x)\equiv 0\)</span></p>
<p>给定 <span class="math inline">\(f,g\in C[a,b]\)</span>，称 <span
class="math inline">\((f,g)=\int_a^bW(x)f(x)g(x)dx\)</span> 为函数 <span
class="math inline">\(f,g\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上关于权 <span
class="math inline">\(W(x)\)</span> 的内积
<br>（满足内积的各种性质，亦可以由此定义范数）</p>
<p>我们常用下面三类范数： <span class="math display">\[
\Vert f\Vert_\infty=\mathop{max}_\limits{x\in[a,b]}|f(x)W(x)|\\
\Vert f\Vert_1=\int_a^b|f(x)W(x)|dx\\
\Vert f\Vert_2=\sqrt{(f,f)}
\]</span></p>
<p>称函数系 <span class="math inline">\(\{f_n(x)\}\)</span> 为 <span
class="math inline">\([a,b]\)</span> 上关于权函数 <span
class="math inline">\(W(x)\)</span> 的正交函数系，若 <span
class="math inline">\((f_i,f_j)=A_i\delta_{ij}\)</span></p>
<h3 id="线性无关">线性无关</h3>
<p>可以与线性代数理论类似考虑一族函数的线性无关性，称函数系 <span
class="math inline">\(\{f_n(x)\}\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上线性无关，若： <span
class="math display">\[
\sum_{i=0}^na_if_i=0 \Rightarrow a_i=0,\forall i=0,1,...,n
\]</span> 可以证明这等价于： <span class="math display">\[
\left|
\begin{array}{}
(f_0,f_0) &amp; (f_0,f_1) &amp;... &amp;(f_0,f_n)\\
(f_1,f_0) &amp; (f_1,f_1) &amp;... &amp;(f_1,f_n)\\
... &amp; ... &amp; ... &amp; ... \\
(f_n,f_0) &amp; (f_n,f_1) &amp;... &amp;(f_n,f_n)
\end{array}
\right|\neq0
\]</span> 该行列式被称为 <span class="math inline">\(Gram\)</span>
行列式</p>
<p>可以用 <span class="math inline">\(Schmidt\)</span>
正交化将一族线性无关函数化为正交函数系，即： <span
class="math display">\[
\varphi_0=f_0\\
\varphi_n=f_n-\sum_{i=0}^{n-1}\frac{(f_n,\varphi_i)}{(\varphi_i,\varphi_i)}\varphi_i
\]</span></p>
<h2 id="直交多项式">直交多项式</h2>
<p>取线性无关的多项式序列 <span
class="math inline">\(\{1,x,...,x^n\}\)</span>，称由此通过 <span
class="math inline">\(Schmidt\)</span>
正交化得到的正交函数系为直交多项式 <span
class="math inline">\(\{p_n(x)\}\)</span> <br>可以证明有递推关系： <span
class="math display">\[
\begin{aligned}
&amp;p_{k+1}(x)=(x-\alpha_k)p_k(x)-\beta_kp_{k-1}(x)\\
&amp;p_0=1,\:p_{-1}=0\\
&amp;其中:\\
&amp;\alpha_k=\frac{(xp_k(x),p_k(x))}{(p_k(x),p_k(x))}\\
&amp;\beta_k=\left\{
\begin{align}
&amp;\frac{(p_k(x),p_k(x))}{(p_{k-1}(x),p_{k-1}(x))},k\geq1\\
&amp;0,k=0
\end{align}
\right.\\
\end{aligned}
\]</span></p>
<h3 id="chebyshev-多项式"><span class="math inline">\(Chebyshev\)</span>
多项式</h3>
<p>取权函数 <span
class="math inline">\(W(x)=\frac1{\sqrt{1-x^2}}\)</span>，区间 <span
class="math inline">\([a,b]=[-1,1]\)</span>，由此得到 <span
class="math inline">\(Chebyshev\)</span> 多项式，可表示为： <span
class="math display">\[
T_n(x)=cos(n\:arccos\:x)
\]</span> 显然，取 <span
class="math inline">\(x=cos\theta\)</span>，据三角公式就有： <span
class="math display">\[
T_{n\pm1}(x)=cos(n\pm1)\theta=cos(n\theta)cos\theta\mp
sin(n\theta)sin\theta
\]</span> 两式相加就能得到递推关系： <span class="math display">\[
T_{n+1}(x)+T_{n-1}(x)=2xT_n(x)
\]</span> 利用 <span class="math inline">\(Euler\)</span>
公式，有：<span
class="math inline">\(cos\:n\theta=\frac{e^{in\theta}+e^{-in\theta}}2\)</span>，由此亦可直接证明：
<span class="math display">\[
T_n(x)=\frac12\left((x+\sqrt{x^2-1})^n+(x-\sqrt{x^2-1})^n\right)
\]</span></p>
<h4 id="近似最佳一致逼近">近似最佳一致逼近</h4>
<p>固定 <span class="math inline">\(z&gt;1\)</span>，记 <span
class="math inline">\(\theta_n \subseteq R[x]_{n+1}\)</span> 为满足条件
<span class="math inline">\(\forall p_n \in \theta_n\)</span> ，都有
<span class="math inline">\(p_n(z)=1\)</span> 的集合，那么： <span
class="math display">\[
\left\Vert\frac{T_n(x)}{T_n(z)}\right\Vert_\infty=\mathop{inf}_\limits{p_n\in
\theta_n}\Vert p_n \Vert_\infty
\]</span> 类似地，记 <span class="math inline">\(\bar{T}_n(x)\)</span>
为 <span class="math inline">\(T_n(x)\)</span>
的首一化多项式，也就是：<span
class="math inline">\(\bar{T}_n(x)=\frac1{2^{n-1}}T_n(x)\)</span>，那么任给
<span class="math inline">\(n\)</span> 次首一多项式 <span
class="math inline">\(p_n(x)\)</span>，都有： <span
class="math display">\[
\Vert
p_n\Vert_\infty\geq\Vert\bar{T}_n\Vert_\infty=\frac1{2^{n-1}}\:\:\:\:(W(x)=1)
\]</span> 当且仅当 <span class="math inline">\(p_n=\bar{T}_n\)</span>
时取等，这说明要想使得对定义在 <span
class="math inline">\([-1,1]\)</span> 上的函数 <span
class="math inline">\(f\)</span> 作 <span
class="math inline">\(n\)</span>
次多项式插值得到的余项较小，可以将插值基点选取为 <span
class="math inline">\(T_{n+1}(x)\)</span> 的零点，即： <span
class="math display">\[
x_i=cos\frac{(2i+1)\pi}{2(n+1)},i=0,1,...,n
\]</span> 对于一般的定义在 <span class="math inline">\([a,b]\)</span>
上的函数 <span
class="math inline">\(f\)</span>，作平移和伸缩变换再类似处理即可，也就是：
<span class="math display">\[
[a,b]\to[-1,1]:x\to\frac2{b-a}(x-\frac{b-a}2)\\
\frac2{b-a}(x_i-\frac{b-a}2)=cos\frac{(2i+1)\pi}{2(n+1)},i=0,1,...,n
\]</span></p>
<p>由此可以得到一个近似的最佳一致逼近多项式，关于最佳一致逼近的具体讨论在后续部分</p>
<h4 id="第二类-chebyshev-多项式">第二类 <span
class="math inline">\(Chebyshev\)</span> 多项式</h4>
<p>与第一类的唯一差别是权函数取为 <span
class="math inline">\(W(x)=\sqrt{1-x^2}\)</span>，将其记为 <span
class="math inline">\(\{U_n(x)\}\)</span>，可以表示为： <span
class="math display">\[
U_n(x)=\frac{sin\left((n+1)arccos\:x\right)}{\sqrt{1-x^2}}
\]</span> 其与第一类有关系式： <span class="math display">\[
T_{n+1}&#39;(x)=(n+1)U_n(x)
\]</span></p>
<h3 id="legendre-多项式"><span class="math inline">\(Legendre\)</span>
多项式</h3>
<p>取最简单的权函数 <span class="math inline">\(W(x)=1\)</span>，区间
<span class="math inline">\([a,b]=[-1,1]\)</span>，得 <span
class="math inline">\(Legendre\)</span> 多项式，可以表示为： <span
class="math display">\[
p_n(x)=\frac1{2^nn!}\frac{d^n}{dx^n}(x^2-1)^n
\]</span>
其用处在这门课主要体现在<strong>高斯型求积公式</strong>中，此处暂且不谈</p>
<h2 id="最佳一致逼近">最佳一致逼近</h2>
<p>取 <span class="math inline">\(W(x)=1\)</span>，设 <span
class="math inline">\(f\in C[a,b]\)</span>，若有一列函数 <span
class="math inline">\(\{f_n\}\)</span> 使得： <span
class="math display">\[
\lim_{n\to\infty}\Vert f-f_n\Vert_\infty=0
\]</span> 称 <span class="math inline">\(\{f_n\}\)</span> 为 <span
class="math inline">\(f\)</span> 的一致逼近函数，不难看出也就是在 <span
class="math inline">\([a,b]\)</span> 上一致收敛于 <span
class="math inline">\(f\)</span></p>
<p>我们在数学分析的课程上已经知道 <span
class="math inline">\(Weierstrass\)</span>
给出的关于多项式一致逼近的相关结果，即 <span
class="math inline">\(\forall \varepsilon&gt;0,\exists p_n(x)\)</span>
使得： <span class="math display">\[
\Vert f-p_n\Vert_\infty&lt;\varepsilon
\]</span> 然而我们知道多项式拟合的次数太高并不好，下面我们固定 <span
class="math inline">\(n\)</span>，考虑在次数不超过 <span
class="math inline">\(n\)</span> 的多项式集合 <span
class="math inline">\(H_n\)</span> 中寻求 <span
class="math inline">\(p_n\)</span> 使得： <span class="math display">\[
\Vert f-p_n\Vert_\infty=\mathop{inf}_\limits{q_n\in H_n}\Vert
f-q_n\Vert_\infty
\]</span>
这就是<strong>最佳一致逼近多项式</strong>问题，关于这个问题，<span
class="math inline">\(Chebyshev\)</span> 给出了以下结果：</p>
<ol type="1">
<li><p>设 <span class="math inline">\(a\leq x_1&lt;x_2&lt;...&lt;x_n\leq
b\)</span>，称 <span class="math inline">\(\{x_1,x_2,...,x_n\}\)</span>
为 <span class="math inline">\(f\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上的交错点组，若满足： <span
class="math display">\[
|f(x_i)|=\mathop{max}_\limits{x\in[a,b]}|f(x)|,\forall i=1,2,...,n\\
f(x_i)=-f(x_{i+1}),\forall i=1,2,...,n-1
\]</span></p></li>
<li><p>（<span class="math inline">\(Chebyshev\)</span> 定理）设 <span
class="math inline">\(p\in H_n\)</span>，则 <span
class="math inline">\(p\)</span> 是 <span
class="math inline">\(f\)</span> 的最佳一致逼近多项式当且仅当 <span
class="math inline">\(f(x)-p(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上存在 <span
class="math inline">\(n+2\)</span> 个点组成的交错点组</p></li>
<li><p>上述 <span class="math inline">\(p(x)\)</span> 在 <span
class="math inline">\(H_n\)</span> 中是唯一的</p></li>
<li><p>若 <span class="math inline">\(f^{(n+1)}(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 中不变号，则 <span
class="math inline">\(a,b\)</span> 属于交错点组</p></li>
</ol>
<h2 id="最佳平方逼近">最佳平方逼近</h2>
<p>与最佳一致逼近类似，只是考虑的范数由 <span
class="math inline">\(\infty\)</span> 范数改为了 <span
class="math inline">\(2\)</span> 范数，我们考察一般情形：</p>
<p>设 <span class="math inline">\(f\in C[a,b],\:\{\varphi_n\}\)</span>
为 <span class="math inline">\([a,b]\)</span>
上的线性无关函数族，我们希望寻求 <span
class="math inline">\(a_0,a_1,...,a_n\)</span> 使得： <span
class="math display">\[
\Vert f-\sum_{k=0}^na_k\varphi_k\Vert_2
\]</span>
达到极小；考察其平方不影响结果，从而可以使用多元函数求极值的办法给出结论：
<span class="math display">\[
F(a_0,a_1,...,a_n)=\int_a^b\left(f(x)-\sum_{k=0}^na_k\varphi_k(x)\right)^2W(x)dx\\
\frac{\partial F}{\partial
a_j}=2\int_a^b\left(f(x)-\sum_{k=0}^na_k\varphi_k(x)\right)(-\varphi_j(x))W(x)dx=0
\]</span> 也就是： <span class="math display">\[
\left(
\begin{array}{}
(\varphi_0,\varphi_0) &amp; (\varphi_0,\varphi_1) &amp;...
&amp;(\varphi_0,\varphi_n)\\
(\varphi_1,\varphi_0) &amp; (\varphi_1,\varphi_1) &amp;...
&amp;(\varphi_1,\varphi_n)\\
... &amp; ... &amp; ... &amp; ... \\
(\varphi_n,\varphi_0) &amp; (\varphi_n,\varphi_1) &amp;...
&amp;(\varphi_n,\varphi_n)
\end{array}
\right)
\left(
\begin{array}{}
a_0\\
a_1\\
...\\
a_n
\end{array}
\right)=\left(
\begin{array}{}
(f,\varphi_0)\\
(f,\varphi_1)\\
...\\
(f,\varphi_n)
\end{array}
\right)
\]</span> 这被称为<strong>法方程</strong>，据 <span
class="math inline">\(\{\varphi_n\}\)</span>
线性无关知其系数矩阵行列式不为 <span
class="math inline">\(0\)</span>，从而存在唯一解</p>
<p>特别地，若 <span class="math inline">\(\{\varphi_n\}\)</span>
为正交函数系，则系数矩阵为对角矩阵，进而直接有： <span
class="math display">\[
a_k=\frac{(f,\varphi_k)}{(\varphi_k,\varphi_k)}
\]</span> 进一步，如果让 <span
class="math inline">\(n\to\infty\)</span>，这就给出了 <span
class="math inline">\(f\)</span> 的广义 <span
class="math inline">\(Fourier\)</span> 级数</p>
<p>若正交函数系取为 <span class="math inline">\(Chebyshev\)</span>
多项式 <span class="math inline">\(\{T_n(x)\}\)</span>，由此就得到 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\([-1,1]\)</span> 上的 <span
class="math inline">\(Chebyshev\)</span> 级数： <span
class="math display">\[
f(x)=\frac12a_0+\sum_{n=1}^\infty a_nT_n(x)\\
a_k=\frac{(T_k,f)}{(T_k,T_k)}=\frac2\pi\int_{-1}^1T_k(x)f(x)\frac{dx}{\sqrt{1-x^2}}
\]</span></p>
<h3 id="离散情形">离散情形</h3>
<p>与连续情形类似，若已知 <span class="math inline">\(f\)</span>
在给定点集 <span class="math inline">\(\{x_1,x_2,...,x_m\}\)</span>
上的值，记： <span class="math display">\[
r_i=\sum_{j=0}^na_j\varphi_j(x_i)-f(x_i)
\]</span> 为<strong>残量</strong>，亦可寻求 <span
class="math inline">\(a_0,a_1,...,a_n\)</span> 使得： <span
class="math display">\[
\sum_{i=0}^mr_i^2
\]</span>
达到极小，这样的问题被称为<strong>离散的最佳平方逼近问题</strong>，也就是<strong>线性最小二乘拟合问题</strong>，在后续部分讨论</p>
<p>在等距点集情形，我们有著名的 <strong>DFT</strong> 以及
<strong>FFT</strong>，此前已作过其浅析，详见：<a
href="https://dasasdhba.github.io/study-FFT/"
class="uri">https://dasasdhba.github.io/study-FFT/</a></p>
<h1 id="数据拟合">数据拟合</h1>
<p>数据拟合问题是指寻求一函数 <span class="math inline">\(f(x)\)</span>
来拟合一组离散数据 <span
class="math inline">\(\{(x_i,y_i)\}_{i=1}^m\)</span>，与插值法不同，我们采用<strong>均方误差</strong>（mean-square
error MSE）来衡量拟合的好坏，也就是考虑： <span class="math display">\[
\mathcal{L}(f)=\frac1m\sum_{i=1}^m(f(x_i)-y_i)^2
\]</span> 一般地，给定函数族 <span
class="math inline">\(\mathcal{F}\)</span>，我们试图求解 <span
class="math inline">\(f\in\mathcal{F}\)</span> 使得： <span
class="math display">\[
\mathcal{L}(f)=\mathop{inf}_\limits{g\in\mathcal{F}}\mathcal{L}(g)
\]</span></p>
<h2 id="线性拟合">线性拟合</h2>
<p>下面介绍线性拟合的<strong>最小二乘法</strong>，这与最佳平方逼近是类似的</p>
<p>设 <span class="math inline">\(f\in C[a,b],\:\{\varphi_n\}\)</span>
为 <span class="math inline">\([a,b]\)</span>
上的线性无关函数族，我们希望寻求 <span
class="math inline">\(a_0,a_1,...,a_n\)</span> 使得： <span
class="math display">\[
\varphi(x)=\sum_{j=0}^na_j\varphi_j\\
\mathcal{L}(\varphi)=\frac1m\sum_{i=1}^m(\varphi(x_i)-y_i)^2
\]</span> 达到极小；类似地，可以使用多元微积分求极值的理论： <span
class="math display">\[
F(a_0,...,a_n)=\sum_{i=1}^m(\sum_{j=0}^na_j\varphi_j(x_i)-y_i)^2\\
\frac{\partial F}{\partial
a_k}=2\sum_{i=1}^m\varphi_k(x_i)(\sum_{j=0}^na_j\varphi_j(x_i)-y_i)=0
\]</span> 记 <span
class="math inline">\(Y=(y_1,...,y_m)^T,\:\Phi_i=(\varphi_i(x_1),...,\varphi_i(x_m))^T\)</span>，取
<span class="math inline">\(\mathbb{R}^m\)</span> 这个 <span
class="math inline">\(Euclid\)</span> 空间的通常内积 <span
class="math inline">\((X,Y)=X^TY\)</span>，则上述方程可以改写为： <span
class="math display">\[
\left(
\begin{array}{}
(\Phi_0,\Phi_0) &amp; (\Phi_0,\Phi_1) &amp;... &amp;(\Phi_0,\Phi_n)\\
(\Phi_1,\Phi_0) &amp; (\Phi_1,\Phi_1) &amp;... &amp;(\Phi_1,\Phi_n)\\
... &amp; ... &amp; ... &amp; ... \\
(\Phi_n,\Phi_0) &amp; (\Phi_n,\Phi_1) &amp;... &amp;(\Phi_n,\Phi_n)
\end{array}
\right)
\left(
\begin{array}{}
a_0\\
a_1\\
...\\
a_n
\end{array}
\right)=\left(
\begin{array}{}
(Y,\Phi_0)\\
(Y,\Phi_1)\\
...\\
(Y,\Phi_n)
\end{array}
\right)
\]</span> 由此即可解出 <span
class="math inline">\(a_0,...,a_n\)</span>；特别地，若取 <span
class="math inline">\(n=1,
\varphi_0(x)=1,\varphi_1(x)=x\)</span>，得到： <span
class="math display">\[
\begin{aligned}
&amp;\left\{\begin{align}
&amp;a_1=\frac{(\Phi_1,Y)-m\bar{x}\bar{y}}{(\Phi_1,\Phi_1)-m\bar{x}\bar{y}}=\frac{\sum_{i=1}^m(x_i-\bar{x})(y_i-\bar{y})}{\sum_{i=1}^m(x_i-\bar{x})^2}\\
&amp;a_0=\bar{y}-a_1\bar{x}\\
\end{align}\right.\\
&amp;其中:\\
&amp;\bar{x}=\sum_{i=1}^mx_i,\:\bar{y}=\sum_{i=1}^my_i
\end{aligned}
\]</span> 即中学阶段已经介绍过的最小二乘法求解回归直线方程</p>
<h3 id="过拟合现象">过拟合现象</h3>
<p>若取 <span
class="math inline">\(\{\varphi_n\}=\{x^n\}\)</span>，直观上 <span
class="math inline">\(n\)</span> 越大误差越小，然而与 <span
class="math inline">\(Runge\)</span>
现象类似，过高的拟合次数会产生<strong>过拟合现象</strong></p>
<h2 id="非线性拟合">非线性拟合</h2>
<p>非线性拟合是考虑用不能被一族函数的线性组合所表出的函数作拟合，如：
<span class="math display">\[
f(x)=\frac a{1+be^{cx}}
\]</span> 我们的目标是寻求待定系数 <span
class="math inline">\(a,b,c\)</span> 使得 <span
class="math inline">\(\mathcal{L}(f)\)</span> 达到极小</p>
<h3 id="线性化求近似解">线性化求近似解</h3>
<p>若有一向量值函数 <span class="math inline">\(F:\mathbb{R}^2 \to
\mathbb{R}^2\)</span> 使得 <span
class="math inline">\(\{F(x_i,y_i)\}_{i=1}^m\)</span>
可以用一族函数的线性组合来拟合，则可以使用线性拟合的办法求近似解
<br>（化曲为直）</p>
<p>举例，若离散数据符合非线性函数： <span class="math display">\[
y=\frac1{1+ae^{bx}}
\]</span> 这可以改写为： <span class="math display">\[
ln\left(\frac 1y-1\right)=bx+ln\:a
\]</span> 这就把问题转换为了线性拟合，注意到由此得到的是： <span
class="math display">\[
\bar{\mathcal{L}}(a,b)=\frac1m\sum_{i=0}^m\left|bx_i+lna-ln\left(\frac
1y_i-1\right)\right|^2
\]</span> 达到极小，故这是原非线性拟合问题的一个近似解</p>
<h3 id="梯度下降法">梯度下降法</h3>
<p>考虑使用非线性函数 <span
class="math inline">\(f(x;a_1,...,a_n)\)</span> 作非线性拟合，其中 <span
class="math inline">\(a_1,...,a_n\)</span>
为待定系数，我们试图寻求待定系数使得： <span class="math display">\[
F(a_1,...,a_n)=\mathcal{L}(f(x;a_1,...,a_n))
\]</span> 达到极小；据多元微积分理论，<span
class="math inline">\(\forall a \in \mathbb{R}^n\)</span>，<span
class="math inline">\(F\)</span> 在 <span
class="math inline">\(a\)</span> 处沿着梯度方向变化最快，其中梯度是指：
<span class="math display">\[
\nabla F(a)=\left(\frac{\partial F}{\partial a_1},...,\frac{\partial
F}{\partial a_n}\right)(a)
\]</span> （方便起见，这里没有加上转置符号）</p>
<p>因而可以通过从某一初值 <span class="math inline">\(a\)</span>
开始，沿着梯度方向不断迭代的办法近似求解 <span
class="math inline">\(F\)</span>
的极小值点，这被称为<strong>梯度下降法</strong>，算法如下： <span
class="math display">\[
\begin{aligned}
&amp;a=(b_1,...,b_n)\:为初值\\
&amp;\eta=10^{-4}\:为步长，又称学习率\\
&amp;\varepsilon=10^{-8}\:为终止条件\\
\\
&amp;while\;\Vert\nabla F(a)\Vert_2 \geq \varepsilon:\\
&amp;\;\;\;\;a=a-\eta\:\nabla F(a)
\end{aligned}
\]</span> 其中 <span class="math inline">\(\eta\)</span>
的选取至关重要，太大没法收敛，太小收敛太慢；另一方面，这种算法显然只能得到局部极小值，不能保证其为全局极小值点，因而适当的选取初值也较为重要，可以通过线性化先求解一近似解作为初值</p>
<h1 id="数值微积分">数值微积分</h1>
<p>假设需要处理的函数十分复杂，又或者我们只知道一些离散点 <span
class="math inline">\(\{x_n,y_n\}\)</span>
的数据，此时需要考察求解微分以及积分的近似值的方法。</p>
<h2 id="数值微分">数值微分</h2>
<p>数值微分比较容易，因为只需要近似求解一个极限，下面记需要考察的函数为
<span class="math inline">\(f\)</span></p>
<h3 id="差商法">差商法</h3>
<p>据定义，可直接取 <span
class="math inline">\(\frac{f(x+h)-f(x)}h\)</span>
作为近似值，即向前差商法；同理还有向后差商法和中心差商法。</p>
<p>以向前差商法为例考察误差，据 <span
class="math inline">\(Taylor\)</span> 展开，有： <span
class="math display">\[
f(x+h)=f(x)+hf&#39;(x)+\frac{h^2}{2!}f&#39;&#39;(\xi)
\]</span> 由此不难看出误差为 <span
class="math inline">\(O(h)\)</span></p>
<h3 id="插值法-1">插值法</h3>
<p>取插值函数 <span class="math inline">\(L(x)\simeq
f(x)\)</span>，并以插值函数的导数作为近似的方法<br>之前已讨论过插值函数的误差，从而不难估计此法的误差</p>
<h2 id="数值积分">数值积分</h2>
<p>假设我们只知道离散点 <span
class="math inline">\(\{x_n,f(x_n)\}\)</span> 的数据，我们尝试考察 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上关于权函数 <span
class="math inline">\(W(x)\)</span> 的积分： <span
class="math display">\[
I(f)=\int_a^bf(x)W(x)dx
\]</span> 称基于这些数据给出的公式： <span class="math display">\[
I_n(f)=\sum_{i=0}^na_if(x_i)
\]</span> 为<strong>数值积分公式</strong>，其中 <span
class="math inline">\(a_i\)</span> 为待定系数。为衡量公式的精确度，称
<span class="math inline">\(I_n(f)\)</span> 有 <strong>k
阶代数精度</strong>，若： <span class="math display">\[
I_n(x^i)=I(x_i),i=0,1,...,k,\:I_n(x^{k+1})\neq I(x^{k+1})
\]</span></p>
<h3 id="插值法-2">插值法</h3>
<p>与数值微分不同，若想直接使用积分定义作近似，作 <span
class="math inline">\(Riemann\)</span> 和难以估计误差，而以 <span
class="math inline">\(Lebesgue\)</span>
积分的观点来考察简单函数的逼近则更加困难，因而数值积分基本上只有插值法。以
<span class="math inline">\(Lagrange\)</span> 插值为例： <span
class="math display">\[
I_n(f)=\int_a^bL_n(x)W(x)dx=\sum_{i=0}^n\left(\int_a^bl_i(x)W(x)dx\right)f(x_i)
\]</span> 据 <span class="math inline">\(Lagrange\)</span>
插值的性质，不难看出此法的代数精度至少为 <span
class="math inline">\(n\)</span>，误差由插值函数的误差作积分给出</p>
<h2 id="函数的数值积分">函数的数值积分</h2>
<p>与之前讨论的仅知道离散点数据的情形不同，以下假设我们需要考察的被积函数
<span class="math inline">\(f\)</span> 为已知函数，积分区间为 <span
class="math inline">\([a,b]\)</span><br>尽管仍然只能采取插值法，然而我们可以自由地选取插值基点，由此可以深入研究各种方法</p>
<h3 id="newton-cotes-求积公式">Newton-Cotes 求积公式</h3>
<p>我们考察 <span class="math inline">\(W(x)=1\)</span>，插值基点为
<span class="math inline">\(n+1\)</span> 个等距基点（步长 <span
class="math inline">\(h=\frac{b-a}n\)</span>）的情形，此时有： <span
class="math display">\[
a_i=\int_a^bl_i(x)=\frac {(-1)^{n+1-i}\;h}{(i-1)!(n+1-i)!}
\int_0^n\prod_{j=0,j\neq i-1}^n(t-j)dt
\]</span> 若 <span class="math inline">\(n\)</span> 为偶数，且 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上有 <span
class="math inline">\(n+2\)</span> 阶连续导数，那么误差： <span
class="math display">\[
E_n(f)=\frac{h^{n+3}f^{(n+2)}(\eta)}{(n+2)!}\int_0^nt\prod_{j=0}^n(t-j)dt
\]</span> 若 <span class="math inline">\(n\)</span> 为奇数，且 <span
class="math inline">\(f(x)\)</span> 在 <span
class="math inline">\([a,b]\)</span> 上有 <span
class="math inline">\(n+1\)</span> 阶连续导数，那么误差： <span
class="math display">\[
E_n(f)=\frac{h^{n+2}f^{(n+1)}(\eta)}{(n+1)!}\int_0^nt\prod_{j=0}^n(t-j)dt
\]</span> 还需要考虑舍入误差可能带来的数值不稳定性，有估计： <span
class="math inline">\(|I_n(f)-I_n^*(f)|\leq\varepsilon\sum_{i=0}^n|a_i|\)</span>，其中
<span class="math inline">\(\varepsilon\)</span> 为最大的舍入误差<br>取
<span class="math inline">\(f(x)=1\)</span>，此时若 <span
class="math inline">\(n\geq8\)</span>，那么存在 <span
class="math inline">\(a_i&lt;0\)</span>，这会使得数值不稳定</p>
<p>通常我们只采用 <span class="math inline">\(n=1\)</span> 或 <span
class="math inline">\(n=2\)</span>
的情形（原因见下节），这分别对应<strong>梯形公式</strong>与
<strong><span class="math inline">\(Simpson\)</span> 公式</strong></p>
<ul>
<li><p>梯形公式：<span
class="math inline">\(I_1(f)=\frac{b-a}2(f(a)+f(b))\)</span></p>
<p>直观上，这是以梯形面积作为近似，因而叫梯形公式</p></li>
<li><p><span class="math inline">\(Simpson\)</span> 公式：<span
class="math inline">\(I_2(f)=\frac{b-a}6\left(f(a)+4f(\frac{a+b}2)+f(b)\right)\)</span></p>
<p>直观上，这是以两端以及中点所作抛物线的面积作为近似，因而也叫抛物线公式</p></li>
</ul>
<h3 id="复合求积公式">复合求积公式</h3>
<p>前已述不能考虑通过提高 <span
class="math inline">\(Newton-Cotes\)</span>
求积公式的阶数来减少误差，而另一方面，积分具有区间可加性，这启发我们将
<span class="math inline">\([a,b]\)</span>
分成若干小段，并对每一段分别使用梯形公式或 <span
class="math inline">\(Simpson\)</span>
公式再求和，这就是复合求积公式。</p>
<p>下面考虑将 <span class="math inline">\([a,b]\)</span> 分为 <span
class="math inline">\(n\)</span> 段，进而步长为 <span
class="math inline">\(h=\frac{b-a}n\)</span>，为了衡量复合求积公式的精确度，称公式
<span class="math inline">\(p\)</span> 阶收敛，若： <span
class="math display">\[
\lim_{h\to0}\frac{I(f)-I_n(f)}{h^p}=C&lt;\infty,\:C\neq0
\]</span> 下面分别考虑使用梯形公式和 <span
class="math inline">\(Simpson\)</span> 公式作复合求积：</p>
<ul>
<li><p>复合梯形公式：<span class="math inline">\(T_n(f)=\frac
h2(f(a)+f(b)+2\sum_{i=1}^{n-1}f(a+ih))\)</span></p>
<p>误差：<span
class="math inline">\(E_n(f)=-\frac{h^2(b-a)}{12}f&#39;&#39;(\xi)\)</span>，因而是
<span class="math inline">\(2\)</span> 阶收敛的</p></li>
<li><p>复合 <span class="math inline">\(Simpson\)</span> 公式（为统一
<span class="math inline">\(h\)</span> 的值，假定 <span
class="math inline">\(n\)</span> 为偶数，将 <span
class="math inline">\([a,b]\)</span> 分为 <span
class="math inline">\(m=\frac n2\)</span> 段）： <span
class="math display">\[
S_n(f)=\frac
h3\left(f(a)+f(b)+4\sum_{i=1}^mf(a+(2i-1)h)+2\sum_{i=1}^{m-1}f(a+2ih)\right)
\]</span> 误差：<span
class="math inline">\(E_m(f)=-\frac{h^4(b-a)}{180}f^{(4)}(\xi)\)</span>，因而是
<span class="math inline">\(4\)</span> 阶收敛的</p></li>
</ul>
<p>可见，使用复合求积公式，只要通过控制 <span
class="math inline">\(h\)</span>，就可以有效地控制误差，因而我们并不需要使用高阶的
<span class="math inline">\(Newton-Cotes\)</span> 求积公式<br></p>
<h3 id="区间逐次分半法">区间逐次分半法</h3>
<p>书接上回，使用复合求积公式时，若想控制误差界为给定的 <span
class="math inline">\(\varepsilon\)</span>，由其误差估计式，往往需要考察
<span class="math inline">\(f\)</span> 的高阶导数，这会带来麻烦。</p>
<p>为此，常使用一种被称为<strong>区间逐次分半</strong>的办法——不断将区间二分，直到达到精度要求</p>
<p>由于我们不希望直接考察误差估计式，常常采用以下办法近似（以复合梯形公式为例）：<br>我们知道：
<span class="math display">\[
E_n(f)=I(f)-T_n(f)=-\frac{h^2(b-a)^3}{12n^2}f&#39;&#39;(\xi_1)\\
E_{2n}(f)=I(f)-T_{2n}(f)=-\frac{h^2(b-a)^3}{12\times4n^2}f&#39;&#39;(\xi_2)
\]</span> 如果我们认为：<span
class="math inline">\(f&#39;&#39;(\xi_1)\simeq
f&#39;&#39;(\xi_2)\)</span>，那么 <span
class="math inline">\(E_n(f)\simeq 4E_{2n}(f)\)</span>，由此可以推出：
<span class="math display">\[
E_{2n}(f)\simeq \frac13(T_{2n}(f)-T_n(f))
\]</span> 这样，我们就回避了直接考察 <span
class="math inline">\(f&#39;&#39;\)</span></p>
<p>另一方面，若记 <span class="math inline">\(n=2^{m-1}\)</span> ，即将
<span class="math inline">\([a,b]\)</span> 作 <span
class="math inline">\(2^{m-1}\)</span> 等分，记由此得到的梯形值为 <span
class="math inline">\(T_{m,1}\)</span>（下标与 <span
class="math inline">\(T_n\)</span> 作区分，无其他含义），那么： <span
class="math display">\[
T_{m,1}=\frac12\left(T_{m-1,1}+h_{m-1}\sum_{k=1}^{2^{m-2}}f(a+(k-\frac12)h_{m-1})\right)\\
h_m=\frac{b-a}{2^{m-1}}
\]</span> 即每一次半分时存在递推关系，降低了计算量；事实上，后面会介绍
<span class="math inline">\(Romberg\)</span>
积分法，想法与此十分相似</p>
<h3 id="自适应积分法">自适应积分法</h3>
<p>在区间逐次分半法中，每次我们都将区间的等分数量翻倍，尽管有递推式，但这样做仍然会导致速度较慢。<br>然而事实上，我们可以将需要控制的误差界
<span class="math inline">\(\varepsilon\)</span> 在等分的 <span
class="math inline">\(n\)</span>
个区间上分别考虑，<br>只要每个区间上的误差都不超过 <span
class="math inline">\(\frac\varepsilon
n\)</span>，那么也能达到同样的目的</p>
<p>这样，我们只需要对那些误差超过 <span
class="math inline">\(\frac\varepsilon n\)</span>
的区间应用逐次分半法，这就是<strong>自适应积分法</strong>。<br>不难看出，这种办法很适合递归实现：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">self_adaptive_integral</span><span class="params">(f,a,b,eps)</span></span></span><br><span class="line">	<span class="keyword">if</span> numeric_integral_err(f,a,b) &lt; <span class="built_in">eps</span></span><br><span class="line">		y = numeric_integral(f,a,b);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		c = (a+b)/<span class="number">2</span>;</span><br><span class="line">		y = self_adaptive_integral(f,a,c,<span class="built_in">eps</span>/<span class="number">2</span>) + self_adaptive_integral(f,c,b,<span class="built_in">eps</span>/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>numeric_integral()</code>
是某个数值积分公式，<code>numeric_integral_err()</code>
往往类似于区间逐次分半法中的误差估计方法</p>
<p>需要指出的是，由于分半的过程中，各个区间需要处理的误差界也在减半，因而此法容易陷入无限递归，应当加上递归层数的限制</p>
<h3 id="euler-maclaurin-公式"><span
class="math inline">\(Euler-Maclaurin\)</span> 公式</h3>
<p>后面会稍微用到，但用得不多，故只给出相关结果，证明略</p>
<p>记 <span class="math inline">\(B_n\)</span> 为 <span
class="math inline">\(Bernoulli\)</span> 数，这是由：<span
class="math inline">\(\frac{x}{e^x-1}=\sum_{n=0}^\infty
\frac{B_n}{n!}x^n\)</span> 给出的，显式公式为： <span
class="math display">\[
B_n=\sum_{k=0}^n\frac1{k+1}\sum_{r=0}^kC_k^r(-1)^rr^n
\]</span> 设 <span class="math inline">\(a,b\in\mathbb{N},\:f\in
C^\infty[a,b]\)</span>，那么有 <span
class="math inline">\(Euler-Maclaurin\)</span> 公式： <span
class="math display">\[
\sum_{n=a}^bf(n)-\int_a^bf(x)dx=\frac12(f(a)+f(b))+\sum_{n=1}^\infty
\frac{B_{2n}}{2n!}(f^{(2n-1)}(b)-f^{(2n-1)}(a))
\]</span> （简单来说就是利用 <span
class="math inline">\(Bernoulli\)</span>
多项式的性质反复分部积分得到的）</p>
<p>一般地，若 <span class="math inline">\(f\in
C^k[a,b]\)</span>，那么同样有： <span class="math display">\[
\sum_{n=a}^bf(n)-\int_a^bf(x)dx=\frac12(f(a)+f(b))+\sum_{n=2}^{k-1}
\frac{B_{n}}{n!}(f^{(n-1)}(b)-f^{(n-1)}(a))+R_k(f)
\]</span> 为了描述余项，需要引入 <span
class="math inline">\(Bernoulli\)</span> 多项式，类似地，这由：<span
class="math inline">\(\frac{te^{tx}}{e^t-1}=\sum_{n=0}^\infty
B_n(x)\frac{t^n}{n!}\)</span> 给出，有显式公式： <span
class="math display">\[
B_n(x)=(B+x)^n
\]</span> 其中 <span class="math inline">\(B^k=B_k\)</span> 为 <span
class="math inline">\(Bernoulli\)</span> 数（只是个方便的记号，<span
class="math inline">\(B\)</span> 并不是一个数）</p>
<p>于是，记 <span class="math inline">\(\{x\}=x-[x]\)</span> 为 <span
class="math inline">\(x\)</span> 的小数部分，那么余项就可以写为： <span
class="math display">\[
R_k(f)=(-1)^{k-1}\int_a^b\frac{B_k(\{x\})}{k!}f^{(k)}(x)dx
\]</span> 对于 <span class="math inline">\(a,b\in\mathbb{R}\)</span>
的情形，可以固定 <span class="math inline">\(n\in\mathbb{N}\)</span>，由
<span class="math inline">\(x\to \frac{b-a}nx+a\)</span> 将 <span
class="math inline">\([0,n]\to[a,b]\)</span>，再使用上述公式</p>
<p>如果记 <span
class="math inline">\(h=\frac{b-a}n\)</span>，整理可以得到： <span
class="math display">\[
\sum_{i=0}^nhf(a+ih)-\int_a^bf(x)dx=\frac h2(f(a)+f(b))+\sum_{m=2}^{k-1}
\frac{B_{m}}{m!}h^{m}(f^{(m-1)}(b)-f^{(m-1)}(a))+R_k(f)\\
R_k(f)=(-1)^{k-1}h^k\int_a^b\frac{B_k(\{\frac{x-a}h\})}{k!}f^{(k)}(x)dx
\]</span></p>
<p>注意， <span class="math inline">\(\sum_{i=0}^nhf(a+ih)-\frac
h2(f(a)+f(b))\)</span> 恰为复合梯形公式！<br>故 <span
class="math inline">\(Euler-Maclaurin\)</span>
公式事实上给出了复合梯形公式的一个极为精确的误差估计</p>
<h3 id="romberg-积分法"><span class="math inline">\(Romberg\)</span>
积分法</h3>
<p>沿用区间逐次分半法的相关记号，将 <span
class="math inline">\([a,b]\)</span> 作 <span
class="math inline">\(2^{m-1}\)</span> 等分，记由此得到的梯形值为 <span
class="math inline">\(T_{m,1}\)</span></p>
<p><span class="math inline">\(Romberg\)</span> 积分法实质上是利用 <span
class="math inline">\(Euler-Maclaurin\)</span>
公式对此做了改进，从而大大加快了收敛速度<br>事实上，据 <span
class="math inline">\(Euler-Maclaurin\)</span> 公式，有： <span
class="math display">\[
I(f)-T_{m,1}=a_2h^2+a_4h^4+O(h^6)
\]</span> 其中 <span class="math inline">\(a_2,a_4\)</span> 只与 <span
class="math inline">\(f\)</span> 在 <span
class="math inline">\(a,b\)</span> 处的相关导数值有关，若进一步考察
<span class="math inline">\(T_{m-1,1}\)</span>，有： <span
class="math display">\[
I(f)-T_{m-1,1}=2^2a_2h^2+2^4a_4h^4+O(h^6)
\]</span> 由此，我们容易消去误差中的 <span
class="math inline">\(h^2\)</span> 项，从而直接将误差缩小至 <span
class="math inline">\(O(h^4)\)</span>！<br>我们记： <span
class="math display">\[
T_{m,2}=\frac{4T_{m,1}-T_{m-1,1}}{3}
\]</span> （不难验证，这恰为复合 <span
class="math inline">\(Simpson\)</span> 公式）</p>
<p>仿此，可以继续考虑： <span class="math display">\[
I(f)-T_{m,2}=b_4h^4+b_6h^6+O(h^8)\\
I(f)-T_{m-1,2}=2^4b_4h^4+2^6b_6h^6+O(h^8)\\
\Rightarrow T_{m,3}=\frac{16T_{m,2}-T_{m-1,2}}{15}
\]</span> 一般地，有： <span class="math display">\[
T_{m,j}=\frac{4^{j-1}T_{m,j-1}-T_{m-1,j-1}}{4^{j-1}-1}
\]</span> 再结合区间逐次分半法中提到的递推式： <span
class="math display">\[
T_{m,1}=\frac12\left(T_{m-1,1}+h_{m-1}\sum_{k=1}^{2^{m-2}}f(a+(k-\frac12)h_{m-1})\right)\\
T_{1,1}=\frac{h_1}2(f(a)+f(b)),\;h_m=\frac{b-a}{2^{m-1}}
\]</span> 这就给出了 <span class="math inline">\(Romberg\)</span>
积分法，计算顺序呈三角式，也就是： <span class="math display">\[
\begin{aligned}
&amp;T_{1,1}\\
&amp;T_{2,1} &amp;T_{2,2}\\
&amp;T_{3,1} &amp;T_{3,2} &amp;&amp;T_{3,3}\\
&amp;...
\end{aligned}
\]</span></p>
<h3 id="gauss-求积公式"><span class="math inline">\(Gauss\)</span>
求积公式</h3>
<p>到目前为止，我们的讨论大都基于 <span
class="math inline">\(Newton-Cotes\)</span>
求积公式——一个选取等距基点的方法</p>
<p>一个自然的问题是，若选取一些特殊的基点作插值，是否可以达到更好的效果？这就是
<span class="math inline">\(Gauss\)</span> 求积公式要讨论的问题</p>
<p>之前已经讨论过，<span class="math inline">\(n+1\)</span> 个插值基点
<span class="math inline">\(a\leq x_0&lt;x_1&lt;...&lt;x_n\leq
b\)</span> 给出的求积公式： <span class="math display">\[
I_n(f)=\int_a^bL_n(x)W(x)dx=\sum_{i=0}^n\left(\int_a^bl_i(x)W(x)dx\right)f(x_i)
\]</span> 的代数精度至少为 <span
class="math inline">\(n\)</span>，如果记 <span
class="math inline">\(\omega_{n+1}(x)=\prod_{i=0}^n(x-x_i)\)</span>，则上式又可以写为：
<span class="math display">\[
I_n(f)=\sum_{i=0}^n\left(\int_a^b\frac{\omega_{n+1}(x)}{(x-x_i)\omega&#39;_{n+1}(x)}W(x_i)dx\right)f(x_i)
\]</span> 可以证明，上述求积公式的代数精度至多是 <span
class="math inline">\(2n+1\)</span>，且达到 <span
class="math inline">\(2n+1\)</span> 的充分必要条件为：</p>
<p><span class="math inline">\(\omega_{n+1}(x)\)</span> 与不高于 <span
class="math inline">\(n\)</span> 次的任何多项式都关于区间 <span
class="math inline">\([a,b]\)</span> 上的权函数 <span
class="math inline">\(W(x)\)</span> 直交</p>
<p>事实上，如果 <span class="math inline">\(p(x)\)</span> 为一个不高于
<span class="math inline">\(2n+1\)</span> 次的多项式，由带余除法： <span
class="math display">\[
p(x)=q(x)\omega_{n+1}(x)+r(x)
\]</span> 再结合直交的条件就不难看出结论成立</p>
<p>一般地，我们称选取了 <span class="math inline">\(n+1\)</span>
个插值基点的求积公式为 <span class="math inline">\(Gauss\)</span>
型求积公式，若其代数精度为 <span class="math inline">\(2n+1\)</span></p>
<p>下面我们简单考虑其误差，因为代数精度为 <span
class="math inline">\(2n+1\)</span>，可选 <span
class="math inline">\(Hermite\)</span> 插值逼近 <span
class="math inline">\(f\)</span> 来作误差估计，由此可以证明离散误差为：
<span class="math display">\[
E_n(f)=Cf^{(2n+2)}(\xi)\\
C=\frac{d^2}{(2n+2)!}\int_a^bp^2_{n+1}(x)dx
\]</span> 其中，<span class="math inline">\(p_{n+1}(x)\)</span> 为 <span
class="math inline">\([a,b]\)</span> 上关于权函数 <span
class="math inline">\(W(x)\)</span> 的 <span
class="math inline">\(n+1\)</span> 次直交多项式，<span
class="math inline">\(d\)</span> 为 <span
class="math inline">\(p_{n+1}(x)\)</span> 首项系数的倒数</p>
<p>下面我们讨论几个特殊情形：</p>
<ul>
<li><p><span
class="math inline">\([a,b]=[-1,1],\;W(x)=1\)</span>，我们知道此时直交多项式为
<span class="math inline">\(Legendre\)</span> 多项式，取 <span
class="math inline">\(n=1\)</span>，有 <span
class="math inline">\(P_2(x)=\frac12(3x^2-1)\)</span></p>
<p>因而只要取 <span class="math inline">\(P_2(x)\)</span> 的两个根 <span
class="math inline">\(x=\pm\frac1{\sqrt{3}}\)</span>
为插值基点，就得到代数精度为 <span class="math inline">\(3\)</span>
的插值公式 <span class="math display">\[
\int_{-1}^1f(x)dx\simeq f(-\frac1{\sqrt{3}})+f(\frac1{\sqrt{3}})
\]</span></p>
<p>称为 <span class="math inline">\(Gauss-Legendre\)</span>
两点公式，离散误差 <span
class="math inline">\(E_1(f)=\frac1{135}f^{(4)}(\xi)\)</span></p></li>
<li><p><span
class="math inline">\([a,b]=[-1,1],\;W(x)=\frac1{\sqrt{1-x^2}}\)</span>，我们知道此时直交多项式为
<span class="math inline">\(Chebyshev\)</span> 多项式 <span
class="math inline">\(T_{n+1}(x)=cos((n+1)arccos\:x)\)</span>
因而只要取插值基点为 <span
class="math inline">\(x_i=cos\left(\frac{2i-1}{2(n+1)}\pi\right),\;i=1,2,...,n+1\)</span>，就得到
<span class="math inline">\(Gauss-Chebyshev\)</span> 求积公式</p>
<p>利用 <span class="math inline">\(Chebyshev\)</span>
多项式的相关性质，化简后的最终结果为： <span class="math display">\[
\int_{-1}^1f(x)\frac{dx}{\sqrt{1-x^2}}\simeq\frac{\pi}{n+1}\sum_{k=1}^{n+1}f(x_i)
\]</span></p></li>
</ul>
<p>对于一般的情形，我们可以仿照复合求积公式的想法，首先将 <span
class="math inline">\([a,b]\)</span>
等分为若干小区间，然后在每个小区间上通过积分变换将其变换为 <span
class="math inline">\([-1,1]\)</span> 上的积分，应用上述公式即可</p>
<h2 id="重积分与广义积分">重积分与广义积分</h2>
<p>重积分只要处理为累次积分，就可以导出类似的积分公式（当然，概率论上有一个著名的重积分计算方法，不过此处不作介绍）</p>
<p>广义积分通常有两种办法处理，一是使用 <span
class="math inline">\(Gauss\)</span>
型求积公式，只需要寻找相关的直交多项式；二是截断法，我们知道广义积分收敛的必要条件是在奇点附近的积分趋于
<span
class="math inline">\(0\)</span>，从求解近似解的角度来讲，直接截去即可</p>
<h1 id="ode-初值问题数值解">ODE 初值问题数值解</h1>
<p>给定一个存在唯一解的 ODE 初值问题：</p>
<p><span class="math display">\[
\left\{\begin{aligned}
&amp;y&#39;=f(t,y),\;a\leq t \leq b\\
&amp;y(a)=\eta
\end{aligned}\right.
\]</span></p>
<p>称在一系列离散点 <span
class="math inline">\(t_0,t_1,...,,t_n\)</span> 处的近似值 <span
class="math inline">\(y_0,y_1,...,y_n\)</span>
为该问题的数值解（称为离散变量法）</p>
<p>通常采用递推的方法，假定我们已知 <span
class="math inline">\(y_0,y_1,...,y_{k-1}\)</span>，我们设计算法：<span
class="math inline">\(y_k\simeq
\varphi(y_0,y_1,...,y_k)\)</span><br>注意，算法两边可能同时出现 <span
class="math inline">\(y_k\)</span>，这种情况我们称方法是隐式的（即需要解方程），否则是显式的</p>
<p>通常，我们有三种思路：</p>
<ul>
<li><p>差商代替倒数，即：<span class="math inline">\(y&#39;(t_k)\simeq
\frac{y(t_{k+1})-y(t_k)}{h_k},\:h_k=t_{k+1}-t_k\)</span>，于是： <span
class="math display">\[
y(t_{k+1})\simeq y(t_k)+h_kf(t_k,y(t_k))
\]</span> 这被称为 <span class="math inline">\(Euler\)</span>
法</p></li>
<li><p><span class="math inline">\(Taylor\)</span>
级数法：取等距离散点，步长 <span
class="math inline">\(h=t_k-t_{k-1}\)</span>，视 <span
class="math inline">\(y(t+h)\)</span> 为关于 <span
class="math inline">\(h\)</span> 的函数，考察 <span
class="math inline">\(h=0\)</span> 处的 <span
class="math inline">\(Taylor\)</span> 展开： <span
class="math display">\[
\begin{aligned}
&amp;y(t+h)=y(t)+hy&#39;(t)+\frac12h^2y&#39;&#39;(t)+\frac1{3!}h^3y&#39;&#39;&#39;(t)+...+\frac1{p!}h^py^{(p)}(t)+\frac1{(p+1)!}h^{p+1}y^{(p+1)}(\xi)\\
&amp;=y(t)+hf(t,y)+\frac12h^2\frac d{dt}f(t,y)+\frac1{3!}h^3\frac
{d^2}{dt^2}f(t,y)+...+\frac1{(p+1)!}h^{p+1}\frac{d^{p}}{dt^{p}}f(\xi,y(\xi))
\end{aligned}
\]</span> 截去余项就得到递推公式，不难看出 <span
class="math inline">\(p=1\)</span> 时这就是 <span
class="math inline">\(Euler\)</span> 法</p></li>
<li><p>数值积分法：<span
class="math inline">\(y(t_{k+1})-y(t_k)=\int_{t_k}^{t_{k+1}}f(t,y)dt\)</span>，将右边替换为数值积分公式即可</p></li>
</ul>
<p>为了研究误差，可以假定 <span
class="math inline">\(y_0,y_1,...,y_{k-1}\)</span>
是精确的，称这种情况下算法 <span
class="math inline">\(\varphi(y_0,y_1,...,y_k)\)</span>
的误差为<strong>局部离散误差</strong><br>记 <span
class="math inline">\(h_k=t_{k+1}-t_{k}\)</span>，我们称算法为 <span
class="math inline">\(p\)</span> 阶方法，若 <span
class="math inline">\(y_{k+1}\)</span> 的局部离散误差为 <span
class="math inline">\(O^*(h_k^{p+1})\)</span></p>
<p>从整体上来看，我们称 <span class="math inline">\(y_n\)</span>
与其精确解之间的误差为<strong>整体离散误差</strong></p>
<h2 id="单步法">单步法</h2>
<p>单步法是说递推算法形如：<span class="math inline">\(y_k\simeq
\varphi(y_{k-1},y_k)\)</span>，即每次递推只用到上一步的数据<br></p>
<p>对于等距、显式的情形，我们通常写为： <span class="math display">\[
y_{k+1}\simeq y_k+h\Phi(t_k,y_k,h)
\]</span> 我们首先讨论一些具体的方法，然后再从理论上系统研究误差问题</p>
<h3 id="euler-法及其改进"><span class="math inline">\(Euler\)</span>
法及其改进</h3>
<p>前已述 <span class="math inline">\(Euler\)</span>
法的原理，在等距情形，也就是 <span
class="math inline">\(\Phi(t_k,y_k,h)=f(t_k,y_k)\)</span><br>因为 <span
class="math inline">\(Euler\)</span> 法可以由 <span
class="math inline">\(Taylor\)</span> 级数法取 <span
class="math inline">\(p=1\)</span> 得到，这就不难看出其局部离散误差为
<span class="math inline">\(O^*(h^2)\)</span>，因而是一阶方法</p>
<p>此法精度不高，故需改进，如果我们采用数值积分法中的梯形公式，可以得到一隐式方法：
<span class="math display">\[
y_{k+1}\simeq y_k+\frac h2(f(t_k,y_k)+f(t_{k+1},y_{k+1}))
\]</span>
据梯形公式的误差估计，我们知道此法为二阶方法，然而此法作为隐式方法，一般需要通过迭代求近似解<br>迭代求解需要一个初值，我们可以使用
<span class="math inline">\(Euler\)</span> 法提供，具体来说，也就是：
<span class="math display">\[
\begin{aligned}
&amp;y_{k+1,0}\simeq y_k+hf(t_k,y_k)\\
&amp;y_{k+1,m}\simeq y_k+\frac h2(f(t_k,y_k)+f(t_{k+1},y_{k+1,m-1}))
\end{aligned}
\]</span> 这个过程也被称作 <strong>PECE</strong>，即
<strong>Predict-Evaluate-Correct-Evaluate</strong>，迭代 <span
class="math inline">\(k\)</span> 次的模式记为 <span
class="math inline">\(P(EC)^kE\)</span><br>简单来说，就是先用显式方法作<strong>预测</strong>，再将该预测值用于隐式方法作<strong>校正</strong>（并反复迭代）的过程。</p>
<p>（注：如果对预测值和校正值的离散误差有较好的把握，可以通过 <span
class="math inline">\(Romberg\)</span>
积分法类似的想法去进一步修正误差）</p>
<p>当 <span class="math inline">\(h\)</span>
足够小时，迭代一两次就已经能够得到较好的结果，由此就得到了改进的 <span
class="math inline">\(Euler\)</span> 方法： <span
class="math display">\[
y_{k+1}\simeq y_k+\frac h2(f(t_k,y_k)+f(t_{k+1},y_k+hf(t_k,y_k)))
\]</span></p>
<h3 id="runge-kutta-方法"><span
class="math inline">\(Runge-Kutta\)</span> 方法</h3>
<p>若直接采用 <span class="math inline">\(Taylor\)</span> 法，则有：
<span class="math display">\[
\Phi(t_k,y_k,h)=f(t_k,y_k)+\frac12h\frac
d{dt}f(t_k,y_k)+\frac1{3!}h^2\frac
{d^2}{dt^2}f(t_k,y_k)+...+\frac1{p!}h^{p-1}\frac{d^{p-1}}{dt^{p-1}}f(t_k,y_k)
\]</span> 此法看似容易，然而计算 <span
class="math inline">\(\frac{d^p}{dt^p}f(t,y(t))\)</span> 绝非易事，<span
class="math inline">\(Runge-Kutta\)</span>
给出了一个想法，绕过了求解偏导数的麻烦</p>
<p>以 <span class="math inline">\(p=2\)</span> 为例（称为二阶 <span
class="math inline">\(Runge-Kutta\)</span> 方法），此时： <span
class="math display">\[
\Phi(t,y,h)=f(t,y(t))+\frac12 h \frac d{dt}f(t,y(t))
\]</span> 其中： <span class="math display">\[
\frac d{dt}f(t,y(t))=f_t&#39;(t,y)+f_y&#39;(t,y)\cdot
y&#39;(t)=f&#39;_t(t,y)+f&#39;_y(t,y)\cdot f(t,y)
\]</span> 我们用待定系数法求一 <span class="math inline">\(\Phi\)</span>
的近似解，如下： <span class="math display">\[
\begin{aligned}
&amp;\Psi(t,y,h)=c_1K_1+c_2K_2\\
&amp;K_1=f(t,y)\\
&amp;K_2=f(t+a_1h,y+a_2hK_1)
\end{aligned}
\]</span> 用 <span class="math inline">\(Taylor\)</span> 展开 <span
class="math inline">\(K_2\)</span>（视为 <span
class="math inline">\(h\)</span> 的函数），得到： <span
class="math display">\[
K_2=f(t,y)+a_1hf_t&#39;(t,y)+a_2hf(t,y)f_y&#39;(t,y)+O(h^2)
\]</span> 于是： <span class="math display">\[
\Psi(t,y,h)=(c_1+c_2)f(t,y)+c_2h(a_1f_t&#39;(t,y)+a_2f_y&#39;(t,y)f(t,y))+O(h^2)
\]</span> 我们知道： <span class="math display">\[
y(t+h)=y(t)+h\Phi(t,y,h)+O(h^3)
\]</span> 要想使得上式将 <span class="math inline">\(\Phi\)</span>
替换为 <span class="math inline">\(\Psi\)</span> 仍然成立，这只要求：
<span class="math display">\[
(c_1+c_2)f(t,y)+c_2h(a_1f_t&#39;(t,y)+a_2f_y&#39;(t,y)f(t,y))=\Phi(x,y,h)
\]</span> 比较各项系数，得方程组： <span class="math display">\[
\left\{\begin{aligned}
&amp;c_1+c_2=1\\
&amp;c_2a_1=c_2a_2=\frac12\\
\end{aligned}\right.
\]</span> 可自由选取一个变量的值，从而解出该方程，这样就导出了二阶 <span
class="math inline">\(Runge-Kutta\)</span> 方法<br>特别地，取 <span
class="math inline">\(a_1=1\)</span>，得到 <span
class="math inline">\(a_2=1,\;c_1=c_2=\frac12\)</span>，由此恰好得到改进的
<span class="math inline">\(Euler\)</span> 方法</p>
<p>至今最常用的是一个四阶 <span
class="math inline">\(Runge-Kutta\)</span> 方法： <span
class="math display">\[
\begin{aligned}
&amp;y_{k+1}=y_k+\frac h6(K_1+2K_2+2K_3+K_4)\\
&amp;K_1=f(t_k,y_k)\\
&amp;K_2=f(t_k+\frac12h,y_k+\frac12hK_1)\\
&amp;K_3=f(t_k+\frac12h,y_k+\frac12hK_2)\\
&amp;K_4=f(t_k+h,y_k+hK_3)
\end{aligned}
\]</span> 其局部离散误差为 <span
class="math inline">\(O^*(h^5)\)</span></p>
<h3 id="理论误差分析">理论误差分析</h3>
<p>我们从理论角度研究一些一般性的误差问题</p>
<h4 id="相容性">相容性</h4>
<p>对于等距情形，我们当然希望近似解关于 <span
class="math inline">\(h\)</span> 能够收敛到精确解，而这有一个必要条件：
<span class="math display">\[
\lim_{h\to0}\left(\frac{y(t+h)-y(t)}{h}-\Phi(t,y,h)\right)=0
\]</span> 如果 <span class="math inline">\(\Phi\)</span>
是连续函数，这个事情实际上是在说：<span
class="math inline">\(y&#39;(t)=\Phi(t,y,0)\)</span>，这给出如下定义：</p>
<p>称单步法与初值问题是<strong>相容的</strong>，若：<span
class="math inline">\(\Phi(t,y,0)=f(t,y)\)</span></p>
<p>如果只知道一个单步法是相容的，实际上并不能给出太多信息，这只能保证这个方法至少为一阶方法<br></p>
<h4 id="收敛性">收敛性</h4>
<p>首先我们给出收敛性的定义：任给 <span
class="math inline">\(t\in[a,b]\)</span>，固定 <span
class="math inline">\(t_n=t\)</span>，若有 <span
class="math inline">\(\lim_{h\to0}y_n=y(t)\)</span>，则称方法是<strong>收敛的</strong><br>对于单步法，我们有如下定理：</p>
<p>若 <span class="math inline">\(\Phi(t,y,h)\)</span> 对 <span
class="math inline">\(y\)</span> 满足 <span
class="math inline">\(Lipschitz\)</span> 条件，<span
class="math inline">\(\forall
t,h\)</span>，则单步法收敛的充分必要条件是相容条件成立<br><span
class="math inline">\(Lipshitz\)</span> 条件就是说，<span
class="math inline">\(\forall y_1,y_2\in\mathbb{R}\)</span>，存在 <span
class="math inline">\(L&gt;0\;s.t.\)</span> <span
class="math display">\[
|\Phi(t,y_1,h)-\Phi(t,y_2,h)|\leq L|y_1-y_2|,\;\forall t,h
\]</span> 进一步，这给出了整体离散误差的一个估计，我们记 <span
class="math inline">\(R(t,h)\)</span> 为局部离散误差，对于 <span
class="math inline">\(p\)</span> 阶方法来说，应该有： <span
class="math display">\[
|R(t,h)|\leq Mh^{p+1}
\]</span> 于是，只要 <span class="math inline">\(Lipschitz\)</span>
条件满足，那么整体离散误差 <span
class="math inline">\(\varepsilon_n=y(t_n)-y_n\)</span> 就满足： <span
class="math display">\[
|\varepsilon_n|\leq e^{L(b-a)}|\varepsilon_0|+h^p\frac ML(e^{L(b-a)}-1)
\]</span> 如果有 <span
class="math inline">\(\varepsilon_0=0\)</span>，那么这个 <span
class="math inline">\(p\)</span> 阶单步法的整体离散误差就为 <span
class="math inline">\(O^*(h^p)\)</span></p>
<h4 id="稳定性">稳定性</h4>
<p>稳定性是指数值稳定性，在误差分析一章中有提到；<br>在 ODE
初值问题中，我们可以通过考察对初值作扰动而产生的变化来考察稳定性，具体来说：</p>
<p>若存在 <span
class="math inline">\(h_0,C&gt;0\)</span>，使得对任意的初值 <span
class="math inline">\(y_0,\bar{y}_0\)</span>，通过步长小于 <span
class="math inline">\(h_0\)</span> 的单步法得到的相应的解 <span
class="math inline">\(y_n,\bar{y}_n\)</span>，都满足： <span
class="math display">\[
|y_n-\bar{y}_n|\leq C|y_0-\bar{y}_0|
\]</span> 就称单步法是<strong>稳定的</strong>；事实上，只要 <span
class="math inline">\(\Phi(t,y,h)\)</span> 对 <span
class="math inline">\(y\)</span> 满足 <span
class="math inline">\(Lipschitz\)</span> 条件，那么单步法就是稳定的</p>
<p>而在实际应用中，讨论某个固定的 <span class="math inline">\(h\)</span>
的情形更有意义，为此引入<strong>绝对稳定性</strong>：</p>
<p>称单步法是<strong>绝对稳定的</strong>，若由初值 <span
class="math inline">\(y_k,\bar{y}_k\)</span> 满足： <span
class="math inline">\(\bar{y}_k=y_k+\delta\)</span> 分别给出的 <span
class="math inline">\(y_{k+1},\bar{y}_{k+1}\)</span> 都有：<span
class="math inline">\(\vert
\bar{y}_{k+1}-y_{k+1}\vert&lt;\vert\delta\vert\)</span><br>通常，我们只讨论初值问题
<span class="math inline">\(y&#39;=\mu y\)</span> 的绝对稳定性，称 <span
class="math inline">\((\alpha,\beta)\)</span> 为绝对稳定区间，若任给
<span class="math inline">\(\mu h\in(\alpha,\beta)\)</span>
单步法都绝对稳定</p>
<p>举例：考虑 <span class="math inline">\(Euler\)</span>
法的绝对稳定区间，这由： <span class="math display">\[
|\bar{y}_{k+1}-y_{k+1}|=|1+\mu h||\delta|&lt;|\delta|
\]</span> 不难看出 <span class="math inline">\(\mu
h\in(-2,0)\)</span></p>
<h2 id="多步法">多步法</h2>
<p>与单步法相对的，多步法是说递推算法形如：<span
class="math inline">\(y_k\simeq
\varphi(y_{k-},...,y_k),\;m&gt;1\)</span></p>
<p>我们仍然考虑一些具体方法，然后理论分析误差</p>
<h3 id="adams-方法"><span class="math inline">\(Adams\)</span> 方法</h3>
<p>使用数值积分法 <span
class="math inline">\(y(t_{k+1})-y(t_k)=\int_{t_k}^{t_{k+1}}f(t,y)dt\)</span>
的问题在于右边的积分公式一般不能显式地给出<br><span
class="math inline">\(Adams\)</span> 方法指出，可以用 <span
class="math inline">\(y_{k-m},...,y_k\)</span> 这些已知点作 <span
class="math inline">\(f(t,y)\)</span> 的插值多项式 <span
class="math inline">\(p_m(t)\)</span>，于是就得到近似公式： <span
class="math display">\[
y_{k+1}\simeq y_k+\int_{t_k}^{t_{k+1}}p_m(t)dt
\]</span> 可以证明，<span class="math inline">\(m\)</span> 步显式 <span
class="math inline">\(Adams\)</span> 方法至少为 <span
class="math inline">\(m\)</span> 阶方法</p>
<p>亦可以将 <span class="math inline">\(y_{k+1}\)</span>
也作为插值点，由此得到方法被称为隐式 <span
class="math inline">\(Adams\)</span> 方法<br>可以证明 ，<span
class="math inline">\(m\)</span> 步隐式 <span
class="math inline">\(Adams\)</span> 方法至少为 <span
class="math inline">\((m+1)\)</span> 阶方法</p>
<p>（注：<span class="math inline">\(m=1\)</span> 时，隐式 <span
class="math inline">\(Adams\)</span> 公式恰为梯形公式）</p>
<p>由于是隐式方法，通常也需要配合 <strong>PECE</strong>
模式使用，这里不详细叙述</p>
<p>还有一被称为 <span class="math inline">\(Milne\)</span>
方法的多步法与 <span class="math inline">\(Adams\)</span>
方法类似，只是将考虑的积分区间扩大： <span
class="math inline">\(y(t_{n+1})-y(t_{n-p})=\int_{t_{n-p}}^{t_{n+1}}f(t,y)dt\)</span><br>然后仍然考虑使用插值多项式代替
<span class="math inline">\(f(t,y)\)</span>，故也不详细叙述</p>
<h3 id="hamming-方法"><span class="math inline">\(Hamming\)</span>
方法</h3>
<p>与 <span class="math inline">\(Runge-Kutta\)</span>
方法的想法类似，在等距情形，我们可以使用待定系数结合 <span
class="math inline">\(Taylor\)</span> 展开的方法来构造多步法，令： <span
class="math display">\[
L(y(t),h)=\sum_{j=0}^k(\alpha_jy(t+jh)-h\beta_jy&#39;(t+jh))
\]</span> 视为 <span class="math inline">\(h\)</span> 的函数，考虑 <span
class="math inline">\(h=0\)</span> 处的 <span
class="math inline">\(Taylor\)</span> 展开，我们知道其必然形如： <span
class="math display">\[
L(y(t),h)=c_0y(t)+c_1hy&#39;(t)+...+c_ph^py^{(p)}(t)+...
\]</span> 其中 <span class="math inline">\(c_j\)</span> 与 <span
class="math inline">\(y(t)\)</span> 无关，故我们分别令 <span
class="math inline">\(y(t)=1,t,t^2,...\)</span> 并取 <span
class="math inline">\(t=0\)</span>，就不难得到 <span
class="math inline">\(c_j\)</span> 的值： <span class="math display">\[
\begin{aligned}
&amp;c_0=\alpha_0+\alpha_1+...+\alpha_k\\
&amp;c_1=\alpha_1+2\alpha_2+...+k\alpha_k-(\beta_0+\beta_1+...+\beta_k)\\
&amp;...\\
&amp;c_p=\frac1{p!}(\alpha_1+2^p\alpha_2+...+k^p\alpha_k)-\frac1{(p-1)!}(\beta_1+2^{p-1}\beta_2+...+k^{p-1}\beta_k)\\
&amp;...
\end{aligned}
\]</span> 要想使得 <span class="math inline">\(L(y(t),h)\)</span>
导出一个至少 <span class="math inline">\(p\)</span>
阶的线性多步法，这就要求：<span
class="math inline">\(c_0=c_1=...=c_p=0\)</span><br>解出 <span
class="math inline">\(\alpha_j,\beta_j\)</span> 即可</p>
<p>注：<span class="math inline">\(Hamming\)</span> 方法似乎只是 <span
class="math inline">\(k=3,\;p=4,\;\alpha_k=1,\;\alpha_{k-1}=\beta_0=0\)</span>
时导出的特例</p>
<h3 id="理论误差分析-1">理论误差分析</h3>
<p>与单步法对应小节类似，我们考察形如： <span class="math display">\[
\sum_{j=0}^ka_jy_{m+j}=h \sum_{j=0}^k\beta_j f(t_{m+j},y_{m+j})
\]</span> 这样的线性 <span class="math inline">\(k\)</span>
步法，我们记： <span class="math display">\[
\rho(\lambda)=\alpha_k\lambda^k+\alpha_{k-1}\lambda^{k-1}+...+\alpha_1\lambda+\alpha_0\\
\sigma(\lambda)=\beta_k\lambda^k+\beta_{k-1}\lambda^{k-1}+...+\beta_1\lambda+\beta_0\\
\]</span> 显然，这两个多项式与线性 <span
class="math inline">\(k\)</span> 步法一一对应，称 <span
class="math inline">\(\rho(\lambda)\)</span> 为线性 <span
class="math inline">\(k\)</span> 步法的特征多项式</p>
<p>仿照单步法的讨论，有如下结果：</p>
<ul>
<li><p>相容性：称线性 <span class="math inline">\(k\)</span>
步法是<strong>相容的</strong>，若它至少是一阶方法</p>
<p>可以证明，这等价于：<span
class="math inline">\(\rho(1)=0,\;\rho&#39;(1)=\sigma(1)\)</span></p></li>
<li><p>收敛性：称线性 <span class="math inline">\(k\)</span>
步法是<strong>收敛的</strong>，若任给 <span
class="math inline">\(t\in[a,b]\)</span>，固定 <span
class="math inline">\(t_n=t\)</span>，都有 <span
class="math inline">\(\lim_{h\to0}y_n=y(t)\)</span></p>
<p>对于线性 <span class="math inline">\(k\)</span>
步法而言，难以考察收敛性，但是有等价关系：收敛 <span
class="math inline">\(\Leftrightarrow\)</span> 相容且稳定</p></li>
<li><p>稳定性：称线性 <span class="math inline">\(k\)</span>
步法是<strong>稳定的</strong>，若存在 <span
class="math inline">\(h_0,C&gt;0\)</span>，使得对任意的初值 <span
class="math inline">\(y_0,\bar{y}_0\)</span><br>通过步长小于 <span
class="math inline">\(h_0\)</span> 的线性 <span
class="math inline">\(k\)</span> 步法得到的相应的解 <span
class="math inline">\(y_n,\bar{y}_n\)</span>，都满足： <span
class="math display">\[
|y_n-\bar{y}_n|\leq C\mathop{max}_\limits{0\leq j \leq
k-1}|y_j-\bar{y}_j|
\]</span></p>
<p>可以证明，这等价于 <span class="math inline">\(\rho(\lambda)\)</span>
满足一个所谓的<strong>特征根条件</strong>，即：</p>
<p><span class="math inline">\(\rho(\lambda)\)</span>
的所有根都在单位圆中，且在单位圆上的根只能是单重根</p></li>
<li><p>强稳定性：上述稳定性一般又称弱稳定性（误差可能会震荡），特征根条件称为弱根条件，若进一步满足：</p>
<p><span class="math inline">\(\rho(\lambda)\)</span> 的全部根除了 <span
class="math inline">\(\lambda =1\)</span>
外均在单位圆内（强根条件），则称满足<strong>强稳定性</strong></p></li>
<li><p>绝对稳定性：仍然只讨论 <span class="math inline">\(y&#39;=\mu
y\)</span>，此时线性 <span class="math inline">\(k\)</span> 步法可以看成
<span class="math inline">\(k\)</span> 阶常系数递推数列，有特征方程：
<span class="math display">\[
\rho(\lambda)-\mu h\sigma(\lambda) = 0
\]</span> 我们称线性 <span class="math inline">\(k\)</span>
步法是<strong>绝对稳定的</strong>，若上述方程的根 <span
class="math inline">\(\lambda_r\)</span> 都满足 <span
class="math inline">\(|\lambda_r|&lt;1\)</span><br>称 <span
class="math inline">\((\alpha,\beta)\)</span> 为绝对稳定区间，若任给
<span class="math inline">\(\mu h\in(\alpha,\beta)\)</span>
多步法都绝对稳定</p>
<p>可以证明，当 <span class="math inline">\(h\)</span> 接近 <span
class="math inline">\(0\)</span> 时，想要达成绝对稳定必须要有 <span
class="math inline">\(\mu h&lt;0\)</span></p></li>
</ul>
<h2 id="高阶-ode-和-ode-方程组">高阶 ODE 和 ODE 方程组</h2>
<p>对于一阶 ODE 方程组，只要简单地记 <span
class="math inline">\(Y=(y_1,...,y_m),\;F=(f_1,...,f_m),\;\eta=(\eta_1,...,\eta_m)\)</span>，那么初值问题就形如：
<span class="math display">\[
\left\{\begin{aligned}
&amp;Y&#39;=F(t,Y),\;a\leq t \leq b\\
&amp;Y(a)=\eta
\end{aligned}\right.
\]</span> 之前讨论的方法对此是完全适用的，而对于高阶 ODE： <span
class="math display">\[
\left\{\begin{aligned}
&amp;y^{(m)}=f(t,y,y&#39;,...,y^{(m-1)}),\;a\leq t \leq b\\
&amp;y(a)=\eta_1,\;y&#39;(a)=\eta_2,...,y^{(m-1)}(a)=\eta_m
\end{aligned}\right.
\]</span> 只要令：<span
class="math inline">\(y_1=y,\;y_2=y&#39;,...,y_m=y^{(m-1)}\)</span>，就化为了方程组：
<span class="math display">\[
\left\{\begin{aligned}
&amp;y_1&#39;=y_2,\;y_1(a)=\eta_1\\
&amp;y_2&#39;=y_3,\;y_2(a)=\eta_2\\
&amp;...\\
&amp;y_m&#39;=f(t,y_1,y_2,...,y_m),\;y_m(a)=\eta_m\\
\end{aligned}\right.
\]</span> 故无需多言</p>
<h1 id="后记">后记</h1>
<ol type="1">
<li>这门课其实还讲了点 <strong>M-P
神经网络</strong>，然而感觉讲的太快太浅，偏科普性质（问就是感觉自己学了个寂寞），故没有整理至此。</li>
<li>没有整理<strong>差分方程</strong>一节，个人认为本质上跟 <span
class="math inline">\(k\)</span>
阶递推数列相关理论没什么区别，反正都是线代的活。</li>
<li>封面是我有一次把梯度下降方向搞反了搞成了“梯度上升”的图像捏，挺壮观的是不是（（（</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">dasasdhba</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://dasasdhba.github.io/math/numeric-analysis/">http://dasasdhba.github.io/math/numeric-analysis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://dasasdhba.github.io" target="_blank">das's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E5%AD%A6%EF%BC%8C%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/">数学，数值计算</a></div><div class="post_share"><div class="social-share" data-image="https://ts3.tc.mm.bing.net/th/id/OIP-C.WK0S-YUIaHS1Jcguo7501gHaEz?rs=1&amp;pid=ImgDetMain&amp;o=7&amp;rm=3" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://gcore.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/restart/"><img class="prev_cover lazyload" data-src="https://s41.ax1x.com/2026/01/06/pZdDFw4.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">重启</div></div></a></div><div class="next-post pull_right"><a href="/math/FFT/"><img class="next_cover lazyload" data-src="https://image.slideserve.com/996565/fast-fourier-transform1-l.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">「数值分析」浅析快速傅里叶变换 FFT</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/math/FFT/" title="「数值分析」浅析快速傅里叶变换 FFT"><img class="relatedPosts_cover lazyload"data-src="https://image.slideserve.com/996565/fast-fourier-transform1-l.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2023-03-29</div><div class="relatedPosts_title">「数值分析」浅析快速傅里叶变换 FFT</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://unpkg.com/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  appId: 'EOAokpc3LI1jWthsKJLEtuBy-gzGzoHsz',
  appKey: 'InUfga6TN89TnYNKelRKLuDQ',
  placeholder: '请输入文本',
  avatar: 'mp',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: true,
  serverURLs: '',
  mathjax: false
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2026 By dasasdhba</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://gcore.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://gcore.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://gcore.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://gcore.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://gcore.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script></body></html>