<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数值分析复习笔记 | dasasdhba</title><meta name="description" content="本篇为应付考试而整理的复习笔记，因而只是整理我个人认为考前需要速通的点，因而不一定全面以及完备。 误差分析 两类基本误差  绝对误差：\(e_{\bar{x}}=x-\bar{x}\) 相对误差：\(r_{\bar{x}}=\frac{e_{\bar{x}}}x\) 由于 \(x\) 往往未知，在 \(r_{\bar{x}}\) 很小的时候，可以用 \(r^*_{\bar{x}}=\f"><meta name="keywords" content="学习"><meta name="author" content="dasasdhba"><meta name="copyright" content="dasasdhba"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/ESP.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数值分析复习笔记"><meta name="twitter:description" content="本篇为应付考试而整理的复习笔记，因而只是整理我个人认为考前需要速通的点，因而不一定全面以及完备。 误差分析 两类基本误差  绝对误差：\(e_{\bar{x}}=x-\bar{x}\) 相对误差：\(r_{\bar{x}}=\frac{e_{\bar{x}}}x\) 由于 \(x\) 往往未知，在 \(r_{\bar{x}}\) 很小的时候，可以用 \(r^*_{\bar{x}}=\f"><meta name="twitter:image" content="https://s1.ax1x.com/2023/04/24/p9mR80O.jpg"><meta property="og:type" content="article"><meta property="og:title" content="数值分析复习笔记"><meta property="og:url" content="http://dasasdhba.github.io/study-numeric-analysis/"><meta property="og:site_name" content="dasasdhba"><meta property="og:description" content="本篇为应付考试而整理的复习笔记，因而只是整理我个人认为考前需要速通的点，因而不一定全面以及完备。 误差分析 两类基本误差  绝对误差：\(e_{\bar{x}}=x-\bar{x}\) 相对误差：\(r_{\bar{x}}=\frac{e_{\bar{x}}}x\) 由于 \(x\) 往往未知，在 \(r_{\bar{x}}\) 很小的时候，可以用 \(r^*_{\bar{x}}=\f"><meta property="og:image" content="https://s1.ax1x.com/2023/04/24/p9mR80O.jpg"><meta property="article:published_time" content="2023-04-24T06:10:28.000Z"><meta property="article:modified_time" content="2023-04-25T14:43:28.751Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://dasasdhba.github.io/study-numeric-analysis/"><link rel="next" title="「数值分析」浅析快速傅里叶变换 FFT" href="http://dasasdhba.github.io/study-FFT/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://dasasdhba.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="dasasdhba" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://s1.ax1x.com/2020/08/08/a547uQ.jpg" onerror="onerror=null;src='undefined'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#误差分析"><span class="toc-number">1.</span> <span class="toc-text">误差分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#两类基本误差"><span class="toc-number">1.1.</span> <span class="toc-text">两类基本误差</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#舍入误差与有效数字"><span class="toc-number">1.2.</span> <span class="toc-text">舍入误差与有效数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算中的误差传播"><span class="toc-number">1.3.</span> <span class="toc-text">运算中的误差传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机浮点系统"><span class="toc-number">1.4.</span> <span class="toc-text">计算机浮点系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ufl-与-ofl"><span class="toc-number">1.4.1.</span> <span class="toc-text">UFL 与 OFL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#机器精度"><span class="toc-number">1.4.2.</span> <span class="toc-text">机器精度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#机器算术运算"><span class="toc-number">1.4.3.</span> <span class="toc-text">机器算术运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数值稳定与病态问题"><span class="toc-number">1.5.</span> <span class="toc-text">数值稳定与病态问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#插值法"><span class="toc-number">2.</span> <span class="toc-text">插值法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lagrange-插值"><span class="toc-number">2.1.</span> <span class="toc-text">\(Lagrange\) 插值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#余项"><span class="toc-number">2.1.1.</span> <span class="toc-text">余项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runge-现象"><span class="toc-number">2.1.2.</span> <span class="toc-text">\(Runge\) 现象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newton-插值"><span class="toc-number">2.2.</span> <span class="toc-text">\(Newton\) 插值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#均差"><span class="toc-number">2.2.1.</span> <span class="toc-text">均差</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#差商表"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">差商表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newton-插值多项式"><span class="toc-number">2.2.2.</span> <span class="toc-text">\(Newton\) 插值多项式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有限差"><span class="toc-number">2.2.3.</span> <span class="toc-text">有限差</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#差分表"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">差分表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newton-前插和后插公式"><span class="toc-number">2.2.4.</span> <span class="toc-text">\(Newton\) 前插和后插公式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hermite-插值"><span class="toc-number">2.3.</span> <span class="toc-text">Hermite 插值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分段插值"><span class="toc-number">2.4.</span> <span class="toc-text">分段插值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分段插值误差界"><span class="toc-number">2.4.1.</span> <span class="toc-text">分段插值误差界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三次样条插值"><span class="toc-number">2.4.2.</span> <span class="toc-text">三次样条插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基样条插值"><span class="toc-number">2.4.3.</span> <span class="toc-text">基样条插值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数逼近"><span class="toc-number">3.</span> <span class="toc-text">函数逼近</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#正交函数系"><span class="toc-number">3.1.</span> <span class="toc-text">正交函数系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线性无关"><span class="toc-number">3.1.1.</span> <span class="toc-text">线性无关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直交多项式"><span class="toc-number">3.2.</span> <span class="toc-text">直交多项式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#chebyshev-多项式"><span class="toc-number">3.2.1.</span> <span class="toc-text">\(Chebyshev\) 多项式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第二类-chebyshev-多项式"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">第二类 \(Chebyshev\) 多项式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#legendre-多项式"><span class="toc-number">3.2.2.</span> <span class="toc-text">\(Legendre\) 多项式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最佳一致逼近"><span class="toc-number">3.3.</span> <span class="toc-text">最佳一致逼近</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最佳平方逼近"><span class="toc-number">3.4.</span> <span class="toc-text">最佳平方逼近</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#离散情形"><span class="toc-number">3.4.1.</span> <span class="toc-text">离散情形</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据拟合"><span class="toc-number">4.</span> <span class="toc-text">数据拟合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线性拟合"><span class="toc-number">4.1.</span> <span class="toc-text">线性拟合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#过拟合现象"><span class="toc-number">4.1.1.</span> <span class="toc-text">过拟合现象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非线性拟合"><span class="toc-number">4.2.</span> <span class="toc-text">非线性拟合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线性化求近似解"><span class="toc-number">4.2.1.</span> <span class="toc-text">线性化求近似解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#梯度下降法"><span class="toc-number">4.2.2.</span> <span class="toc-text">梯度下降法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#后记"><span class="toc-number">5.</span> <span class="toc-text">后记</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div class="post-bg" id="nav" style="background-image: url(https://s1.ax1x.com/2023/04/24/p9mR80O.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">dasasdhba</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">数值分析复习笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2023-04-24 14:10:28"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2023-04-24</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2023-04-25 22:43:28"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2023-04-25</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/study-numeric-analysis/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/study-numeric-analysis/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>本篇为应付考试而整理的复习笔记，因而只是整理我个人认为考前需要速通的点，因而不一定全面以及完备。</p>
<h1 id="误差分析">误差分析</h1>
<h2 id="两类基本误差">两类基本误差</h2>
<ul>
<li><p>绝对误差：<span class="math inline">\(e_{\bar{x}}=x-\bar{x}\)</span></p></li>
<li><p>相对误差：<span class="math inline">\(r_{\bar{x}}=\frac{e_{\bar{x}}}x\)</span></p>
<p>由于 <span class="math inline">\(x\)</span> 往往未知，在 <span class="math inline">\(r_{\bar{x}}\)</span> 很小的时候，可以用 <span class="math inline">\(r^*_{\bar{x}}=\frac{e_{\bar{x}}}{\bar{x}}\)</span> 近似</p></li>
</ul>
<h2 id="舍入误差与有效数字">舍入误差与有效数字</h2>
<p>记十进制数 <span class="math inline">\(a\)</span> 某个数码 <span class="math inline">\(a_s\)</span> 的位数为 <span class="math inline">\(k(a_s)\)</span>，当 <span class="math inline">\(a_s\)</span> 在个位时取 0，十位时取 1，小数点后第一位时取 -1，以此类推</p>
<ul>
<li><p>舍入误差：将 a 四舍五入至 <span class="math inline">\(k\)</span> 位小数，那么 <span class="math inline">\(|e_{\bar{a}}|\leq\frac12\times10^{-k}\)</span></p></li>
<li><p>有效数字：设 <span class="math inline">\(\bar{a}\)</span> 为 <span class="math inline">\(a\)</span> 的近似值，从 <span class="math inline">\(\bar{a}\)</span> 中首位不为零的数码起，称数码 <span class="math inline">\(a_s\)</span> 为有效数字，若满足： <span class="math display">\[
|e_{\bar{a}}|\leq\frac12\times10^{k(a_s)}
\]</span> （因而对于四舍五入得到的近似值，从首位不为零的数码起，所有数码都是有效数字）</p></li>
</ul>
<p>利用有效数字，我们有如下<strong>相对误差估计</strong>：</p>
<p>设 <span class="math inline">\(\bar{a}\)</span> 有 <span class="math inline">\(k\)</span> 位有效数字，其中第一位有效数字为 <span class="math inline">\(a_s\)</span>，那么： <span class="math display">\[
|r^*_{\bar{a}}|\leq\frac1{2a_s}\times10^{-(k-1)}
\]</span> 反之，若有上述不等式成立，则 <span class="math inline">\(\bar{a}\)</span> 至少有 <span class="math inline">\(k\)</span> 位有效数字</p>
<p>（这说明有效数字越多，相对误差越小）</p>
<h2 id="运算中的误差传播">运算中的误差传播</h2>
<p>考察二元函数 <span class="math inline">\(z=f(x,y)\)</span> 产生的误差：<span class="math inline">\(e_{\bar{z}}=f(x,y)-f(\bar{x},\bar{y})\)</span></p>
<p>当 <span class="math inline">\(|e_{\bar{x}}|,|e_{\bar{y}}|\)</span> 很小，且 <span class="math inline">\(f\)</span> 可微时，有近似公式： <span class="math display">\[
e_{\bar{z}}\approx \frac{\partial f}{\partial x}(\bar{x},\bar{y})\:e_{\bar{x}}+\frac{\partial f}{\partial y}(\bar{x},\bar{y})\:e_{\bar{y}}\\
r_{\bar{z}}\approx \frac{\bar{x}}{\bar{z}}\frac{\partial f}{\partial x}(\bar{x},\bar{y})\:r_{\bar{x}}+\frac{\bar{y}}{\bar{z}}\frac{\partial f}{\partial y}(\bar{x},\bar{y})\:r_{\bar{y}}
\]</span> （对于 <span class="math inline">\(r^*\)</span> 亦有类似的近似）</p>
<p>由此导出：</p>
<ol type="1">
<li><p><span class="math inline">\(f(x,y)=x\pm y\)</span> <span class="math display">\[
e_{\bar{x}\pm \bar{y}}=e_{\bar{x}}\pm e_{\bar{y}}\\
r_{\bar{x}\pm \bar{y}}=\frac{\bar{x}}{\bar{x}\pm \bar{y}}r_{\bar{x}}\pm\frac{\bar{y}}{\bar{x}\pm \bar{y}}r_{\bar{y}}
\]</span> 可见 <span class="math inline">\(x\approx y\)</span> 时作减法会产生较大的相对误差，这被称为<strong>相减相消</strong>，应尽量避免</p></li>
<li><p><span class="math inline">\(f(x,y)=xy\)</span> <span class="math display">\[
e_{\bar{x}\bar{y}}=\bar{y}e_{\bar{x}}+\bar{x}e_{\bar{y}}\\
r_{\bar{x}\bar{y}}=r_{\bar{x}}+r_{\bar{y}}
\]</span></p></li>
<li><p><span class="math inline">\(f(x,y)=x/y\)</span> <span class="math display">\[
e_{\bar{x}/\bar{y}}=\frac{\bar{y}e_{\bar{x}}-\bar{x}e_{\bar{y}}}{\bar{y}^2}\\
r_{\bar{x}/\bar{y}}=r_{\bar{x}}-r_{\bar{y}}
\]</span> 可见 <span class="math inline">\(y\to0\)</span> 时会产生较大的绝对误差，应尽量避免</p></li>
</ol>
<h2 id="计算机浮点系统">计算机浮点系统</h2>
<p>称 <span class="math inline">\(F(p,t,L,U)\)</span> 为一个计算机浮点系统，其中：</p>
<ul>
<li><span class="math inline">\(p\)</span>：基数（进制）</li>
<li><span class="math inline">\(t\)</span>：精度（最大小数位数）</li>
<li><span class="math inline">\(L,U\)</span>：指数的取值范围 <span class="math inline">\([-L,U]\)</span>（整数）</li>
</ul>
<p>属于浮点系统 <span class="math inline">\(F\)</span> 的数 <span class="math inline">\(x\)</span> 具有如下形式： <span class="math display">\[
x=\pm p^J\sum_{k=1}^td_kp^{-k}=\pm (0.d_1d_2...d_t)_p\times p^J\\
J\in \mathbb{Z}\cap[-L,U],\:d_k\in\{0,1,2,...,p-1\}
\]</span> 称 <span class="math inline">\((0.d_1d_2...d_t)_p\)</span> 为 <span class="math inline">\(x\)</span> 的尾数，<span class="math inline">\(J\)</span> 为 <span class="math inline">\(x\)</span> 的指数（阶）</p>
<p>称 <span class="math inline">\(x\)</span> 为<strong>规格化浮点数</strong>，若 <span class="math inline">\(d_1\neq0\)</span></p>
<h3 id="ufl-与-ofl">UFL 与 OFL</h3>
<ul>
<li>称 <span class="math inline">\(F\)</span> 中的最小正数为 <span class="math inline">\(UFL=p^{-t}\times p^{-L}=p^{-(L+t)}\)</span></li>
<li>称 <span class="math inline">\(F\)</span> 中的最大正数为 <span class="math inline">\(OFL=(1-p^{-t})\times p^U\)</span></li>
</ul>
<h3 id="机器精度">机器精度</h3>
<p><span class="math inline">\(F\)</span> 自然不能表示任意实数，称 <span class="math inline">\(F\)</span> 中用于表示一个在 <strong>UFL</strong> 以及 <strong>OFL</strong> 范围内的实数 <span class="math inline">\(x\)</span> 的最大的相对误差为机器精度 <span class="math inline">\(\varepsilon_{mach}\)</span></p>
<ul>
<li>若采取<strong>截断法</strong>：<span class="math inline">\(\varepsilon_{mach}=p^{1-t}\)</span></li>
<li>若采取<strong>最近舍入法</strong>（四舍六入五取双）：<span class="math inline">\(\varepsilon_{mach}=\frac12p^{1-t}\)</span></li>
</ul>
<p>一般地：<span class="math inline">\(0&lt;UFL&lt;\varepsilon_{mach}&lt;OFL\)</span></p>
<h3 id="机器算术运算">机器算术运算</h3>
<p>以 <span class="math inline">\(\oplus\:\ominus\:\otimes\)</span> 等符号代表机器算术运算符号， 可以假定机器运算的定义为： <span class="math display">\[
x\odot y=fl(fl(x)\cdot fl(y))
\]</span> 其中 <span class="math inline">\(\cdot\)</span> 泛指上述符号，<span class="math inline">\(fl(x)\)</span> 为 <span class="math inline">\(F\)</span> 中最接近 <span class="math inline">\(x\)</span> 的数，也就是 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(F\)</span> 中的表示</p>
<p>乘除运算是直接进行的，只需要分别处理底数部分和指数部分即可；</p>
<p>而对于加减运算，则需要<strong>对阶</strong>操作，即首先将阶数较小的数调整为与阶数较大的数同阶数（相应地，底数修改小数点位置），这个过程中若底数超出了精度 <span class="math inline">\(t\)</span>，则需要截断或最近舍入；完成加减运算之后，仍然需要作截断或最近舍入</p>
<p>特别地，对于减法，我们有<strong>精度丢失定理</strong>：设 <span class="math inline">\(x&gt;y\)</span> 均为正的规格化二进制浮点数，且 <span class="math inline">\(2^{-q}\leq1-\frac yx\leq2^{-p}\)</span> 则 <span class="math inline">\(x\ominus y\)</span> 丢失至多 <span class="math inline">\(q\)</span> 个，至少 <span class="math inline">\(p\)</span> 个有效二进制位</p>
<h2 id="数值稳定与病态问题">数值稳定与病态问题</h2>
<ul>
<li><p>称一个算法是<strong>数值稳定</strong>的，若在计算过程中，<strong>误差</strong>不会增长，否则称为<strong>数值不稳定</strong>的</p>
<p>例：在计算递推式时，式中出现了形如 <span class="math inline">\(x_{n+1}=ax_n,\:a&gt;1\)</span> 的情况，那么误差就会被 <span class="math inline">\(a\)</span> 不断放大，导致数值不稳定</p></li>
<li><p>称一个问题是<strong>病态</strong>的，若输入的<strong>微小变化</strong>能够导致输出的<strong>巨大误差</strong></p>
<p>例：求解线性方程组时系数矩阵接近奇异，如 <span class="math inline">\(Hilbert\)</span> 矩阵</p></li>
</ul>
<h1 id="插值法">插值法</h1>
<p>插值问题是指给定一组离散数据 <span class="math inline">\(\{x_k,y_k\},k=0,1,...,n\)</span>，我们试图寻求一函数形如： <span class="math display">\[
\varphi(x)=a_0\varphi_0(x)+a_1\varphi_1(x)+...+a_n\varphi_n(x)
\]</span> 使得 <span class="math inline">\(\varphi(x_k)=y_k,\forall k=0,1,...,n\)</span></p>
<h2 id="lagrange-插值"><span class="math inline">\(Lagrange\)</span> 插值</h2>
<p>记 <span class="math inline">\(l_i(x)=\prod_{j=0,j\neq i}^n\frac{x-x_j}{x_i-x_j}\)</span>，则 <span class="math inline">\(l_i(x_j)=\delta_{ij}\)</span>，称为 <span class="math inline">\(Lagrange\)</span> 基本多项式</p>
<p>则 <span class="math inline">\(Lagrange\)</span> 插值多项式为：<span class="math inline">\(L_n(x)=\sum_{i=0}^nf(x_i)l_i(x)\)</span>，容易证明这是存在唯一的</p>
<p>方便起见，若记 <span class="math inline">\(\omega_{n+1}(x)=\prod_{i=0}^n(x-x_i)\)</span>，那么 <span class="math inline">\(\omega_{n+1}&#39;(x_i)=\prod_{j=0,j\neq i}^n(x_i-x_j)\)</span></p>
<p>于是 <span class="math inline">\(l_i(x)=\frac{\omega_{n+1}(x)}{(x-x_i)\omega_{n+1}&#39;(x_i)}\)</span></p>
<h3 id="余项">余项</h3>
<p>设离散数据 <span class="math inline">\(\{x_k,y_k\},k=0,1,...,n\)</span> 是由函数 <span class="math inline">\(f\)</span> 给出，也就是 <span class="math inline">\(y_i=f(x_i)\)</span>，称： <span class="math display">\[
r_n(x)=f(x)-L_n(x)
\]</span> 为 <span class="math inline">\(Lagrange\)</span> 插值多项式的<strong>余项</strong></p>
<p>假设 <span class="math inline">\(f\)</span> 在包含 <span class="math inline">\(\{x_n\}\)</span> 的区间 <span class="math inline">\([a,b]\)</span> 上具有 <span class="math inline">\(n\)</span> 阶连续导数，且在 <span class="math inline">\((a,b)\)</span> 内存在 <span class="math inline">\(n+1\)</span> 阶有界导数， <br>那么 <span class="math inline">\(\forall x \in [a,b],\:\exists \xi\in(a,b)\)</span> 使得： <span class="math display">\[
r_n(x)=\frac{f^{n+1}(\xi)}{(n+1)!}\omega_{n+1}(x)
\]</span> 其证明需要简单了解，大致如下： <br>因为 <span class="math inline">\(x_0,x_1,...,x_n\)</span> 都是 <span class="math inline">\(r_n(x)\)</span> 的一重零点，故可以设 <span class="math inline">\(r_n(x)=\omega_{n+1}(x)K(x)\)</span>，为确定 <span class="math inline">\(K(x)\)</span>，引入辅助函数： <span class="math display">\[
F(t)=f(t)-L_n(t)-K(x)\omega_{n+1}(t)
\]</span> 则 <span class="math inline">\(t = x_0,x_1,...,x_n,x\)</span> 时均有 <span class="math inline">\(F(t)=0\)</span>，反复应用 <span class="math inline">\(Rolle\)</span> 定理就有 <span class="math inline">\(0=F^{(n+1)}(\xi)=f^{(n+1)}(\xi)-K(x)(n+1)!\)</span> <br>从而不难解出 <span class="math inline">\(K(x)\)</span> （这说明 <span class="math inline">\(\xi\)</span> 与 <span class="math inline">\(x_0,x_1,...,x_n,x\)</span> 有关）</p>
<p>通过考察余项，我们可以估计误差，特别地，对于线性插值，有： <span class="math display">\[
|r_1(x)|\leq\frac{(b-a)^2}{8}|f&#39;&#39;(\xi)|
\]</span> 对于二次插值，有： <span class="math display">\[
|r_2(x)|\leq \frac{\sqrt3}{27}(b-a)^3|f&#39;&#39;&#39;(\xi)|
\]</span></p>
<h3 id="runge-现象"><span class="math inline">\(Runge\)</span> 现象</h3>
<p>一般而言，<span class="math inline">\(n\)</span> 越大，<span class="math inline">\(L_n(x)\)</span> 在端点附近的抖动也越大，这被称为 <span class="math inline">\(Runge\)</span> 现象，因而高次插值法一般不能用于外插</p>
<h2 id="newton-插值"><span class="math inline">\(Newton\)</span> 插值</h2>
<h3 id="均差">均差</h3>
<p>称 <span class="math inline">\(f[x_i,x_j]=\frac{f(x_j)-f(x_i)}{x_j-x_i}\)</span> 为 <span class="math inline">\(f\)</span> 关于基点 <span class="math inline">\(x_i,x_j\)</span> 的一阶均差<br> 称 <span class="math inline">\(f[x_i,x_j,x_k]=\frac{f[x_j,x_k]-f[x_i,x_j]}{x_k-x_i}\)</span> 为 <span class="math inline">\(f\)</span> 关于基点 <span class="math inline">\(x_i,x_j,x_k\)</span> 的二阶均差<br> 一般地，<span class="math inline">\(f[x_0,x_1,...,x_n]=\frac{f[x_1,x_2,...,x_n]-f[x_0,x_1,...,x_{n-1}]}{x_n-x_0}\)</span> <br>方便起见，不妨规定 <span class="math inline">\(f[x_i]=f(x_i)\)</span></p>
<p>用归纳法可以证明： <span class="math display">\[
f[x_0,x_1,...,x_n]=\sum_{i=0}^n\frac{f(x_i)}{\prod_{j=0,j\neq i}^n(x_i-x_j)}
\]</span></p>
<h4 id="差商表">差商表</h4>
<p>常用差商表来计算各个均差：</p>
<p><span class="math display">\[
\left[
\begin{array}{}
x_0 &amp; f(x_0)\\
x_1 &amp; f(x_1)  &amp; f[x_0,x_1]\\
x_2 &amp; f(x_2) &amp; f[x_1,x_2] &amp; f[x_0,x_1,x_2]\\
... &amp; ... &amp; ... &amp; ...  &amp; ...\\
x_n &amp; f(x_n) &amp; f[x_{n-1},x_n] &amp; f[x_{n-2},x_{n-1},x_n] &amp;  ... &amp; f[x_0,...,x_n]\\
\end{array}
\right]
\]</span></p>
<h3 id="newton-插值多项式"><span class="math inline">\(Newton\)</span> 插值多项式</h3>
<p><span class="math inline">\(Lagrange\)</span> 插值的缺陷是每新增一个样本点都要全部重新算一遍，<span class="math inline">\(Newton\)</span> 插值优化了这一点，其关键是将多项式考虑为如下形式： <span class="math display">\[
N_n(x)=a_0+a_1(x-x_0)+a_2(x-x_0)(x-x_1)+...+a_n(x-x_0)(x-x_1)...(x-x_{n-1})
\]</span> 从而不难看出 <span class="math inline">\(a_k=f[x_0,x_1,...,x_k]\)</span></p>
<p>若新增一插值基点 <span class="math inline">\(\bar{x}\)</span>，那么 <span class="math inline">\(f(\bar{x})-N_n(\bar{x})=N_{n+1}(\bar{x})-N_n(\bar{x})=f[x_0,x_1,...,x_n,\bar{x}]\omega_{n+1}(\bar{x})\)</span> <br>据插值多项式的唯一性，比较上一节中的余项就有： <span class="math display">\[
f[x_0,x_1,...,x_n,x]=\frac{f^{(n+1)}(\xi)}{(n+1)!}
\]</span></p>
<h3 id="有限差">有限差</h3>
<p>下面我们考虑样本点满足 <span class="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span> 的简单情形，方便起见，引入有限差的概念，分别称： <span class="math display">\[
\Delta f(x)=f(x+h)-f(x)\\
\nabla f(x)=f(x)-f(x-h)\\
\delta f(x)=f(x+\frac h2)-f(x-\frac h2)
\]</span> 为函数 <span class="math inline">\(f(x)\)</span> 在点 <span class="math inline">\(x\)</span> 的一阶向前差分，一阶向后差分以及一阶中心差分，易见它们都是线性算子 <br>下面以向前差分为例定义高阶情形： <span class="math display">\[
\Delta^2f(x)=\Delta(\Delta f(x))=\Delta f(x+h)-\Delta f(x)\\
\Delta^nf(x)=\Delta(\Delta^{n-1} f(x))=\Delta^{n-1} f(x+h)-\Delta^{n-1} f(x)\\
\]</span> 类似地，方便起见我们规定 <span class="math inline">\(\Delta^0f(x)=f(x)\)</span>，用归纳法可以证明： <span class="math display">\[
\Delta^n f(x)=\sum_{i=0}^n(-1)^iC_n^if(x+(n-i)h)\\
\nabla^n f(x)=\sum_{i=0}^n(-1)^iC_n^if(x-ih)\\
\delta^n f(x)=\sum_{i=0}^n(-1)^iC_n^if(x+(\frac n2-i)h)
\]</span> 反过来，我们也有： <span class="math display">\[
f(x+nh)=\sum_{i=0}C_n^i\Delta^if(x)\\
f(x-nh)=\sum_{i=0}^n(-1)^iC_n^i\nabla^if(x)\\
f(x+nh)=\sum_{i=0}^nC_n^i\delta^if(x+\frac i2h)
\]</span> 最后，对于满足 <span class="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span> 的样本点，我们有： <span class="math display">\[
f[x_0,x_1,...,x_n]=\frac{\Delta^nf(x_0)}{n!h^n}=\frac{\nabla^nf(x_n)}{n!h^n}
\]</span> 对于中心差分则需要分样本点的奇偶个数作讨论，原理类似</p>
<h4 id="差分表">差分表</h4>
<p>可以用差商表类似的方法构造差分表以计算差分，以向前差分为例：</p>
<p><span class="math display">\[
\left[
\begin{array}{}
x_i=x_0+ih &amp; \Delta &amp; \Delta^2 &amp; \Delta^3 &amp; ...  &amp; \Delta^{n-1} &amp; \Delta^n\\
x_0 &amp; \Delta f(x_0) &amp; \Delta^2 f(x_0) &amp; \Delta^3 f(x_0) &amp;  ... &amp;\Delta^{n-1} f(x_0)&amp; \Delta^n f(x_0)\\
x_1 &amp; \Delta f(x_1) &amp; \Delta^2 f(x_1) &amp; \Delta^3 f(x_1) &amp;  ... &amp;\Delta^{n-1} f(x_1)&amp;\\
x_2 &amp; \Delta f(x_2) &amp; \Delta^2 f(x_2) &amp; \Delta^3 f(x_2) &amp;  ...\\
... &amp; ... &amp; ... &amp; ... &amp; ... \\
x_{n-1} &amp; \Delta f(x_{n-1}) &amp; \Delta^2 f(x_{n-1}) \\
x_n &amp; \Delta f(x_n)
\end{array}
\right]
\]</span></p>
<h3 id="newton-前插和后插公式"><span class="math inline">\(Newton\)</span> 前插和后插公式</h3>
<p>考虑样本点满足 <span class="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span> 的情形，利用均差和向前差分的关系，作变换：<span class="math inline">\(x=x_0+sh\)</span> <br>从而 <span class="math inline">\(Newton\)</span> 插值公式可以整理为： <span class="math display">\[
N_n(x)=N_n(x_0+sh)=\sum_{k=0}^n\left(\begin{array}{}s\\k\end{array}\right)\Delta^kf(x_0)\\
\left(\begin{array}{}s\\k\end{array}\right)=\frac{s(s-1)...(s-k+1)}{k!}
\]</span> 即 <span class="math inline">\(Newton\)</span> 前插公式；利用向后差分，作变换：<span class="math inline">\(x=x_n+th\)</span>，同理有： <span class="math display">\[
N_n(x)=N_n(x_n+th)=\sum_{k=0}^n\left(\begin{array}{}-t\\k\end{array}\right)(-1)^k\nabla^kf(x_n)\\
\left(\begin{array}{}-t\\k\end{array}\right)(-1)^k=\frac{t(t+1)...(t+k-1)))}{k!}
\]</span> 即 <span class="math inline">\(Newton\)</span> 后插公式</p>
<h2 id="hermite-插值">Hermite 插值</h2>
<p>在 <span class="math inline">\(Hermite\)</span> 插值中我们不仅已知样本点的值，还知道样本点的前 <span class="math inline">\(n\)</span> 阶导数值，因而我们希望寻求一插值多项式使得其导数值也与我们的已知数据符合，下面讨论 <span class="math inline">\(n=1\)</span> 的简单情形：</p>
<p>设已知 <span class="math inline">\(f(x)\)</span> 在插值基点 <span class="math inline">\(x_0,x_1,...,x_n\)</span> 处的函数值分别为 <span class="math inline">\(y_0,y_1,...,y_n\)</span> 以及一阶导数值分别为 <span class="math inline">\(y&#39;_0,y&#39;_1,...,y&#39;_n\)</span> <br>我们试求一多项式 <span class="math inline">\(H_{2n+1}\in R[x]_{2n+2}\)</span> 使得： <span class="math display">\[
\left\{ \begin{aligned}
H_{2n+1}(x_i)=y_i\\
H&#39;_{2n+1}(x_i)=y&#39;_i
\end{aligned}\right.
\]</span> 不妨设： <span class="math display">\[
H_{2n+1}=\sum_{i=0}^ny_iA_i(x)+\sum_{i=0}^ny&#39;_iB_i(x)\\
A_i(x_j)=\delta_{ij},\:A&#39;_i(x_j)=0\\
B_i(x_j)=0,\:B&#39;_i(x_j)=\delta_{ij}
\]</span> 可以通过分析 <span class="math inline">\(A_i,\:B_i\)</span> 各自零点的重数设出其形式进而求解，最后可以得到： <span class="math display">\[
B_i(x)=(x-x_i)l_i^2(x)\\
A_i(x)=\left(1-2(x-x_i)\sum_{j=0,j\neq i}^n\frac1{x_i-x_j}\right)l_i^2(x)
\]</span> 与 <span class="math inline">\(Lagrange\)</span> 插值类似，可以证明 <span class="math inline">\(Hermite\)</span> 插值的唯一性，以及其余项可表示为： <span class="math display">\[
r(x)=\frac{f^{(2n+2)}(\xi)}{(2n+2)!}\omega_{n+1}^2(x)
\]</span></p>
<h2 id="分段插值">分段插值</h2>
<p>为了解决高次多项式插值带来的 <span class="math inline">\(Runge\)</span> 现象，可以使用分段插值，也就是将插值区间细分为若干子区间，并在这些子区间内使用较低次数的多项式进行插值的办法，其中最简单的分段插值就是<strong>分段线性插值</strong></p>
<h3 id="分段插值误差界">分段插值误差界</h3>
<p>直观上，采用分段插值时，子区间分的越细，那么分段插值的误差界应该越小 <br>下面我们考虑将插值区间分为等距基点 <span class="math inline">\(x_k-x_{k-1}=h,\forall k=1,2,..,n\)</span> 的情形，由之前对余项的讨论，有：</p>
<ul>
<li><p>分段线性插值： <span class="math display">\[
|e_{f_1(x)}|\leq\frac{1}8Mh^2\\
M=\mathop{max}\limits_{x\in[a,b]}|f&#39;&#39;(x)|
\]</span></p></li>
<li><p>分段抛物线插值（即每一个区间含三个基点采用二次多项式插值）： <span class="math display">\[
|e_{f_2(x)}|\leq\frac{\sqrt{3}}{27} M h^3\\
M=\mathop{max}\limits_{x\in[a,b]}|f&#39;&#39;&#39;(x)|
\]</span></p></li>
</ul>
<h3 id="三次样条插值">三次样条插值</h3>
<p>直接作分段插值的一个严重的问题是得到的结果往往不光滑，因而我们可以考虑在每一区间 <span class="math inline">\([x_i,x_{i+1}]\)</span> 上采用三次多项式插值，并要求每一段的拼接点的导数以及二阶导数相等，这种插值办法被称为三次样条插值</p>
<p>直观上，我们需要求解 <span class="math inline">\(4n\)</span> 个待定系数，然而假设的条件只能给出 <span class="math inline">\(4n-2\)</span> 个方程，因而我们需要附加两个条件，常采用边界条件：</p>
<ul>
<li>自然边界条件：取插值函数在 <span class="math inline">\(x_0, x_n\)</span> 处的二阶导数为 <span class="math inline">\(0\)</span>，这样得到的插值称为<strong>自然三次样条插值</strong></li>
<li>完备边界条件：假设我们已知待插值函数 <span class="math inline">\(f\)</span> 在端点处的导数值，取插值函数在 <span class="math inline">\(x_0, x_n\)</span> 处的导数与之相等即可，这样得到的插值称为<strong>完备三次样条插值</strong></li>
</ul>
<p>下面简要讨论具体的计算，给定 <span class="math inline">\([a,b]\)</span> 的一组基点： <span class="math display">\[
a=x_1&lt;x_2&lt;...&lt;x_{n+1}=b
\]</span> 记 <span class="math inline">\([x_i,x_i+1]\)</span> 上的三次插值多项式为 <span class="math inline">\(S_i(x),\:i=1,2,...,n\)</span>，已知条件为： <span class="math display">\[
S_{i-1}(x_i)=S_i(x_i)=f(x_i),\:i=2,...,n\\
S&#39;_{i-1}(x_i)=S&#39;_i(x_i),\:i=2,...,n\\
S&#39;&#39;_{i-1}(x_i)=S&#39;&#39;_i(x_i),\:i=2,...,n\\
S_1(x_1)=f(x_1),\:S_n(x_{n+1})=f(x_{n+1})
\]</span> 记 <span class="math inline">\(S&#39;&#39;_i(x_i)=m_i,\:h_i=x_{i+1}-x_i\)</span>，因为 <span class="math inline">\(deg\:S&#39;&#39;_i=1\)</span>，结合 <span class="math inline">\(S&#39;&#39;_{i-1}(x_i)=S&#39;&#39;_i(x_i)\)</span> 就知道其必形如： <span class="math display">\[
S&#39;&#39;_i(x)=m_i\frac{x_{i+1}-x}{h_i}+m_{i+1}\frac{x-x_i}{h_i}
\]</span> 对其积分得： <span class="math display">\[
S&#39;_i(x)=-m_i\frac{(x_{i+1}-x)^2}{2h_i}+m_{i+1}\frac{(x-x_i)^2}{2h_i}+A_i\\
S_i(x)=m_i\frac{(x_{i+1}-x)^3}{6h_i}+m_{i+1}\frac{(x-x_i)^3}{6h_i}+A_i(x-x_i)+B_i
\]</span> 结合 <span class="math inline">\(S_i(x_i)=f(x_i),\:S_i(x_{i+1})=f(x_{i+1})\)</span> 可以解得： <span class="math display">\[
B_i=f(x_i)-m_i\frac{h_i^2}6\\
A_i=f[x_i,x_{i+1}]-\frac{h_i}6(m_{i+1}-m_i)
\]</span> 再由 <span class="math inline">\(S&#39;_{i-1}(x_i)=S&#39;_i(x_i)\)</span> 就得到： <span class="math display">\[
h_{i-1}m_{i-1}+2(h_{i-1}+h_i)m_i+h_im_{i+1}=6(f[x_i,x_{i+1}]-f[x_{i-1},x_i])
\]</span> 也就是： <span class="math display">\[
\left(\begin{array}{}
h_1 &amp;2(h_1+h_2) &amp; h_2 &amp; 0 &amp; ... &amp; 0 \\
0 &amp; h_2 &amp;2(h_2+h_3) &amp; h_3 &amp; ... &amp; 0 \\
... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... \\
0 &amp; ... &amp; h_{n-2} &amp;2(h_{n-2}+h_{n-1}) &amp; h_{n-1} &amp; 0\\
0 &amp; 0 &amp; ... &amp; h_{n-1} &amp;2(h_{n-1}+h_{n}) &amp; h_{n} 
\end{array}\right)
\left(\begin{array}{}
m_1\\
m_2\\
...\\
m_n\\
m_{n+1}
\end{array}\right)=6
\left(\begin{array}{}
d_2\\
d_3\\
...\\
d_{n-1}\\
d_n
\end{array}\right)\\\\
d_i=f[x_i,x_{i+1}]-f[x_{i-1},x_i]
\]</span> 前已述该方程没有唯一解，需要补上一定的边界条件，即：</p>
<ul>
<li><p>自然边界条件：<span class="math inline">\(m_1=m_{n+1}=0\)</span></p></li>
<li><p>完备边界条件：<span class="math inline">\(S&#39;_1(a)=f&#39;(a),\:S&#39;_n(b)=f&#39;(b)\)</span>，进而： <span class="math display">\[
2h_1m_1+h_1m_2=6(f[x_1,x_2]-f&#39;(a))\\
h_nm_n+2h_nm_{n+1}=6(f&#39;(b)-f[x_n,x_{n+1}])
\]</span></p></li>
</ul>
<p>补上这些边界条件即有唯一解</p>
<h3 id="基样条插值">基样条插值</h3>
<p>注意到 <span class="math inline">\(Lagrange\)</span> 插值多项式总可以写成 <span class="math inline">\(Lagrange\)</span> 基本多项式 <span class="math inline">\(l_i(x)\)</span> 的线性组合，亦可寻找一<strong>基三次样条系</strong>来表示三次样条插值函数</p>
<p>常见的办法是构造一在区间 <span class="math inline">\([-2,2]\)</span> 上的分段三次多项式 <span class="math inline">\(\varphi(x)\)</span>，使得其在 <span class="math inline">\(x=-1,0,1\)</span> 上面的取值以及导数值，二阶导数值较好，以及在 <span class="math inline">\(x=-2,2\)</span> 上的函数值，导数值，二阶导数值均为 <span class="math inline">\(0\)</span>，从而可以通过将其根据实际的基点位置作平移和伸缩变换得到一系列基函数</p>
<h1 id="函数逼近">函数逼近</h1>
<h2 id="正交函数系">正交函数系</h2>
<p>称 <span class="math inline">\(W(x)\)</span> 为 <span class="math inline">\([a,b]\)</span> 上的权函数，若满足：</p>
<ul>
<li>在 <span class="math inline">\((a,b)\)</span> 中，<span class="math inline">\(W(x)\geq 0\)</span>，且只有有限个零点</li>
<li><span class="math inline">\(\int_a^bx^iW(x)dx,i=1,2,...\)</span> 存在且有限</li>
</ul>
<p>则对于非负连续函数 <span class="math inline">\(f\)</span>，若 <span class="math inline">\(\int_a^bf(x)W(x)dx=0\)</span>，则在 <span class="math inline">\([a,b]\)</span> 上有 <span class="math inline">\(f(x)\equiv 0\)</span></p>
<p>给定 <span class="math inline">\(f,g\in C[a,b]\)</span>，称 <span class="math inline">\((f,g)=\int_a^bW(x)f(x)g(x)dx\)</span> 为函数 <span class="math inline">\(f,g\)</span> 在 <span class="math inline">\([a,b]\)</span> 上关于权 <span class="math inline">\(W(x)\)</span> 的内积 <br>（满足内积的各种性质，亦可以由此定义范数）</p>
<p>我们常用下面三类范数： <span class="math display">\[
\Vert f\Vert_\infty=\mathop{max}_\limits{x\in[a,b]}|f(x)W(x)|\\
\Vert f\Vert_1=\int_a^b|f(x)W(x)|dx\\
\Vert f\Vert_2=\sqrt{(f,f)}
\]</span></p>
<p>称函数系 <span class="math inline">\(\{f_n(x)\}\)</span> 为 <span class="math inline">\([a,b]\)</span> 上关于权函数 <span class="math inline">\(W(x)\)</span> 的正交函数系，若 <span class="math inline">\((f_i,f_j)=A_i\delta_{ij}\)</span></p>
<h3 id="线性无关">线性无关</h3>
<p>可以与线性代数理论类似考虑一族函数的线性无关性，称函数系 <span class="math inline">\(\{f_n(x)\}\)</span> 在 <span class="math inline">\([a,b]\)</span> 上线性无关，若： <span class="math display">\[
\sum_{i=0}^na_if_i=0 \Rightarrow a_i=0,\forall i=0,1,...,n
\]</span> 可以证明这等价于： <span class="math display">\[
\left|
\begin{array}{}
(f_0,f_0) &amp; (f_0,f_1) &amp;... &amp;(f_0,f_n)\\
(f_1,f_0) &amp; (f_1,f_1) &amp;... &amp;(f_1,f_n)\\
... &amp; ... &amp; ... &amp; ... \\
(f_n,f_0) &amp; (f_n,f_1) &amp;... &amp;(f_n,f_n)
\end{array}
\right|\neq0
\]</span> 该行列式被称为 <span class="math inline">\(Gram\)</span> 行列式</p>
<p>可以用 <span class="math inline">\(Schmidt\)</span> 正交化将一族线性无关函数化为正交函数系，即： <span class="math display">\[
\varphi_0=f_0\\
\varphi_n=f_n-\sum_{i=0}^{n-1}\frac{(f_n,f_i)}{(f_i,f_i)}f_i
\]</span></p>
<h2 id="直交多项式">直交多项式</h2>
<p>取线性无关的多项式序列 <span class="math inline">\(\{1,x,...,x^n\}\)</span>，称由此通过 <span class="math inline">\(Schmidt\)</span> 正交化得到的正交函数系为直交多项式 <span class="math inline">\(\{p_n(x)\}\)</span> <br>可以证明有递推关系： <span class="math display">\[
\begin{aligned}
&amp;p_{k+1}(x)=(x-\alpha_k)p_k(x)-\beta_kp_{k-1}(x)\\
&amp;p_0=1,\:p_{-1}=0\\
&amp;其中:\\
&amp;\alpha_k=\frac{(xp_k(x),p_k(x))}{(p_k(x),p_k(x))}\\
&amp;\beta_k=\left\{
\begin{align}
&amp;\frac{(p_k(x),p_k(x))}{(p_{k-1}(x),p_{k-1}(x))},k\geq1\\
&amp;0,k=0
\end{align}
\right.\\
\end{aligned}
\]</span></p>
<h3 id="chebyshev-多项式"><span class="math inline">\(Chebyshev\)</span> 多项式</h3>
<p>取权函数 <span class="math inline">\(W(x)=\frac1{\sqrt{1-x^2}}\)</span>，区间 <span class="math inline">\([a,b]=[-1,1]\)</span>，由此得到 <span class="math inline">\(Chebyshev\)</span> 多项式，可表示为： <span class="math display">\[
T_n(x)=cos(n\:arccos\:x)
\]</span> 显然，取 <span class="math inline">\(x=cos\theta\)</span>，据三角公式就有： <span class="math display">\[
T_{n\pm1}(x)=cos(n\pm1)\theta=cos(n\theta)cos\theta\mp sin(n\theta)sin\theta
\]</span> 两式相加就能得到递推关系： <span class="math display">\[
T_{n+1}(x)+T_{n-1}(x)=2xT_n(x)
\]</span> 利用 <span class="math inline">\(Euler\)</span> 公式，有：<span class="math inline">\(cos\:n\theta=\frac{e^{in\theta}+e^{-in\theta}}2\)</span>，由此亦可直接证明： <span class="math display">\[
T_n(x)=\frac12\left((x+\sqrt{x^2-1})^n+(x-\sqrt{x^2-1})^n\right)
\]</span> #### 近似最佳一致逼近</p>
<p>固定 <span class="math inline">\(z&gt;1\)</span>，记 <span class="math inline">\(\theta_n \subseteq R[x]_{n+1}\)</span> 为满足条件 <span class="math inline">\(\forall p_n \in \theta_n\)</span> ，都有 <span class="math inline">\(p_n(z)=1\)</span> 的集合，那么： <span class="math display">\[
\left\Vert\frac{T_n(x)}{T_n(z)}\right\Vert_\infty=\mathop{inf}_\limits{p_n\in \theta_n}\Vert p_n \Vert_\infty
\]</span> 类似地，记 <span class="math inline">\(\bar{T}_n(x)\)</span> 为 <span class="math inline">\(T_n(x)\)</span> 的首一化多项式，也就是：<span class="math inline">\(\bar{T}_n(x)=\frac1{2^{n-1}}T_n(x)\)</span>，那么任给 <span class="math inline">\(n\)</span> 次首一多项式 <span class="math inline">\(p_n(x)\)</span>，都有： <span class="math display">\[
\Vert p_n\Vert_\infty\geq\Vert\bar{T}_n\Vert_\infty=\frac1{2^{n-1}}\:\:\:\:(W(x)=1)
\]</span> 当且仅当 <span class="math inline">\(p_n=\bar{T}_n\)</span> 时取等，这说明要想使得对定义在 <span class="math inline">\([-1,1]\)</span> 上的函数 <span class="math inline">\(f\)</span> 作 <span class="math inline">\(n\)</span> 次多项式插值得到的余项较小，可以将插值基点选取为 <span class="math inline">\(T_{n+1}(x)\)</span> 的零点，即： <span class="math display">\[
x_i=cos\frac{(2i+1)\pi}{2(n+1)},i=0,1,...,n
\]</span> 对于一般的定义在 <span class="math inline">\([a,b]\)</span> 上的函数 <span class="math inline">\(f\)</span>，作平移和伸缩变换再类似处理即可，也就是： <span class="math display">\[
[a,b]\to[-1,1]:x\to\frac2{b-a}(x-\frac{b-a}2)\\
\frac2{b-a}(x_i-\frac{b-a}2)=cos\frac{(2i+1)\pi}{2(n+1)},i=0,1,...,n
\]</span></p>
<p>由此可以得到一个近似的最佳一致逼近多项式，关于最佳一致逼近的具体讨论在后续部分</p>
<h4 id="第二类-chebyshev-多项式">第二类 <span class="math inline">\(Chebyshev\)</span> 多项式</h4>
<p>与第一类的唯一差别是权函数取为 <span class="math inline">\(W(x)=\sqrt{1-x^2}\)</span>，将其记为 <span class="math inline">\(\{U_n(x)\}\)</span>，可以表示为： <span class="math display">\[
U_n(x)=\frac{sin\left((n+1)arccos\:x\right)}{\sqrt{1-x^2}}
\]</span> 其与第一类有关系式： <span class="math display">\[
T_{n+1}&#39;(x)=(n+1)U_n(x)
\]</span></p>
<h3 id="legendre-多项式"><span class="math inline">\(Legendre\)</span> 多项式</h3>
<p>取最简单的权函数 <span class="math inline">\(W(x)=1\)</span>，区间 <span class="math inline">\([a,b]=[-1,1]\)</span>，得 <span class="math inline">\(Legendre\)</span> 多项式，可以表示为： <span class="math display">\[
p_n(x)=\frac1{2^nn!}\frac{d^n}{dx^n}(x^2-1)^n
\]</span> 其用处在这门课主要体现在<strong>高斯型求积公式</strong>中，故更多性质此处暂且不谈</p>
<h2 id="最佳一致逼近">最佳一致逼近</h2>
<p>取 <span class="math inline">\(W(x)=1\)</span>，设 <span class="math inline">\(f\in C[a,b]\)</span>，若有一列函数 <span class="math inline">\(\{f_n\}\)</span> 使得： <span class="math display">\[
\lim_{n\to\infty}\Vert f-f_n\Vert_\infty=0
\]</span> 称 <span class="math inline">\(\{f_n\}\)</span> 为 <span class="math inline">\(f\)</span> 的一致逼近函数，不难看出也就是在 <span class="math inline">\([a,b]\)</span> 上一致收敛于 <span class="math inline">\(f\)</span></p>
<p>我们在数学分析的课程上已经知道 <span class="math inline">\(Weierstrass\)</span> 给出的关于多项式一致逼近的相关结果，即 <span class="math inline">\(\forall \varepsilon&gt;0,\exists p_n(x)\)</span> 使得： <span class="math display">\[
\Vert f-p_n\Vert_\infty&lt;\varepsilon
\]</span> 然而我们知道多项式拟合的次数太高并不好，下面我们固定 <span class="math inline">\(n\)</span>，考虑在次数不超过 <span class="math inline">\(n\)</span> 的多项式集合 <span class="math inline">\(H_n\)</span> 中寻求 <span class="math inline">\(p_n\)</span> 使得： <span class="math display">\[
\Vert f-p_n\Vert_\infty=\mathop{inf}_\limits{q_n\in H_n}\Vert f-q_n\Vert_\infty
\]</span> 这就是<strong>最佳一致逼近多项式</strong>问题，关于这个问题，<span class="math inline">\(Chebyshev\)</span> 给出了以下结果：</p>
<ol type="1">
<li><p>设 <span class="math inline">\(a\leq x_1&lt;x_2&lt;...&lt;x_n\leq b\)</span>，称 <span class="math inline">\(\{x_1,x_2,...,x_n\}\)</span> 为 <span class="math inline">\(f\)</span> 在 <span class="math inline">\([a,b]\)</span> 上的交错点组，若满足： <span class="math display">\[
|f(x_i)|=\mathop{max}_\limits{x\in[a,b]}|f(x)|,\forall i=1,2,...,n\\
f(x_i)=-f(x_{i+1}),\forall i=1,2,...,n-1
\]</span></p></li>
<li><p>（<span class="math inline">\(Chebyshev\)</span> 定理）设 <span class="math inline">\(p\in H_n\)</span>，则 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(f\)</span> 的最佳一致逼近多项式当且仅当 <span class="math inline">\(f(x)-p(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 上存在 <span class="math inline">\(n+2\)</span> 个点组成的交错点组</p></li>
<li><p>上述 <span class="math inline">\(p(x)\)</span> 在 <span class="math inline">\(H_n\)</span> 中是唯一的</p></li>
<li><p>若 <span class="math inline">\(f^{(n+1)}(x)\)</span> 在 <span class="math inline">\([a,b]\)</span> 中不变号，则 <span class="math inline">\(a,b\)</span> 属于交错点组</p></li>
</ol>
<h2 id="最佳平方逼近">最佳平方逼近</h2>
<p>与最佳一致逼近类似，只是考虑的范数由 <span class="math inline">\(\infty\)</span> 范数改为了 <span class="math inline">\(2\)</span> 范数，我们考察一般情形：</p>
<p>设 <span class="math inline">\(f\in C[a,b],\:\{\varphi_n\}\)</span> 为 <span class="math inline">\([a,b]\)</span> 上的线性无关函数族，我们希望寻求 <span class="math inline">\(a_0,a_1,...,a_n\)</span> 使得： <span class="math display">\[
\Vert f-\sum_{k=0}^na_k\varphi_k\Vert_2
\]</span> 达到极小；考察其平方不影响结果，从而可以使用多元函数求极值的办法给出结论： <span class="math display">\[
F(a_0,a_1,...,a_n)=\int_a^b\left(f(x)-\sum_{k=0}^na_k\varphi_k(x)\right)^2W(x)dx\\
\frac{\partial F}{\partial a_j}=2\int_a^b\left(f(x)-\sum_{k=0}^na_k\varphi_k(x)\right)(-\varphi_j(x))W(x)dx=0
\]</span> 也就是： <span class="math display">\[
\left(
\begin{array}{}
(\varphi_0,\varphi_0) &amp; (\varphi_0,\varphi_1) &amp;... &amp;(\varphi_0,\varphi_n)\\
(\varphi_1,\varphi_0) &amp; (\varphi_1,\varphi_1) &amp;... &amp;(\varphi_1,\varphi_n)\\
... &amp; ... &amp; ... &amp; ... \\
(\varphi_n,\varphi_0) &amp; (\varphi_n,\varphi_1) &amp;... &amp;(\varphi_n,\varphi_n)
\end{array}
\right)
\left(
\begin{array}{}
a_0\\
a_1\\
...\\
a_n
\end{array}
\right)=\left(
\begin{array}{}
(f,\varphi_0)\\
(f,\varphi_1)\\
...\\
(f,\varphi_n)
\end{array}
\right)
\]</span> 这被称为<strong>法方程</strong>，据 <span class="math inline">\(\{\varphi_n\}\)</span> 线性无关知其系数矩阵行列式不为 <span class="math inline">\(0\)</span>，从而存在唯一解</p>
<p>特别地，若 <span class="math inline">\(\{\varphi_n\}\)</span> 为正交函数系，则系数矩阵为对角矩阵，进而直接有： <span class="math display">\[
a_k=\frac{(f,\varphi_k)}{(\varphi_k,\varphi_k)}
\]</span> 进一步，如果让 <span class="math inline">\(n\to\infty\)</span>，这就给出了 <span class="math inline">\(f\)</span> 的广义 <span class="math inline">\(Fourier\)</span> 级数</p>
<p>若正交函数系取为 <span class="math inline">\(Chebyshev\)</span> 多项式 <span class="math inline">\(\{T_n(x)\}\)</span>，由此就得到 <span class="math inline">\(f\)</span> 在 <span class="math inline">\([-1,1]\)</span> 上的 <span class="math inline">\(Chebyshev\)</span> 级数： <span class="math display">\[
f(x)=\frac12a_0+\sum_{n=1}^\infty a_nT_n(x)\\
a_k=\frac{(T_k,f)}{(T_k,T_k)}=\frac2\pi\int_{-1}^1T_k(x)f(x)\frac{dx}{\sqrt{1-x^2}}
\]</span></p>
<h3 id="离散情形">离散情形</h3>
<p>与连续情形类似，若已知 <span class="math inline">\(f\)</span> 在给定点集 <span class="math inline">\(\{x_1,x_2,...,x_m\}\)</span> 上的值，记： <span class="math display">\[
r_i=\sum_{j=0}^na_j\varphi_j(x_i)-f(x_i)
\]</span> 为<strong>残量</strong>，亦可寻求 <span class="math inline">\(a_0,a_1,...,a_n\)</span> 使得： <span class="math display">\[
\sum_{i=0}^mr_i^2
\]</span> 达到极小，这样的问题被称为<strong>离散的最佳平方逼近问题</strong>，也就是<strong>线性最小二乘拟合问题</strong>，在后续部分讨论</p>
<p>在等距点集情形，我们有著名的 <strong>DFT</strong> 以及 <strong>FFT</strong>，此前已作过其浅析，详见：<a href="https://dasasdhba.github.io/study-FFT/" class="uri">https://dasasdhba.github.io/study-FFT/</a></p>
<h1 id="数据拟合">数据拟合</h1>
<p>数据拟合问题是指寻求一函数 <span class="math inline">\(f(x)\)</span> 来拟合一组离散数据 <span class="math inline">\(\{(x_i,y_i)\}_{i=1}^m\)</span>，与插值法不同，我们采用<strong>均方误差</strong>（mean-square error MSE）来衡量拟合的好坏，也就是考虑： <span class="math display">\[
\mathcal{L}(f)=\frac1m\sum_{i=1}^m(f(x_i)-y_i)^2
\]</span> 一般地，给定函数族 <span class="math inline">\(\mathcal{F}\)</span>，我们试图求解 <span class="math inline">\(f\in\mathcal{F}\)</span> 使得： <span class="math display">\[
\mathcal{L}(f)=\mathop{inf}_\limits{g\in\mathcal{F}}\mathcal{L}(g)
\]</span></p>
<h2 id="线性拟合">线性拟合</h2>
<p>下面介绍线性拟合的<strong>最小二乘法</strong>，这与最佳平方逼近是类似的</p>
<p>设 <span class="math inline">\(f\in C[a,b],\:\{\varphi_n\}\)</span> 为 <span class="math inline">\([a,b]\)</span> 上的线性无关函数族，我们希望寻求 <span class="math inline">\(a_0,a_1,...,a_n\)</span> 使得： <span class="math display">\[
\varphi(x)=\sum_{j=0}^na_j\varphi_j\\
\mathcal{L}(\varphi)=\frac1m\sum_{i=1}^m(\varphi(x_i)-y_i)^2
\]</span> 达到极小；类似地，可以使用多元微积分求极值的理论： <span class="math display">\[
F(a_0,...,a_n)=\sum_{i=1}^m(\sum_{j=0}^na_j\varphi_j(x_i)-y_i)^2\\
\frac{\partial F}{\partial a_k}=2\sum_{i=1}^m\varphi_k(x_i)(\sum_{j=0}^na_j\varphi_j(x_i)-y_i)=0
\]</span> 记 <span class="math inline">\(Y=(y_1,...,y_m)^T,\:\Phi_i=(\varphi_i(x_1),...,\varphi_i(x_m))^T\)</span>，取 <span class="math inline">\(\mathbb{R}^m\)</span> 这个 <span class="math inline">\(Euclid\)</span> 空间的通常内积 <span class="math inline">\((X,Y)=X^TY\)</span>，则上述方程可以改写为： <span class="math display">\[
\left(
\begin{array}{}
(\Phi_0,\Phi_0) &amp; (\Phi_0,\Phi_1) &amp;... &amp;(\Phi_0,\Phi_n)\\
(\Phi_1,\Phi_0) &amp; (\Phi_1,\Phi_1) &amp;... &amp;(\Phi_1,\Phi_n)\\
... &amp; ... &amp; ... &amp; ... \\
(\Phi_n,\Phi_0) &amp; (\Phi_n,\Phi_1) &amp;... &amp;(\Phi_n,\Phi_n)
\end{array}
\right)
\left(
\begin{array}{}
a_0\\
a_1\\
...\\
a_n
\end{array}
\right)=\left(
\begin{array}{}
(Y,\Phi_0)\\
(Y,\Phi_1)\\
...\\
(Y,\Phi_n)
\end{array}
\right)
\]</span> 由此即可解出 <span class="math inline">\(a_0,...,a_n\)</span>；特别地，若取 <span class="math inline">\(n=1, \varphi_0(x)=1,\varphi_1(x)=x\)</span>，得到： <span class="math display">\[
\begin{aligned}
&amp;\left\{\begin{align}
&amp;a_1=\frac{(\Phi_1,Y)-m\bar{x}\bar{y}}{(\Phi_1,\Phi_1)-m\bar{x}\bar{y}}=\frac{\sum_{i=1}^m(x_i-\bar{x})(y_i-\bar{y})}{\sum_{i=1}^m(x_i-\bar{x})^2}\\
&amp;a_0=\bar{y}-a_1\bar{x}\\
\end{align}\right.\\
&amp;其中:\\
&amp;\bar{x}=\sum_{i=1}^mx_i,\:\bar{y}=\sum_{i=1}^my_i
\end{aligned}
\]</span> 即中学阶段已经介绍过的最小二乘法求解回归直线方程</p>
<h3 id="过拟合现象">过拟合现象</h3>
<p>若取 <span class="math inline">\(\{\varphi_n\}=\{x^n\}\)</span>，直观上 <span class="math inline">\(n\)</span> 越大误差越小，然而与 <span class="math inline">\(Runge\)</span> 现象类似，过高的拟合次数会产生<strong>过拟合现象</strong></p>
<h2 id="非线性拟合">非线性拟合</h2>
<p>非线性拟合是考虑用不能被一族函数的线性组合所表出的函数作拟合，如： <span class="math display">\[
f(x)=\frac a{1+be^{cx}}
\]</span> 我们的目标是寻求待定系数 <span class="math inline">\(a,b,c\)</span> 使得 <span class="math inline">\(\mathcal{L}(f)\)</span> 达到极小</p>
<h3 id="线性化求近似解">线性化求近似解</h3>
<p>若有一向量值函数 <span class="math inline">\(F:\mathbb{R}^2 \to \mathbb{R}^2\)</span> 使得 <span class="math inline">\(\{F(x_i,y_i)\}_{i=1}^m\)</span> 可以用一族函数的线性组合来拟合，则可以使用线性拟合的办法求近似解 <br>（化曲为直）</p>
<p>举例，若离散数据符合非线性函数： <span class="math display">\[
y=\frac1{1+ae^{bx}}
\]</span> 这可以改写为： <span class="math display">\[
ln\left(\frac 1y-1\right)=bx+ln\:a
\]</span> 这就把问题转换为了线性拟合，注意到由此得到的是： <span class="math display">\[
\bar{\mathcal{L}}(a,b)=\frac1m\sum_{i=0}^m\left|bx_i+lna-ln\left(\frac 1y_i-1\right)\right|^2
\]</span> 达到极小，故这是原非线性拟合问题的一个近似解</p>
<h3 id="梯度下降法">梯度下降法</h3>
<p>考虑使用非线性函数 <span class="math inline">\(f(x;a_1,...,a_n)\)</span> 作非线性拟合，其中 <span class="math inline">\(a_1,...,a_n\)</span> 为待定系数，我们试图寻求待定系数使得： <span class="math display">\[
F(a_1,...,a_n)=\mathcal{L}(f(x;a_1,...,a_n))
\]</span> 达到极小；据多元微积分理论，<span class="math inline">\(\forall a \in \mathbb{R}^n\)</span>，<span class="math inline">\(F\)</span> 在 <span class="math inline">\(a\)</span> 处沿着梯度方向变化最快，其中梯度是指： <span class="math display">\[
\nabla F(a)=\left(\frac{\partial F}{\partial a_1},...,\frac{\partial F}{\partial a_n}\right)(a)
\]</span> （方便起见，这里没有加上转置符号）</p>
<p>因而可以通过从某一初值 <span class="math inline">\(a\)</span> 开始，沿着梯度方向不断迭代的办法近似求解 <span class="math inline">\(F\)</span> 的极小值点，这被称为<strong>梯度下降法</strong>，算法如下： <span class="math display">\[
\begin{aligned}
&amp;a=(b_1,...,b_n)\:为初值\\
&amp;\eta=10^{-4}\:为步长，又称学习率\\
&amp;\varepsilon=10^{-8}\:为终止条件\\
\\
&amp;while\;\Vert\nabla F(a)\Vert_2 \geq \varepsilon:\\
&amp;\;\;\;\;a=a-\eta\:\nabla F(a)
\end{aligned}
\]</span> 其中 <span class="math inline">\(\eta\)</span> 的选取至关重要，太大没法收敛，太小收敛太慢；另一方面，这种算法显然只能得到局部极小值，不能保证其为全局极小值点，因而适当的选取初值也较为重要，可以通过线性化先求解一近似解作为初值</p>
<h1 id="后记">后记</h1>
<ol type="1">
<li><p>这门课其实还讲了点 <strong>M-P 神经网络</strong>，然而感觉讲的太快太浅，偏科普性质（问就是感觉自己学了个寂寞），故没有整理至此</p></li>
<li><p>封面是我有一次把梯度下降方向搞反了搞成了“梯度上升”的图像捏，挺壮观的是不是（（（</p></li>
<li><p>目前内容截至到期中，期末的等期末再说（</p></li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">dasasdhba</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://dasasdhba.github.io/study-numeric-analysis/">http://dasasdhba.github.io/study-numeric-analysis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://dasasdhba.github.io" target="_blank">dasasdhba</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2023/04/24/p9mR80O.jpg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/study-FFT/"><img class="next_cover lazyload" data-src="https://allsignalprocessing.com/wp-content/uploads/2014/06/fast-fourier-transform.png" onerror="onerror=null;src='http://yanxuan.nosdn.127.net/17d506bee5c563ab6285b5b1c2e95599.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">「数值分析」浅析快速傅里叶变换 FFT</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/study-FFT/" title="「数值分析」浅析快速傅里叶变换 FFT"><img class="relatedPosts_cover lazyload"data-src="https://allsignalprocessing.com/wp-content/uploads/2014/06/fast-fourier-transform.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2023-03-29</div><div class="relatedPosts_title">「数值分析」浅析快速傅里叶变换 FFT</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://unpkg.com/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  appId: 'qKzKTqLS4IP0grV2Pq1waGQt-MdYXbMMI',
  appKey: 'sYVhbspdU7W0iDOAMjPrtQ7c',
  placeholder: '写个评论吧~',
  avatar: 'mp',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: true,
  serverURLs: '',
  mathjax: false
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By dasasdhba</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/search/local-search.js"></script></body></html>